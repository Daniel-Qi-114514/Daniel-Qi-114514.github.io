<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Welcome to DanielQi&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://mermaid-js.github.io/mermaid/"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Welcome to DanielQi&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['from import to export', 'from asking to serving', 'from idea to reality'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">一个安静优雅的hexo主题，拥有轻量化页面。</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-多态"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/09/%E5%A4%9A%E6%80%81/"
    >方法重写与多态</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/09/%E5%A4%9A%E6%80%81/" class="article-date">
  <time datetime="2022-02-09T12:39:06.000Z" itemprop="datePublished">2022-02-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">课程笔记_面向对象编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"><a href="#本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。" class="headerlink" title="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"></a>本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。</h2><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><h2 id="我们为什么需要方法重写？"><a href="#我们为什么需要方法重写？" class="headerlink" title="我们为什么需要方法重写？"></a>我们为什么需要方法重写？</h2><p>有一个父类/超类叫pet，它有两个子类dog和cat，dog和cat有共同的属性名字和性别，有共同的输入和输出信息方法setInfo()和showInfo(),将这些属性和方法都写在父类里。现在有新的要求，dog增加了一个属性是品种，cat增加了一个属性是体重，这时候发现方法原来的写法不能同时满足两个子类不同属性的输出，此时我们提出三种解决方案：</p>
<ol>
<li>删除父类的方法，在子类内分别写方法并调用：这种方法简单粗暴，但是一旦像这样的同时具有相同和不同属性与方法的子类增多，会使得代码有很多重复的部分，增大了工作量。</li>
<li>保留父类的方法，同时将不同的部分分别写入子类专属的方法内：这种方法较上一种的工作量减少了，但是在调用的时候会变得麻烦，既然都是输入输出信息的功能，为什么不让它们名称相同呢？</li>
<li>子类<strong>重写</strong>父类方法：<ul>
<li>子类根据需求对从父类继承的方法进行重新编写</li>
<li>重写时，可以用super.方法的方式保留父类的方法</li>
<li><strong>构造方法不能被重写</strong></li>
</ul>
</li>
</ol>
<h2 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h2><ul>
<li><strong>方法名相同</strong></li>
<li><strong>参数列表相同</strong></li>
<li><strong>返回值类型相同或是其子类</strong></li>
<li><strong>访问权限不能严于父类</strong></li>
<li><strong>父类的私有方法不能被子类覆盖</strong></li>
<li><strong>子类方法不能抛出比父类方法更多的异常</strong></li>
<li><strong>父类的静态方法不能被子类覆盖为非静态方法，父类的非静态方法也不能被子类覆盖为静态方法</strong></li>
<li>由于super不能在静态方法中使用，因此子类可以定义与父类同名的静态方法，以便在子类中隐藏父类的静态方法</li>
</ul>
<h2 id="代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）"><a href="#代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）" class="headerlink" title="代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）"></a>代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（<del>说什么我都开摆！</del>）</h2><h3 id="父类写法"><a href="#父类写法" class="headerlink" title="父类写法"></a>父类写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Pet &#123;//父类</span><br><span class="line">    //按照方法1的写法，这里可以啥都没有x</span><br><span class="line">    public String name;//方法2中这里要保留</span><br><span class="line">    public String sex;</span><br><span class="line">    //方法3写法（方法2中父类的写法和方法3一致，故略）</span><br><span class="line">    public void setInfo(String name, String sex)&#123;</span><br><span class="line">    	this.name=name;</span><br><span class="line">    	this.sex=sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showInfo()&#123;</span><br><span class="line">    	System.out.println(&quot;宠物的名字是：&quot;+name+&quot;，宠物的性别是：&quot;+sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="子类写法"><a href="#子类写法" class="headerlink" title="子类写法"></a>子类写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Pet&#123;//子类</span><br><span class="line">    private float weight;//体重</span><br><span class="line">    private String name;//名字</span><br><span class="line">    private String sex;//性别</span><br><span class="line">    /*方法1写法</span><br><span class="line">     public void setInfo(String name,String sex, float weight)&#123;</span><br><span class="line">    	 this.name = name;//这里实际上略写了name和sex的声明，这两个属性的声明可以在父类中以public关键字做保留，也可以在子类中写</span><br><span class="line">    	 this.sex = sex;</span><br><span class="line">    	 this.weight = weight;</span><br><span class="line">     &#125;</span><br><span class="line">     public void showInfo()&#123;</span><br><span class="line">    	 System.out.println(&quot;宠物的名字是：&quot;+name+&quot;，宠物的性别是：&quot;+sex+&quot;，猫的体重是&quot;+weight);</span><br><span class="line">     &#125;</span><br><span class="line">     */</span><br><span class="line">    /*方法2写法</span><br><span class="line">     public void setInfo(String name,String sex, float weight)&#123;</span><br><span class="line">    	 this.name = name;</span><br><span class="line">    	 this.sex = sex;</span><br><span class="line">    	 this.weight = weight;</span><br><span class="line">     &#125;</span><br><span class="line">     public void showCatInfo()&#123;//注意此处的改名</span><br><span class="line">         showInfo();</span><br><span class="line">    	 System.out.println(&quot;猫的体重是&quot;+weight);</span><br><span class="line">     &#125;</span><br><span class="line">     */</span><br><span class="line">    //方法3写法</span><br><span class="line"></span><br><span class="line">    public void showInfo()&#123;</span><br><span class="line">    	super.showInfo();</span><br><span class="line">        System.out.println(&quot;猫的体重是&quot;+weight+&quot;kg&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><ul>
<li>super可以用来访问父类的<strong>非私有（private）成员</strong></li>
<li><strong>静态方法中不能出现super</strong></li>
<li>当子类中定义了和父类同名的成员时，super可以使被屏蔽的成员可见</li>
<li>super只能出现在<strong>子类的方法和构造方法中</strong></li>
<li>super调用父类构造方法时，只能是super所在方法的第一句</li>
<li>super可以用于调用<strong>继承关系中最近</strong>的父类/间接父类的成员<ul>
<li>当子类、父类、间接父类中都有同名的成员时（子类重写/覆盖父类，父类重写/覆盖间接父类）时，子类中使用super只能访问父类的成员。</li>
<li>当子类和间接父类中有同名成员时，子类中使用super可以访问<strong>继承关系中最近</strong>的间接父类成员。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//访问父类方法</span><br><span class="line">super.print();</span><br><span class="line">//访问父类属性</span><br><span class="line">super.name;</span><br><span class="line">//访问父类构造方法</span><br><span class="line">super();</span><br><span class="line">super(name)</span><br></pre></td></tr></table></figure>
<h3 id="super和this比较"><a href="#super和this比较" class="headerlink" title="super和this比较"></a>super和this比较</h3><table>
<thead>
<tr>
<th>区别</th>
<th align="center">this</th>
<th align="right">super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td align="center">访问<strong>本类</strong>属性，如果没有则从父类找</td>
<td align="right">访问<strong>父类</strong>属性</td>
</tr>
<tr>
<td>访问普通方法</td>
<td align="center">访问<strong>本类</strong>普通方法，如果没有则从父类找</td>
<td align="right">访问<strong>父类</strong>普通方法</td>
</tr>
<tr>
<td>访问构造方法</td>
<td align="center">调用<strong>本类</strong>构造，放在构造方法首行</td>
<td align="right">调用<strong>父类</strong>构造，放在子类构造方法首行</td>
</tr>
</tbody></table>
<h3 id="继承条件下的构造方法"><a href="#继承条件下的构造方法" class="headerlink" title="继承条件下的构造方法"></a>继承条件下的构造方法</h3><ul>
<li>当子类构造方法没有通过super显式调用父类的<strong>带参</strong>构造方法，也没有通过this显式调用自身其他构造方法时，系统默认调用父类的<strong>无参构造方法</strong></li>
<li>相对的，当子类构造方法通过super显式调用父类的<strong>带参构造方法</strong>时，系统执行父类的带参构造方法而不执行父类的<strong>无参构造方法</strong></li>
<li>子类构造方法通过this显式调用自身的其他构造方法，在相应构造方法中应用上述两条规则</li>
<li><strong>注意，子类的构造方法在执行时，无论是否有显式给出，父类的构造方法在逻辑顺序上永远是第一个执行的</strong></li>
</ul>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="Object类是什么？"><a href="#Object类是什么？" class="headerlink" title="Object类是什么？"></a>Object类是什么？</h2><ul>
<li><strong>Object类是所有类的直接或间接父类</strong>，而且是继承关系<strong>最远</strong>的那个直接或间接父类<h2 id="Object类有什么？"><a href="#Object类有什么？" class="headerlink" title="Object类有什么？"></a>Object类有什么？</h2></li>
<li><strong>自己找个IDE（比如myeclipse），新建类然后写个this，Object类里的东西就在提示弹窗里显示出来了</strong></li>
<li>Object类被子类经常重写的方法<ul>
<li><strong>toString()</strong>: 返回当前对象本身的有关信息，按字符串对象返回</li>
<li><strong>equals()</strong>: 比较两个对象是否是同一个对象，是则返回true</li>
<li><strong>hashCode()</strong>: 返回该对象的哈希值</li>
<li><strong>getClass()</strong>: 获取当前对象所属的类信息，返回Class对象</li>
</ul>
</li>
</ul>
<p><strong>此处的小补充</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//equals函数判断是否是一个对象的依据是看两个对象是否占用同一处内存</span><br><span class="line">//这里假设有一个Student类</span><br><span class="line">Student s1 = new Student();</span><br><span class="line">Student s2 = new Student();</span><br><span class="line">Student s3 = s1;</span><br><span class="line">System.out.println(s1.equals(s3));//结果为true</span><br><span class="line">System.out.println(s1.equals(s2));//结果为false，因为二者成员虽然一样，但在不占用同一处内存。</span><br></pre></td></tr></table></figure>
<h2 id="重写Object类的方法（此处以重写equals方法为例）"><a href="#重写Object类的方法（此处以重写equals方法为例）" class="headerlink" title="重写Object类的方法（此处以重写equals方法为例）"></a>重写Object类的方法（此处以重写equals方法为例）</h2><p>我们接着上面的问题来，如果两个学生类的所有属性都一样，按理说它们指的就是一个人，但按照equals()的原理却不能认为两个对象相同，即当<strong>认为属性相同就是同一对象</strong>时，就有了重写equals()的需要。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//如果两个学生的属性（此处为姓名name和学号sid）相同，就认为是同一个学生对象。</span><br><span class="line">public boolean equals(Object obj)&#123;//注意，此处是Student的equals方法。</span><br><span class="line">    //如果占用的是同一处内存</span><br><span class="line">    if(this == obj)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //此处应用instanceof运算符，“对象a instanceof 类型b”的意思是判断a是否为b的实例</span><br><span class="line">    elif(!(obj instance of Student))&#123;//如果对象不是Student类型</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Student s = (Student)Obj;//将Obj强制转换为student类型，这里实际上也可以省去这一步，但是这样更保险一些。</span><br><span class="line">    if (this.name==s.name&amp;&amp;this.sid==s.sid)//这里判断name是否相同还有一种写法就是“this.name.equals(s.name)”，由此可见Java.lang.String已经重写过一遍equals方法，使其可以用于判断字符串是否相同。</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="我们为什么需要多态？"><a href="#我们为什么需要多态？" class="headerlink" title="我们为什么需要多态？"></a>我们为什么需要多态？</h2><p>接着上面说过的dog、cat和pet类继续讲，现在我们设定pet类增加了健康值health这个属性，当健康值小于50时，认定宠物生病了，需要治疗，我们将治疗方法cure()放在新建的主人类master里，治疗方法的内容是显示治疗方案和修改宠物实例的health值为60。而不同的宠物需要不同的治疗方式，我们设定治疗猫时需要显示“打针”，治疗狗时需要显示“吃药”。我们可以使用<strong>方法重载</strong>来实现，主人类的代码此时如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Master&#123;</span><br><span class="line">    public void cure(Cat cat)&#123;</span><br><span class="line">        if(cat.health&lt;50)&#123;</span><br><span class="line">         System.out.println(&quot;打针&quot;);</span><br><span class="line">         cat.health=60;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    public void cure(Dog dog)&#123;</span><br><span class="line">        if(dog.health&lt;50)&#123;</span><br><span class="line">         System.out.println(&quot;吃药&quot;);</span><br><span class="line">         dog.health=60</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但当宠物的种类变多时，这种写法会需要频繁修改，更不用说如果不止是主人类需要有这个cure方法，<strong>还有其他和主人类类似的类需要有这个cure方法时</strong>，就会导致代码<strong>臃肿、可扩展性、可维护性差</strong>，因此我们需要多态来优化。</p>
<h2 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h2><p>多态：<strong>同一个引用类型，使用不同的实例而执行不同的操作</strong><br><strong>使用父类作为方法的形参，是Java中实现和使用多态的主要方式。</strong><br><strong>使用父类作为方法的返回值，也是Java中实现和使用多态的主要方式。</strong><br>我们接着来看刚才的例子。我们的优化思路是将治疗方法cure移到父类pet内，pet的各个子类重写父类的pet方法，此时主人类、父类、子类的代码简化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public void cure(Pet pet)&#123;//父类作为方法的形参</span><br><span class="line">        if(pet.health&lt;50)&#123;</span><br><span class="line">          pet.cure();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pet&#123;//父类写法</span><br><span class="line">     public int health;</span><br><span class="line">     public String name;</span><br><span class="line">     public String sex;</span><br><span class="line">     public void cure()&#123;</span><br><span class="line">       //这里不要写属性的修改，因为修改的是子类的属性（我好像在说废话x）</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Cat extends Pet&#123;//子类写法</span><br><span class="line">    public void cure()&#123;</span><br><span class="line">        System.out.println(&quot;打针&quot;);</span><br><span class="line">        this.heatlh=60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里附上一个<strong>父类作为方法的返回值</strong>的多态用法，假设我们要送动物给别人。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public Pet sendPet(int type)&#123;//以父类作为返回对象，也是多态的一种用法</span><br><span class="line">        Pet pet = null;</span><br><span class="line">        switch(type)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                 Pet pet=new Cat();</span><br><span class="line">                 break;</span><br><span class="line">            case 2:</span><br><span class="line">                 Pet pet=new Dog();</span><br><span class="line">                 break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;私密马赛！没有这种宠物&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return pet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，这时你再构建对象，你就得写成<strong>Pet xx = new Xx()<strong>，即</strong>向上转型</strong>这里和以前的写法规定不一样了。而当master的cure函数收到Pet类型的对象时，系统会<strong>找到这个对象指向的具体的类型Xx</strong>,也就是实际上在调用时将其<strong>视作Xx类型的对象</strong>。</p>
<h3 id="关于向上（向下）转型"><a href="#关于向上（向下）转型" class="headerlink" title="关于向上（向下）转型"></a>关于向上（向下）转型</h3><p>上文中我们把<strong>父类类型引用变量指向子类对象，自动进行类型转换</strong>的写法称为<strong>向上转型</strong>，自然地，我们也将<strong>父类类型引用变量强制转换为子类类型引用变量</strong>的写法称为<strong>向下转型</strong>。</p>
<h4 id="我们为什么需要转型"><a href="#我们为什么需要转型" class="headerlink" title="我们为什么需要转型"></a>我们为什么需要转型</h4><p>当我们需要以多态写法（我个人将多态理解成一种写法）去简化调用这些子类的方法时，我们需要将参数表里传入的类型向上转型成子类共同继承的父类类型来使方法在具备简洁的方法体的同时可以<strong>灵活调用各个子类重写的父类方法</strong>，而当我们需要调用子类的<strong>特有方法</strong>时，由于<strong>父类对象不能调用子类特有的方法</strong>就需要将其强制转换回子类，即向下转型，从而实现调用。</p>
<h4 id="转型需要注意的地方"><a href="#转型需要注意的地方" class="headerlink" title="转型需要注意的地方"></a>转型需要注意的地方</h4><ul>
<li><strong>向上转型后只能调用子类覆盖或继承父类的方法，不能调用子类特有的方法</strong></li>
<li>在向下转型的过程中<strong>如果没有转换成真实子类类型，会出现类型转换异常</strong>，来看下面的代码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test()&#123;//测试类</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        Pet dog = new Dog();//先来个向上转型</span><br><span class="line">        Cat cat = (Cat) dog;//再来个向下转型</span><br><span class="line">        cat.meow();//让猫（实际上是“变成猫”的狗）调用喵喵叫方法（狗肯定不会喵喵叫啊所以是猫的特有方法）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码在写的时候IDE不会给你报错，也就是没有语法问题。但当你编译它的时候，IDE会告诉你存在编译错误（至少我的Myeclipse是这样）<strong>java.lang.ClassCastException:Dog cannot be cast to Cat</strong>（<strong>类型转换异常</strong>：狗变不成猫！），所以注意，向下转型时如果没有转化为真实的子类类型，会触发类型转换异常。<br>如果想要避免类型转换异常的出现，我们可以借助<strong>instanceof</strong>来进行辅助判断，来看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test()&#123;//测试类</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        Pet dog = new Dog();//先来个向上转型</span><br><span class="line">        if (dog instanceof Dog)&#123;</span><br><span class="line">            dog.bark();//汪汪汪</span><br><span class="line">        &#125;</span><br><span class="line">        elif(dog instanceof Cat)&#123;</span><br><span class="line">            cat.meow();//喵喵喵</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>，使用instanceof时，对象的类型必须和instanceof后面的类<strong>在继承上有上下级关系</strong></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object%E7%B1%BB/" rel="tag">Object类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/instanceof/" rel="tag">instanceof</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/super/" rel="tag">super</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E6%80%81/" rel="tag">多态</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/" rel="tag">方法重写</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boop/" rel="tag">面向对象编程oop</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计网课程笔记1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/05/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/"
    >计网课程笔记1</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/05/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/" class="article-date">
  <time datetime="2022-02-05T08:49:31.000Z" itemprop="datePublished">2022-02-05</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%BD%91/">课程笔记_计网</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1H3411y7q6?spm_id_from=333.999.0.0">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="1-1-计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）"><a href="#1-1-计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）" class="headerlink" title="1.1 计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）"></a>1.1 计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）</h1><hr>
<h1 id="1-2-计算机网络、互联网的定义与发展"><a href="#1-2-计算机网络、互联网的定义与发展" class="headerlink" title="1.2 计算机网络、互联网的定义与发展"></a>1.2 计算机网络、互联网的定义与发展</h1><h2 id="1-2-1互联网·计算机网络·互连网"><a href="#1-2-1互联网·计算机网络·互连网" class="headerlink" title="1.2.1互联网·计算机网络·互连网"></a>1.2.1互联网·计算机网络·互连网</h2><ul>
<li><strong>互联网（Internet）</strong>：覆盖全球的计算机网络，<strong>采用TCP/IP协议</strong></li>
<li><strong>计算机网络（computer network）</strong>：由若干结点和连接这些<em>结点（node）</em>的链路组成</li>
<li><strong>互连网（internet）</strong>：泛指通过路由器将各个计算机网络连接起来形成的更大的计算机网络<h3 id="关于“云”这个图形"><a href="#关于“云”这个图形" class="headerlink" title="关于“云”这个图形"></a>关于“云”这个图形</h3></li>
<li>当使用一朵云来表示网络时，可能有两种不同的情况：<ul>
<li>云表示的网络已经包含了和网络相连的计算机</li>
<li>云表示的网络里剩下许多路由器和连接这些路由器的<em>链路（link）</em>，把有关的计算机画在云的外面，将网络相连的计算机称为<em>主机（host）</em></li>
</ul>
</li>
</ul>
<h2 id="1-2-2计算机网络发展的三个阶段"><a href="#1-2-2计算机网络发展的三个阶段" class="headerlink" title="1.2.2计算机网络发展的三个阶段"></a>1.2.2计算机网络发展的三个阶段</h2><ul>
<li>第一阶段：军用网络ARPANET</li>
<li>第二阶段：三级结构互联网：主干网-地区网-园区网</li>
<li>第三阶段：<em>多层次互联网服务提供者（ISP）</em>结构互联网</li>
</ul>
<h2 id="1-2-3互联网的标准化"><a href="#1-2-3互联网的标准化" class="headerlink" title="1.2.3互联网的标准化"></a>1.2.3互联网的标准化</h2><p>**<strong>所有互联网标准都以RFC形式在互联网上发表</strong></p>
<ul>
<li><strong>互联网草案（Internet Draft）</strong>：有效期只有六个月，在这个阶段还不是RFC文档</li>
<li><strong>建议标准（Proposed Standard）</strong>：从这个阶段的开始就是RFC文档</li>
<li><strong>互联网标准 （Internet Standard）</strong>：形成正式标准后，每个标准就分配到一个编号。一个标准可以和多个RFC文档关联</li>
</ul>
<hr>
<h1 id="1-3互联网的组成"><a href="#1-3互联网的组成" class="headerlink" title="1.3互联网的组成"></a>1.3互联网的组成</h1><p>从互联网的工作方式上看，可以划分为两大块：<strong>边缘部分</strong>和<strong>核心部分</strong></p>
<ul>
<li>边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用于通信（数据传输）和资源共享</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）</li>
</ul>
<h2 id="1-3-1互联网的边缘部分"><a href="#1-3-1互联网的边缘部分" class="headerlink" title="1.3.1互联网的边缘部分"></a>1.3.1互联网的边缘部分</h2><p>构成互联网边缘部分的主机称为<strong>端系统（end system）</strong>，端系统可以有很大的差别（功能、所有者、性能……）</p>
<h3 id="端系统间通信的含义"><a href="#端系统间通信的含义" class="headerlink" title="端系统间通信的含义"></a>端系统间通信的含义</h3><p>端系统间的通信，实际上是指运行在主机A上的某个程序 <em>（从占用计算机资源的角度划分为进程）</em>与运行在主机B上的某个程序（进程）进行通信</p>
<h3 id="端系统间的两种通信方式"><a href="#端系统间的两种通信方式" class="headerlink" title="端系统间的两种通信方式"></a>端系统间的两种通信方式</h3><p>端系统之间的通信方式通常可划分为两大类：</p>
<ul>
<li><p><strong>客户-服务器方式（C/S方式）</strong> Client/Server</p>
<ul>
<li>客户和服务器都是指通信中所涉及的两个应用进程</li>
<li>C/S方式所描述的是进程之间服务和被服务的关系</li>
<li>客户是<strong>服务的请求方</strong>，服务器是<strong>服务的提供方</strong> </li>
<li>客户软件的特点<ul>
<li>被客户调用后运行，在打算通信时主动向远地服务器发起服务请求。因此客户程序必须知道服务器程序的地址</li>
<li>不需要很特殊的硬件和很复杂的操作系统</li>
</ul>
</li>
<li>服务器软件的特点<ul>
<li>一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求</li>
<li>系统启动后即自动调用并一直不断地运行着，<strong>被动地</strong>等待并接受来自各地的客户的服务请求。因此，服务器程序不需要知道客户程序的地址</li>
<li>客户和服务器的通信关系建立后，通信服务是双向的，客户和服务器都可发送和接收数据</li>
<li>一般需要强大的硬件和高级的操作系统支持</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对等方式（P2P方式）</strong> Peer to Peer（点到点/端对端）</p>
<ul>
<li>对等链接是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方</li>
<li>只要两个主机都运行了对等连接软件，就可以进行平等的、对等连接通信</li>
<li>双方都可以下载对方已经存储在硬盘内的资料</li>
</ul>
</li>
</ul>
<h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><ul>
<li>接入网：将端系统连接到其边缘路由器的物理链路，是用户连接到网络的基础设施</li>
<li>边缘路由器：端系统到任何其他远程端系统的路径上的<strong>第一台路由器</strong></li>
<li>将端系统连接到网络边缘路由器的粗糙分类：<ul>
<li>家庭接入网络（点对点接入）<ul>
<li>方式1：使用传统的电话线路连接本地中心局，数据通信和电话不能同时使用 <em>（拨号上网）</em></li>
<li>方式2：使用传统的电话线路连接本地中心局，数据通信和电话采用频分多路复用技术<ul>
<li>有多种传输速率</li>
<li>住宅和中心局距离不超过8——10英里</li>
<li>采用非对称数字用户线路模式（ADSL） <em>（下行需要大带宽支持，上行只需小量带宽）</em>，ASDL调制解调器始终和互联网连接，省去拨号上网、在电话线上产生三个通道 <em>（上行、下行、电话）</em>三个通道可以同时工作</li>
</ul>
</li>
<li>方式3：使用线缆调制解调器、混合光纤同轴电缆HFC<ul>
<li>通过一个以太网端口与家庭PC连接</li>
<li>光节点发送的分组经下行信道传输到每个家庭，若多个用户同时下载则会导致接收速率下降</li>
<li>每个家庭发送的分组经上行信道向光节点传输，几个用户同时发送分组将会冲突，需要多路访问协议协调</li>
</ul>
</li>
<li>方式4：使用光纤到户FTTH<ul>
<li>从本地局到每个家庭都提供一条光纤路径</li>
<li>从中心局出来的每根光纤由多个家庭共享，在临近家庭的位置通过光纤分配器给每个家庭提供一根光纤</li>
</ul>
</li>
</ul>
</li>
<li>企业/家庭接入网络、广域无线接入网络：见1.5.2</li>
</ul>
</li>
</ul>
<h2 id="1-3-2互联网的核心部分"><a href="#1-3-2互联网的核心部分" class="headerlink" title="1.3.2互联网的核心部分"></a>1.3.2互联网的核心部分</h2><ul>
<li>网络核心部分是互联网中最复杂的部分</li>
<li>网络中的核心部分要向网络边缘中的大量主机提供连通性，使得边缘部分中的任何一个主机都能够向其他主机通信</li>
<li>在网络核心部分起特殊作用的是<strong>路由器（router）</strong>，路由器是实现<strong>分组交换</strong>的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能</li>
</ul>
<p>为了理解分组交换，首先要看电路交换</p>
<h3 id="电路交换的主要特点"><a href="#电路交换的主要特点" class="headerlink" title="电路交换的主要特点"></a>电路交换的主要特点</h3><p>如果N台电话要两两相连，那么需要N（N-1）/2对电话线，当N很大时，电话线的数量与N²近似成正比，这对不利于电话网的建设。因此当电话机的数量增多时，就要使用<strong>交换机</strong>来完成全网的交换任务。而交换机所采用的交换方式就是<strong>电路交换</strong></p>
<ul>
<li>在这里，交换的含义就是<strong>转接</strong>，将两条电话线连通起来。</li>
<li>从通信资源的分配角度来看，交换就是依照某种方式<strong>动态</strong>地分配传输线路的资源</li>
<li>电路交换的特点<ul>
<li>电路交换必定是<strong>面向连接</strong><em>（必须得接通才能连接）</em>的</li>
<li>电路交换分为三个阶段：<ul>
<li>建立连接：建立一条专用的物理通路，以保证双方通话所需的通信资源在通信时不会被其他用户占用</li>
<li>通信：双方交流信息的过程</li>
<li>释放连接： 释放占用的所有通信资源</li>
</ul>
</li>
</ul>
</li>
<li>电路交换的优点：通信稳定</li>
<li>电路交换用于计算机网络时的缺点：计算机数据具有突发性（不是一直都在传数据），导致在传送计算机数据时通信线路的利用率很低，产生资源的浪费</li>
</ul>
<h3 id="分组交换的主要特点"><a href="#分组交换的主要特点" class="headerlink" title="分组交换的主要特点"></a>分组交换的主要特点</h3><ul>
<li>分组交换采用<strong>存储转发</strong>技术</li>
<li>在发送端，先把较长的报文划分成<strong>较短的、固定长度的</strong>数据段</li>
<li>每一个数据段前面添加上<strong>首部</strong>构成<strong>分组</strong></li>
<li>分组交换传输单元（此处假定在传输过程中数据没有损失）<ul>
<li>分组交换网以<strong>分组</strong>作为数据传输单元，每一个分组的首部都含有目的地址和源地址等控制信息，分组交换网中的结点交换机根据收到的分组首部地址中的地质信息，把分组转发到下一个结点交换机</li>
<li>每个分组在互联网中<strong>独立地选择传输路径</strong></li>
<li>依次把各分组发送到接收端</li>
<li>接收端收到分组后剥去首部还原成数据，再恢复成原来的报文</li>
</ul>
</li>
<li>分组交换的优点<ul>
<li>高效：在分组传输的过程中<strong>动态分配</strong>传输带宽，对通信链路<strong>逐段占用</strong></li>
<li>灵活：为每一个分组<strong>独立</strong>地选择最合适的转发路由</li>
<li>迅速：以分组为传送单位，可以<strong>不先建立连接</strong>就能向其他主机发送分组</li>
<li>可靠：保证可靠性的网络协议；分布式多路由组成的交换网使得网络有很好的的生存性</li>
</ul>
</li>
<li>分组交换的缺点<ul>
<li>分组在各节点存储转发需要<strong>排队</strong>，造成一定的<strong>时延</strong><del>ping</del></li>
<li>分组必须携带的首部造成一定的<strong>开销</strong></li>
</ul>
</li>
</ul>
<h3 id="互联网核心的组成"><a href="#互联网核心的组成" class="headerlink" title="互联网核心的组成"></a>互联网核心的组成</h3><ul>
<li>互联网的核心部分由许多网络和将它们连接起来的路由器组成，而主机（端系统）处在互联网的边缘部分</li>
<li>互联网核心部分中的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分通常以相对较低速率的链路相连接</li>
<li>主机的用途是为用户进行信息处理，并和其它主机通过网络交换信息 <em>（发送分组，接收分组）</em> 。路由器的用途是用来转发分组，即进行分组交接，先<strong>存储</strong>收到的数据，再决定要<strong>转发</strong>到哪里</li>
</ul>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul>
<li>在路由器中的输入和输出端口之间没有直接连线</li>
<li>路由器处理分组的过程是：<ul>
<li>把收到的分组先<strong>放入缓存</strong></li>
<li><strong>查找转发表</strong>，找出到某个目的地址应该从哪个端口转发</li>
<li>把分组送到适当的端口<strong>转发</strong>出去</li>
</ul>
</li>
</ul>
<h3 id="电路交换、报文交换、分组交换的不同（个人理解）"><a href="#电路交换、报文交换、分组交换的不同（个人理解）" class="headerlink" title="电路交换、报文交换、分组交换的不同（个人理解）"></a>电路交换、报文交换、分组交换的不同（个人理解）</h3><ul>
<li>电路交换需要等待连接建立后才能传递信息，有一定的时间的浪费，且发送信息期间链路均被占用，成本高</li>
<li>报文交换不需要等待连接建立，对每个链路的占用时长降低，因此成本低，但因为结点之间的传送存在次序，必须要等上一级结点传送完毕才能传给下一结点，导致用时长</li>
<li>分组交换将报文分成多个分组，压缩了传送时间且具有报文交换的优点。</li>
</ul>
<hr>
<h1 id="1-4-计算机网络在我国的发展（略）"><a href="#1-4-计算机网络在我国的发展（略）" class="headerlink" title="1.4 计算机网络在我国的发展（略）"></a>1.4 计算机网络在我国的发展（略）</h1><hr>
<h1 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h1><h2 id="1-5-1-计算机网络的定义（计算机网络的精确定义并未统一）"><a href="#1-5-1-计算机网络的定义（计算机网络的精确定义并未统一）" class="headerlink" title="1.5.1 计算机网络的定义（计算机网络的精确定义并未统一）"></a>1.5.1 计算机网络的定义（计算机网络的精确定义并未统一）</h2><ul>
<li>课程给出的定义：计算机网络主要是由一些通用的、可编程的硬件 <em>（表明这种硬件一定含有CPU）</em>互连而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</li>
</ul>
<h2 id="1-5-2几种不同类别的网络"><a href="#1-5-2几种不同类别的网络" class="headerlink" title="1.5.2几种不同类别的网络"></a>1.5.2几种不同类别的网络</h2><ul>
<li>计算机网络有多种类别。类型包括：<ul>
<li><p>从网路的作用范围进行分类</p>
<ul>
<li><strong>广域网WAN</strong>：作用范围几十到几千公里</li>
<li><strong>城域网MAN</strong>；作用范围5~50公里</li>
<li><strong>局域网LAN/园区网</strong>：局限在较小范围（如1公里左右）</li>
<li><strong>个人局域网PAN</strong>：范围很小，大约在10米左右</li>
</ul>
</li>
<li><p>从网络的使用者进行分类</p>
<ul>
<li><strong>公用网</strong>：按规定缴纳费用的人都可以使用的网络</li>
<li><strong>专用网</strong>：为特殊业务工作的需要而建造的网络</li>
</ul>
</li>
<li><p>用来把用户接入到互联网的网络</p>
<ul>
<li><strong>接入网AN</strong>：又称本地接入网或居民接入网</li>
<li>接入网是一类比较特殊的计算机网络，用于将用户接入互联网。</li>
<li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分，由端系统到另一个端系统的路径中与第一个路由器间的物理链路所构成。从覆盖的范围看，很多接入网属于局域网，从作用上看，接入网只是起到让用户能够与互联网连接的作用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-6计算机网络的性能，是什么？如何衡量？"><a href="#1-6计算机网络的性能，是什么？如何衡量？" class="headerlink" title="1.6计算机网络的性能，是什么？如何衡量？"></a>1.6计算机网络的性能，是什么？如何衡量？</h1><h2 id="1-6-1计算机网络的性能指标"><a href="#1-6-1计算机网络的性能指标" class="headerlink" title="1.6.1计算机网络的性能指标"></a>1.6.1计算机网络的性能指标</h2><ul>
<li><p>速率</p>
<ul>
<li>计算机数据量/信息量单位<strong>比特bit</strong></li>
<li>速率指的是<strong>数据的传送速率</strong>，也称为<strong>数据率</strong>或<strong>比特率</strong></li>
<li>速率的单位是<strong>bit/s</strong>,更大的单位有kbit/s,Mbit/s,Gbit/s等等。<em>需要注意的是，1kb=1024b，1kb/s=1000bit/s，其余以此类推。</em></li>
</ul>
</li>
<li><p>带宽</p>
<ul>
<li>带宽本来是指信号所具有的<strong>频带宽度</strong>，单位是Hz</li>
<li>在计算机网络中，带宽用来表示网络中某信道传送数据的能力，表示在单位时间内网络中的某通道所能通过的<strong>最高数据率</strong>，因此单位和速率一样是bit/s</li>
<li>在时间轴上信号的宽度随带宽的增大而变窄</li>
</ul>
</li>
<li><p>吞吐量</p>
<ul>
<li>吞吐量表示在单位时间内通过某个网络/通道/接口的数据量</li>
<li>吞吐量常用于对显示世界中网络的测量，以便知道有多少数据能够通过网络</li>
<li><strong>吞吐量受网络带宽/网络额定速率的限制</strong></li>
</ul>
</li>
<li><p>时延/延迟<del>ptsd犯了</del></p>
<ul>
<li>延迟是指数据从网络链路一段传送到另一端所需要的的时间</li>
<li>网络延迟由以下几个不同的部分组成：<ul>
<li><strong>发送延迟</strong> = 数据帧长度/发送速率</li>
<li><strong>传播延迟</strong>：电磁波在信道中传播一定的距离而花费的时间。<em>可知传播延迟和发送延迟有本质上的不同</em>。传播延迟==通道的物理长度/信号的传播速度</li>
<li><strong>处理延迟</strong>：主机或路由器收到分组时，为处理分组（分析首部、提取数据、差错检验、查找路由）所花费的时间 </li>
<li><strong>排队延迟</strong>：分组在路由器输入输出队列中<strong>排队等待处理所需时间</strong>，<strong>取决于网络中当时的通讯录</strong></li>
</ul>
</li>
<li>延迟=发送延迟+传播延迟+处理延迟+排队延迟</li>
</ul>
</li>
<li><p>时延带宽积</p>
<ul>
<li>链路的时延带宽积又称以比特为单位的链路长度</li>
<li><strong>时延带宽积=传播时延x带宽</strong></li>
</ul>
</li>
<li><p>往返时间RTT</p>
<ul>
<li>往返时间表示从发送方发送数据开始到发送方收到来自接收方的确认总共经历的时间</li>
<li>往返时间=各中间结点的处理延迟和排队延迟+传播延迟+发送延迟</li>
</ul>
</li>
<li><p>利用率</p>
<ul>
<li>分为<strong>信道利用率</strong>和<strong>网络利用率</strong></li>
<li>信道利用率：指出某信道有百分之几的时间是有数据通过的。</li>
<li>网络利用率：全网络的信道利用率的加权平均值</li>
<li><strong>信道利用率并非越高越好</strong>，当某信道的利用率增大时，该信道引起的<strong>时延</strong>也将<strong>急剧增加</strong>，若令D0为网络空闲时的延迟，D表示网络当前的延迟，U表示网络的利用率，则在适当的假定条件下，可以用公式<strong>D=D0/（1-U）</strong>表示D和D0的关系</li>
</ul>
</li>
</ul>
<h2 id="1-6-2计算机网络的非性能特征"><a href="#1-6-2计算机网络的非性能特征" class="headerlink" title="1.6.2计算机网络的非性能特征"></a>1.6.2计算机网络的非性能特征</h2><ul>
<li>费用</li>
<li>质量</li>
<li>标准化</li>
<li>可靠性</li>
<li>可扩展性和可升级性</li>
<li>易于管理和维护</li>
</ul>
<hr>
<h1 id="1-7计算机网络的体系结构"><a href="#1-7计算机网络的体系结构" class="headerlink" title="1.7计算机网络的体系结构"></a>1.7计算机网络的体系结构</h1><h2 id="1-7-1计算机网络体系结构的形成"><a href="#1-7-1计算机网络体系结构的形成" class="headerlink" title="1.7.1计算机网络体系结构的形成"></a>1.7.1计算机网络体系结构的形成</h2><ul>
<li>相互通讯的两个计算机系统必须高度协调工作，而这种协调是相当复杂的</li>
<li><strong>分层</strong>可将庞大而复杂的问题转化为若干较小的局部问题，化繁为简，易于处理。</li>
<li>在形成统一标准之前，各种体系结构的计算机网络之间很难相互连通，为了解决该问题，ISO于1977年提出了标准框架<strong>开放系统互连基本参考模型</strong>，简称<strong>OSI</strong>，但OSI在市场化方面失败了。</li>
<li>目前的两种国际标准(事实意义上)为<strong>TCP\IP</strong></li>
</ul>
<h2 id="1-7-2协议与划分层次"><a href="#1-7-2协议与划分层次" class="headerlink" title="1.7.2协议与划分层次"></a>1.7.2协议与划分层次</h2><ul>
<li>计算机网络中的数据交换<strong>必须遵守实现约定的规则</strong>，这些规则明确规定了所交换的数据的格式以及有关的同步问题</li>
<li><strong>网络协议</strong>是为进行网络中的数据交换而建立的规则、标准或约定</li>
<li>网络协议的三个组成要素<ul>
<li><strong>语法</strong>：报文格式/数据与控制信息的结构或格式</li>
<li><strong>语义</strong>：每个字段的含义/需要发出何种控制信息。完成何种动作以及做出何种响应</li>
<li><strong>同步</strong>：报文传输的先后次序/事件实现顺序的详细说明</li>
</ul>
</li>
<li>协议的两种形式：文字描述、程序代码</li>
<li>分层：将计算机数据的传送划分为彼此之间有联系但功能上相互独立的多个层次进行。</li>
<li>分层的好处和缺点<ul>
<li>好处<ul>
<li>各层之间相互独立</li>
<li>灵活性好</li>
<li>结构上可分割</li>
<li>易于实现和维护</li>
<li>能促进标准化工作</li>
</ul>
</li>
<li>缺点<ul>
<li>效率降低</li>
<li>有些功能会在不同的层次中重复出现，因而产生额外开销</li>
</ul>
</li>
<li>因此层数的多少要适当，层数太少会使得每一层的协议太过复杂，而层数太多，又会在描述和综合各层功能的系统工程任务时遇到较多的困难</li>
</ul>
</li>
</ul>
<h3 id="如何恰当分层？"><a href="#如何恰当分层？" class="headerlink" title="如何恰当分层？"></a>如何恰当分层？</h3><ul>
<li>各层完成的主要功能<ul>
<li>差错控制：使相应层次对等方的通信更加可靠</li>
<li>流量控制：发送端的发送速率必须使接收端来得及接收，不要太快</li>
<li>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原 </li>
<li>复用和分用：发送端几个高层会话复用一条底层的连接，在接收端再进行分用</li>
<li>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后再释放连接</li>
</ul>
</li>
</ul>
<h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><ul>
<li><strong>计算机网络的体系结构</strong>是关于网络的各层及其协议的集合</li>
<li>体系结构就是这个计算机网络及其部件<strong>所应完成的功能的精确定义</strong></li>
<li><strong>实现</strong>是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题</li>
</ul>
<h2 id="1-7-3具有五层协议的体系结构"><a href="#1-7-3具有五层协议的体系结构" class="headerlink" title="1.7.3具有五层协议的体系结构"></a>1.7.3具有五层协议的体系结构</h2><ul>
<li>OSI的七层体系结构虽然概念清楚、理论较为完整，但它既复杂又不实用。</li>
<li>TCP/IP 是四层体系结构：应用层、运输层、网际层和网络接口层，但最下面的网络接口层并没有具体内容。</li>
<li>因此采取折中的办法，即综合OSI和TCP/IP的优点，采用一种五层协议的体系结构：<strong>应用层（对应OSI的应用层+表示层+会话层）、运输层、网络层、数据链路层、物理层</strong><h3 id="主机1向主机2通过五层协议体系结构发送数据的全过程"><a href="#主机1向主机2通过五层协议体系结构发送数据的全过程" class="headerlink" title="主机1向主机2通过五层协议体系结构发送数据的全过程"></a>主机1向主机2通过五层协议体系结构发送数据的全过程</h3></li>
<li>应用进程数据先传送到应用层，加上应用层首部，成为应用层<strong>PDU（OSI把对等层次之间传送的数据单位称为该层的协议数据单元）</strong></li>
<li>发送<ul>
<li>应用层PDU再传送到运输层，加上运输层首部成为<strong>运输层报文</strong></li>
<li>运输层报文再传送到网络层，加上网络层首部成为<strong>IP数据报/分组</strong></li>
<li>IP数据报再传送到数据链路层，加上链路层首部和尾部，成为<strong>数据链路层帧</strong></li>
<li>数据链路层帧再传送到物理层，物理层把比特流传送到物理媒体</li>
</ul>
</li>
<li>接收<ul>
<li>物理层接收到比特流，上交给数据链路层</li>
<li>数据链流层剥去帧首部和尾部，取出数据部分上交给网络层</li>
<li>网络层剥去首部，取出数据部分上交给运输层</li>
<li>运输层剥去首部，取出数据部分上交给应用层</li>
<li>应用层剥去首部，取出应用程序数据上交给应用进程，传送结束</li>
</ul>
</li>
<li>任何两个同样的层次把数据通过水平虚线 <em>（包含两个层次下面的所有部分）</em>直接传递给对方，这就是所谓的<strong>对等层</strong>之间的通信</li>
<li>各层协议实际上就是在各个对等层之间传递数据时的各项规定</li>
</ul>
<h2 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h2><ul>
<li><strong>实体</strong>：表示任何可发送或接收信息的硬件或软件进程</li>
<li><strong>协议</strong>：控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务</li>
<li>注意协议和服务的区别，<strong>协议是水平的</strong>，即协议是控制对等实体之间通信的规则，<strong>服务是垂直的</strong>，即服务是由下层向上层通过层间接口提供的。本层的服务用户只能看见服务而无法看见下面的协议。</li>
<li>协议必须把所有不利的事件事先都估计到，不能假定一切都是正常的、非常理想的。看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，还必须非常仔细地检查这个协议能否应对各种异常情况</li>
</ul>
<hr>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-测试文档"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/02/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/"
    >测试文档</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/02/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/" class="article-date">
  <time datetime="2022-02-02T14:03:41.000Z" itemprop="datePublished">2022-02-02</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><p>内容</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>字体加粗</strong><br><em>字体倾斜</em><br><em><strong>字体加粗倾斜</strong></em><br><del>字体加删除线</del></p>
<blockquote>
<p>这是嵌套</p>
<blockquote>
<p>这是嵌套</p>
<blockquote>
<p>这是嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h6 id="这是一个六级标题"><a href="#这是一个六级标题" class="headerlink" title="这是一个六级标题"></a>这是一个六级标题</h6><p>分割线</p>
<hr>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>添加<del>涩图</del>测试<br><img src="../photos/hexo/1_1.jpg" title="图片标题"></p>
<hr>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>超链接测试<br><a target="_blank" rel="noopener" href="https://space.bilibili.com/13720945?spm_id_from=333.788.0.0">b站主页</a></p>
<hr>
<h1 id="代码和代码块"><a href="#代码和代码块" class="headerlink" title="代码和代码块"></a>代码和代码块</h1><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">system.out.println(&quot;hello world!&quot;);</span><br></pre></td></tr></table></figure>
<p>代码块</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(i=0;i&lt;=9;i++)&#123;</span><br><span class="line">    system.out.println(&quot;当前数字是&quot;+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table>
<thead>
<tr>
<th>乘数</th>
<th align="center">乘数</th>
<th align="right">积</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td align="center">2</td>
<td align="right">4</td>
</tr>
<tr>
<td>3</td>
<td align="center">3</td>
<td align="right">9</td>
</tr>
<tr>
<td>1</td>
<td align="center">2</td>
<td align="right">2</td>
</tr>
</tbody></table>
<hr>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><hr>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<hr>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><ol>
<li>列表内容<ul>
<li>分支列表内容</li>
<li>分支列表内容<br>  +分支列表内容</li>
</ul>
</li>
<li>列表内容</li>
</ol>
<hr>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-hello-world"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/01/12/hello-world/"
    >Hello World</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/01/12/hello-world/" class="article-date">
  <time datetime="2022-01-12T03:57:23.136Z" itemprop="datePublished">2022-01-12</time>
</a>    
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/2/">上一页</a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Daniel Qi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.svg" alt="Welcome to DanielQi&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/photos/">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/1.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/2.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=139774&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>
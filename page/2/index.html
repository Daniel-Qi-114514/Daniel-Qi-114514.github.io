<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Welcome to DanielQi&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://mermaid-js.github.io/mermaid/"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Welcome to DanielQi&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['from import to export', 'from asking to serving', 'from idea to reality'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">一个安静优雅的hexo主题，拥有轻量化页面。</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-数据库原理笔记2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B02/"
    >数据库原理笔记2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B02/" class="article-date">
  <time datetime="2022-03-21T12:43:38.000Z" itemprop="datePublished">2022-03-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">课程笔记_数据库原理</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="依照学校教学安排，第二章为数据库关系模型"><a href="#依照学校教学安排，第二章为数据库关系模型" class="headerlink" title="依照学校教学安排，第二章为数据库关系模型"></a>依照学校教学安排，第二章为数据库关系模型</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="2-1-关系及其相关概念"><a href="#2-1-关系及其相关概念" class="headerlink" title="2.1 关系及其相关概念"></a>2.1 关系及其相关概念</h1><h2 id="2-1-1-关系模型的提出"><a href="#2-1-1-关系模型的提出" class="headerlink" title="2.1.1 关系模型的提出"></a>2.1.1 关系模型的提出</h2><p>关系模型以关系代数理论为数学基础，将数据操作抽象为关系处理，其关系表结构简单，便于理解和访问。关系模型在当今几乎所有商业数据库中得到广泛应用，该理论由E.F.Codd于1970年发表。</p>
<h2 id="2-1-2-实体、关系的概念"><a href="#2-1-2-实体、关系的概念" class="headerlink" title="2.1.2 实体、关系的概念"></a>2.1.2 实体、关系的概念</h2><ul>
<li><strong>实体</strong>：包含有数据特征的事物对象在概念模型世界中的抽象名称，可以理解成对象</li>
<li><strong>关系</strong>：在关系模型中，使用关系来存储实体中的数据，关系指<strong>具有关系特征、用于存放实体数据的二维表</strong>，关系也常被称为关系表</li>
<li><strong>关系特征</strong>：在关系表中，每一行称为<strong>元组</strong>，每一列称为<strong>属性</strong><ul>
<li>表中每行存储实体的一个示例数据</li>
<li>表中每列包含实体的一项属性数据</li>
<li>表中单元格只能存储单个值</li>
<li>不允许有重复的行、列</li>
<li>行列顺序可任意</li>
</ul>
</li>
</ul>
<h2 id="2-1-3-关系的数学定义"><a href="#2-1-3-关系的数学定义" class="headerlink" title="2.1.3 关系的数学定义"></a>2.1.3 关系的数学定义</h2><ul>
<li><strong>定义</strong>：关系是指在集合域D<sub>1</sub>、…、D<sub>n</sub>上运算笛卡尔积 *(设A、B是两个集合，称集合AxB={&lt;a,b&gt;|(a∈A)^(b∈B)}为集合A与B的笛卡尔积)*的有意义子集，其数学描述为R⊆D<sub>1</sub>xD<sub>2</sub>x、…、xD<sub>n</sub>，其中每一个向量(d1,d2,…dn)称为一个<strong>n元组</strong>，简称元组。想两种的每个di称为分量。若集合域D<sub>i</sub>(i=1,2,…,n)为有限集，每个域的基数为m<sub>i</sub>(i=1,2,…,n)，则笛卡尔积D<sub>1</sub>xD<sub>2</sub>x、…、xD<sub>n</sub>的基数M为m<sub>i</sub>从1到n的累乘</li>
<li><strong>注意</strong>：关系R只是该笛卡尔积的<strong>有意义子集</strong>，即关系R的元组数≤笛卡尔积的元组数</li>
</ul>
<h2 id="2-1-4-关系的键定义"><a href="#2-1-4-关系的键定义" class="headerlink" title="2.1.4 关系的键定义"></a>2.1.4 关系的键定义</h2><ul>
<li>在关系中，可以用来唯一标识元组的属性列称为<strong>键</strong>，其它属性列都为非键列</li>
<li><strong>复合键</strong>：关系中用来唯一标识元组的<strong>多列</strong></li>
<li><strong>候选键</strong>：关系中可能有多个列均适合作为键，将其中每个都称为候选键</li>
<li><strong>主键</strong>：关系表中最有代表性的一个候选键，每个关系表中只能定义一个主键<ul>
<li>主键作用<ul>
<li>唯一标识关系表的每行（元组）</li>
<li>与关联表的外键建立联系，实现关系表之间连接</li>
<li>数据库文件使用主键值来组织关系表的数据存储</li>
<li>数据库使用主键索引快速检索数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>代理键</strong>：采用DBMS自动生成的数字序列作为关系表的主键<ul>
<li>代理键的作用：由DBMS自动生成的数字序列作为主键，可替代复合主键，以便获得更高性能的数据访问操作处理</li>
</ul>
</li>
</ul>
<h2 id="2-1-5-关系模式语句表示"><a href="#2-1-5-关系模式语句表示" class="headerlink" title="2.1.5 关系模式语句表示"></a>2.1.5 关系模式语句表示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELATION_NAME(Column01,Column02,...,LastColumn)//关系名称(主键属性,属性名2,...,最后一个属性名)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-2-关系模型原理"><a href="#2-2-关系模型原理" class="headerlink" title="2.2 关系模型原理"></a>2.2 关系模型原理</h1><h2 id="2-2-1-关系模型及其组成"><a href="#2-2-1-关系模型及其组成" class="headerlink" title="2.2.1 关系模型及其组成"></a>2.2.1 关系模型及其组成</h2><ul>
<li><strong>关系模型</strong>：一种基于二维表结构存储数据实体及实体间联系的数据模型<ul>
<li>数据结构：关系模型由若干二维表组成，并且表之间存在一定的联系，它们一起组织、存储数据</li>
<li>数据操作：关系模型中可以进行集合运算操作（选择、投影、连接、交、并、差……）、专门关系运算操作（数据行插入、修改、删除）</li>
<li>数据约束：在关系模型中，数据关系约束是指关系表中实体数据完整性、关联表之间数据一致性（属性列取值类型、属性列取值范围、属性列取值是否唯一、属性列是否允许空值）等要求，一般由业务需求来确定</li>
</ul>
</li>
</ul>
<h2 id="2-2-2-关系模型数据操作"><a href="#2-2-2-关系模型数据操作" class="headerlink" title="2.2.2 关系模型数据操作"></a>2.2.2 关系模型数据操作</h2><p>关系模型数据操作采用基于关系代数的数据操作，包括传统的集合运算操作和专门的关系运算操作</p>
<ul>
<li>关系并运算操作：关系并运算的结果集是由属于R或属于S的所有元组组成</li>
<li>关系差运算操作：关系差运算的结果集是由属于R但不属于S的所有元组组成</li>
<li>关系交运算操作：关系交运算的结果集是由既属于R又属于S的所有元组组成</li>
<li>关系笛卡尔积操作：关系笛卡尔积的结果集是由所有属于R的元组和所有属于S的元组进行组合而成</li>
</ul>
<h2 id="2-2-3-关系模型完整性"><a href="#2-2-3-关系模型完整性" class="headerlink" title="2.2.3 关系模型完整性"></a>2.2.3 关系模型完整性</h2><p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束</p>
<ul>
<li>完整性约束作用<ul>
<li>消除关系表的元组重复存储</li>
<li>保持关联表的数据一致性 </li>
<li>实现业务数据规则</li>
</ul>
</li>
<li>关系模型完整性约束组成<ul>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义完整性约束</li>
</ul>
</li>
</ul>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性是指在关系表中实施的主键取值约束，以保证关系表中的每个元组可以被唯一标识</p>
<ul>
<li>实体完整性约束规则<ul>
<li>每个关系表中的主键属性列都不允许为空值，否则就不可能标识实体</li>
<li>现实世界中的实体是靠主键来标识，主键取值应该唯一，并区分关系表中的每个元组</li>
</ul>
</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据一致性</p>
<ul>
<li><strong>外键</strong>：在关联的两个主系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</li>
<li>参照完整性约束规则：若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致</li>
</ul>
<h3 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h3><p>用户自定义完整性是指用户根据具体业务对数据处理规则要求所定义的数据约束</p>
<ul>
<li>用户可以定义如下类型的完整性约束：<ul>
<li>定义列的数据类型和数据范围</li>
<li>定义类的缺省值 <em>（无干预情况下的默认值）</em></li>
<li>定义列是否允许取空值</li>
<li>定义列取值唯一性</li>
<li>定义列之间的数据依赖性</li>
</ul>
</li>
</ul>
<h2 id="2-2-4-ON条件、where条件"><a href="#2-2-4-ON条件、where条件" class="headerlink" title="2.2.4 ON条件、where条件"></a>2.2.4 ON条件、where条件</h2><ul>
<li>ON条件：在生成临时表时使用的条件，它不管on中的条件是否都为真，都会返回左表中的记录</li>
<li>where条件：在临时表生成好后，再对临时表进行过滤的条件，此时已经没有leftjoin的含义，条件不为真的就全部过滤掉、</li>
</ul>
<h2 id="2-2-5-自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接"><a href="#2-2-5-自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接" class="headerlink" title="2.2.5 自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接"></a>2.2.5 自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接</h2><ul>
<li>自然连接：自然连接不用指定连接列，也不能使用ON语句，它默认比较两张表里相同的列</li>
<li>内连接：内连接可以自定义两张表的不同列字段，内连接有两种形式：显式（有INNER JOIN，形成的中间表为两个表经过ON条件过滤后的笛卡尔积）和隐式（没有INNER JOIN，形成的中间表为两个表的笛卡尔积）</li>
<li>外连接<ul>
<li>左外连接：返回指定左表的全部行+右表对应的行，如果左表中数据在右表中没有与其相匹配的行，则在查询结果集合中显示为空值 <em>（null）</em>。</li>
<li>右外连接：与左外连接类似，是左外连接的反向链接</li>
<li>全外连接：将左右两表进行自然连接，左表或右表只要有一个没有就显示NULL<br><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/sql_join_inner.asp">关键字使用参考</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-3-PostgreSQL数据库关系操作实践（略）"><a href="#2-3-PostgreSQL数据库关系操作实践（略）" class="headerlink" title="2.3 PostgreSQL数据库关系操作实践（略）"></a>2.3 PostgreSQL数据库关系操作实践（略）</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" rel="tag">数据库原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据库原理笔记1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B01/"
    >数据库原理笔记1</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B01/" class="article-date">
  <time datetime="2022-03-10T13:10:54.000Z" itemprop="datePublished">2022-03-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">课程笔记_数据库原理</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="依照学校教学安排，第一章为数据库系统概论"><a href="#依照学校教学安排，第一章为数据库系统概论" class="headerlink" title="依照学校教学安排，第一章为数据库系统概论"></a>依照学校教学安排，第一章为数据库系统概论</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="1-1-数据库及其系统概念"><a href="#1-1-数据库及其系统概念" class="headerlink" title="1.1 数据库及其系统概念"></a>1.1 数据库及其系统概念</h1><h1 id="1-1-1-什么是数据库？"><a href="#1-1-1-什么是数据库？" class="headerlink" title="1.1.1 什么是数据库？"></a>1.1.1 什么是数据库？</h1><ul>
<li>在任何信息系统的技术实现中均需要一类<strong>用于组织和存储数据的数据容器</strong></li>
<li>支持应用程序对数据的共享操作访问</li>
<li>将信息系统的各类数据如<strong>文本数据、图表数据、音视频数据等</strong>进行组织存储并<strong>提供能对外访问</strong></li>
<li><strong>数据库的定义</strong>：一种依照特定<strong>数据模型</strong>组织、存储和管理数据的文件集合，这些文件一般存放在外部存储器中，以便长久保存数据，并可快速访问</li>
<li><strong>数据库文件组成</strong>：<strong>数据文件</strong>和<strong>日志文件</strong></li>
<li><strong>数据库的本质就是一类数据文件</strong></li>
<li>数据库与普通数据文件的主要区别<ul>
<li>数据库可以支持不同应用对数据共享访问，普通数据文件难以支持</li>
<li>数据库可以实现复杂的数据管理，普通数据文件难以实现</li>
<li>数据库可独立于应用程序，普通数据文件与应用程序紧耦合</li>
<li>数据库的操作访问与控制管理由数据库管理系统软件实现，普通数据文件的操作访问与控制管理都必须由应用程序实现</li>
</ul>
</li>
</ul>
<h1 id="1-1-2-什么是数据模型"><a href="#1-1-2-什么是数据模型" class="headerlink" title="1.1.2 什么是数据模型"></a>1.1.2 什么是数据模型</h1><ul>
<li>数据模型是指描述事物对象的<strong>数据结构组成</strong>、<strong>数据语义联系</strong>、<strong>数据约束的抽象结构及其说明</strong>，由数据结构、数据操作和数据约束组成<ul>
<li>数据结构：用于描述事物对象的静态特征，包括事物对象的数据组成、数据类型、数据性质等</li>
<li>数据操作：用于描述事物对象的动态特征，包括数据的插入、修改、删除和查询等访问操作</li>
<li>数据约束：用于描述数据结构中数据之间的语义联系，数据之间的制约和依存关系，以及数据动态变化的规则等</li>
</ul>
</li>
</ul>
<h1 id="1-1-3-数据库使用的数据模型"><a href="#1-1-3-数据库使用的数据模型" class="headerlink" title="1.1.3 数据库使用的数据模型"></a>1.1.3 数据库使用的数据模型</h1><ul>
<li><strong>层次数据模型</strong>：最早使用的一种数据模型<ul>
<li>采用树结构来组织、存储和管理数据，每个结点存储一个数据记录，数据结点之间通过链接指针相互联系，通过结点遍历访问方法实现查询数据</li>
<li>由于树结构受限于上下结点层次访问，缺乏灵活性，故后来使用网状数据模型</li>
</ul>
</li>
<li><strong>网状数据模型</strong><ul>
<li>采用网状图结构组织、存储和管理数据，在网状图中，中间结点不但可以上下层次访问，还可以横向关联访问</li>
<li>优点：可灵活地表示数据之间的复杂关系，数据冗余小</li>
<li>缺点：结构复杂，增加了数据查询、数据修改 <em>（需要更改数据结点和关联指针）</em>和数据定位的难度，因此使用关系数据模型</li>
</ul>
</li>
<li><strong>关系数据模型</strong><ul>
<li>采用二维表结构组织、存储和管理数据，并以关联列实现表之间的关系</li>
<li>优点：数据结构简单、操作灵活，支持关系与集合运算操作，支持广泛使用的SQL数据库操作语言标准，拥有众多产品与用户</li>
<li>缺点：只用于结构化数据的组织与存储管理，支持的数据类型较简单，难以支持互联网广泛应用的非结构化数据和复杂数据管理</li>
</ul>
</li>
<li><strong>其它数据模型</strong>：如对象数据模型、键值对数据模型、列式数据模型、文档数据模型、图形数据模型等</li>
</ul>
<h1 id="1-1-4-数据库系统"><a href="#1-1-4-数据库系统" class="headerlink" title="1.1.4 数据库系统"></a>1.1.4 数据库系统</h1><ul>
<li>定义：<strong>一类基于数据库进行数据管理与信息服务的软件系统</strong></li>
<li>组成：<strong>数据库用户、数据库应用程序、数据库管理系统、数据库</strong><ul>
<li>数据库用户：由应用程序员 <em>（开发）</em>、系统分析员 <em>（开发）</em>、数据库管理员 <em>（使用DBMS提供的工具维护数据库系统）</em>、最终用户构成</li>
<li>数据库应用程序：是一种在DBMS支持下对数据库中数据进行访问处理的应用程序，基本功能有：<ul>
<li>通过输入框采集用户输入数据</li>
<li>通过接口连接访问数据库</li>
<li>执行用户数据查询</li>
<li>通过表单列表输出结果数据</li>
<li>…</li>
</ul>
</li>
<li>数据库管理系统DBMS：一种专门用于**创建、管理 <em>（包括读写、修改、删除数据等）</em>、维护、提供外部访问数据库支持 <em>（执行数据访问规则）</em>、执行数据库备份和恢复**的系统软件</li>
<li>数据库：一种依照特定数据模型组织、存储和管理数据的文件集合</li>
</ul>
</li>
</ul>
<h1 id="1-1-5-关系数据库中的数据内容"><a href="#1-1-5-关系数据库中的数据内容" class="headerlink" title="1.1.5 关系数据库中的数据内容"></a>1.1.5 关系数据库中的数据内容</h1><ul>
<li>在关系数据库中，除了存储和管理应用的<strong>用户数据</strong> <em>（存放于用户表）</em>外，还需要存与管理数据库本身的<strong>元数据、索引数据、运行数据</strong> <em>（存放于系统表）</em>等系统数据</li>
</ul>
<h1 id="1-1-6-关系数据库的对象组织"><a href="#1-1-6-关系数据库的对象组织" class="headerlink" title="1.1.6 关系数据库的对象组织"></a>1.1.6 关系数据库的对象组织</h1><ul>
<li>用户表：存储用户的应用数据</li>
<li>系统表：存储数据库系统自身数据</li>
<li>视图：通过虚拟表实现数据查询处理</li>
<li>索引：通过目录数据结构支持快速数据查询</li>
<li>约束：对关系表及其数据施加规则</li>
<li>存储过程：在数据库内部实现特定功能程序的数据处理</li>
<li>触发器：在数据库内部实现数据操作事件触发自动执行的过程程序</li>
</ul>
<hr>
<h1 id="1-2-数据库技术发展"><a href="#1-2-数据库技术发展" class="headerlink" title="1.2 数据库技术发展"></a>1.2 数据库技术发展</h1><h2 id="1-2-1数据管理技术发展阶段"><a href="#1-2-1数据管理技术发展阶段" class="headerlink" title="1.2.1数据管理技术发展阶段"></a>1.2.1数据管理技术发展阶段</h2><ul>
<li>人工管理阶段<ul>
<li>应用需求：科学计算</li>
<li>硬件背景：简单的计算机，纸带打孔I/O</li>
<li>软件背景：没有操作系统</li>
<li>数据管理：人工在代码中控制处理</li>
<li>管理特点：<ul>
<li>程序员组织与管理数据</li>
<li>应用程序依赖数据集</li>
<li>应用之间无数据共享、数据冗余度大</li>
<li>数据集无结构</li>
</ul>
</li>
</ul>
</li>
<li>文件系统管理阶段<ul>
<li>应用需求：科学计算、信息管理</li>
<li>硬件背景：磁鼓、磁带、磁盘等外部存储设备的出现</li>
<li>软件背景：操作系统、文件系统等系统软件的出现</li>
<li>数据管理：文件方式组织和存储数据，应用程序可通过文件系统提供的文件存取方法接口访问数据文件</li>
<li>管理特点：<ul>
<li>由文件组织与存储数据</li>
<li>数据文件的数据记录具有简单的字段结构，但文件整体无结构</li>
<li>应用程序依赖于数据文件，需自己维护数据文件</li>
<li>数据独立性差，难以实现应用程序之间的数据共享访问</li>
</ul>
</li>
</ul>
</li>
<li>数据库系统管理阶段<ul>
<li>应用需求：大规模信息管理</li>
<li>硬件背景：大容量磁盘、磁盘阵列的出现，支持大容量数据管理</li>
<li>软件背景：数据库管理系统出现</li>
<li>数据管理：数据库管理系统组织、存储和访问数据</li>
<li>管理特点：<ul>
<li>数据集结构化，易于查询和统计处理</li>
<li>不同应用程序可以实现数据共享访问</li>
<li>数据独立性高，应用可扩展</li>
<li>数据由DBMS统一管理和操作访问<h2 id="1-2-2数据库技术发展经历时代"><a href="#1-2-2数据库技术发展经历时代" class="headerlink" title="1.2.2数据库技术发展经历时代"></a>1.2.2数据库技术发展经历时代</h2></li>
</ul>
</li>
</ul>
</li>
<li>第一代数据库技术：20世纪60年代末出现的层次模型数据库技术和网状模型数据库技术</li>
<li>第二代数据库技术：20世纪70年代出现的关系模型数据库技术</li>
<li>第三代数据库技术：20世纪90年代出现的面向对象数据库技术和对象-关系数据模型数据库技术</li>
<li>第四代数据库技术：本世纪初期出现的半结构化数据库技术，以及当今面向互联网应用的非结构化数据库技术、大规模分布式数据库技术<h2 id="1-2-3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术"><a href="#1-2-3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术" class="headerlink" title="1.2.3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术"></a>1.2.3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术</h2><h2 id="1-2-4数据库技术发展趋势"><a href="#1-2-4数据库技术发展趋势" class="headerlink" title="1.2.4数据库技术发展趋势"></a>1.2.4数据库技术发展趋势</h2></li>
<li>数据库规模朝两级发展，大型数据库系统越来越大，小型数据库系统越来越小</li>
<li>从数据库行数据访问模式，到列数据访问模式</li>
<li>从结构化数据库，到半结构化XML数据库、非结构化数据库</li>
<li>从操作型数据库系统，到数据仓库、商业智能数据分析、大数据处理</li>
<li>从通用数据库，到实时数据库、多媒体数据库、空间数据库、分布式数据库、并行数据库等专业领域数据库</li>
</ul>
<hr>
<h1 id="1-3-数据库应用系统"><a href="#1-3-数据库应用系统" class="headerlink" title="1.3 数据库应用系统"></a>1.3 数据库应用系统</h1><h2 id="1-3-1数据库应用系统类型"><a href="#1-3-1数据库应用系统类型" class="headerlink" title="1.3.1数据库应用系统类型"></a>1.3.1数据库应用系统类型</h2><ul>
<li>业务处理系统TPS：运用数据库应用程序对机构业务活动信息进行记录、计算、检索、汇总、统计等数据处理，为机构操作层面提供基本业务服务，提高业务处理效率的信息系统。</li>
<li>管理信息系统MIS：一种以机构职能管理为主导，利用计算机软硬件、网络通信、数据库等IT技术，实现机构职能整体信息化管理，以达到规范化管理和提高机构工作效率，并支持机构职能服务的信息系统</li>
<li>决策支持系统DSS：以管理科学、运筹学、控制论和行为科学为基础，以计算机技术、数据库技术、人工智能技术为手段，针对特定领域问题解决，为管理者提供辅助决策服务与方案的信息系统 <h2 id="1-3-2数据库系统应用结构"><a href="#1-3-2数据库系统应用结构" class="headerlink" title="1.3.2数据库系统应用结构"></a>1.3.2数据库系统应用结构</h2></li>
<li>单机用户结构：整个数据库应用系统都装在一台计算机上，由一个用户进行访问操作，<strong>数据不能共享，数据冗余度大</strong></li>
<li>集中式结构：数据库系统的应用程序、DBMS、数据都部署在同一服务器上运行，多个用户使用自己的计算机终端网络连接服务器，并可实现共享访问数据库，<strong>结构简单，易于维护，但当终端用户增加到一定数量后，服务器及网络将成为数据存取访问的瓶颈，使系统的性能大大降低</strong></li>
<li>客户/服务器结构：数据库应用程序的数据集中在数据库服务器管理、应用分布客户机处理。客户端应用程序通过网络并发访问数据库服务器中的数据库，客户机程序与数据库服务器<strong>分工进行数据处理，提高系统负载分担能力，但仍会因大量客户端并发访问数据库服务器，导致系统性能瓶颈</strong></li>
<li>分布式结构：分布式结构下的各服务器结点数据库在逻辑上是一个整体，但物理分布在计算机网络的不同服务器结点上运行，每个数据库服务器可通过网络既支持多个本地客户机访问，也支持远程客户机访问。<strong>既实现数据分布，又实现处理分布，并执行全局应用</strong>，适合跨地区的大型机构及企业等组织对数据库应用的要求，<strong>处理性能强，但数据库的分布处理与维护有一定的开销和技术难度</strong><h2 id="1-3-3数据库应用系统生命周期"><a href="#1-3-3数据库应用系统生命周期" class="headerlink" title="1.3.3数据库应用系统生命周期"></a>1.3.3数据库应用系统生命周期</h2></li>
<li><strong>需求分析</strong>：系统分析人员与用户交流，利用软件工程方法获取系统数据需求信息，并采用需求模型定义系统数据组成及其数据字典</li>
<li><strong>系统设计</strong>：系统设计人员根据系统功能和性能需求，对系统数据库进行设计，包括系统概念数据模型、系统逻辑数据模型和系统物理数据模型设计</li>
<li><strong>系统实现</strong>：按照系统设计方案进行数据库创建与应用编程实现，主要包括DBMS安装部署、数据库创建、数据对象创建、应用编程实现等方面的工作</li>
<li><strong>系统测试</strong>：系统测试人员将测试数据上载到数据库中，对数据库对象进行测试操作访问，实现数据库功能和性能测试</li>
<li><strong>系统运行与维护</strong>：系统运维人员在信息系统投入运行过程中，对数据库系统进行定期维护和优化，以保证数据库系统正常地、高效地运行</li>
</ul>
<hr>
<h1 id="1-4-典型数据库管理系统"><a href="#1-4-典型数据库管理系统" class="headerlink" title="1.4 典型数据库管理系统"></a>1.4 典型数据库管理系统</h1><h2 id="1-4-1-数据库管理系统类型"><a href="#1-4-1-数据库管理系统类型" class="headerlink" title="1.4.1 数据库管理系统类型"></a>1.4.1 数据库管理系统类型</h2><ul>
<li>按用途分类<ul>
<li>通用DBMS：支持公共领域数据库应用，广泛应用在各个机构的业务信息系统、办公管理系统、商业信息系统中，如 SQL Server</li>
<li>专用领域DBMS：支持专用领域数据库应用，如嵌入式应用、实时计算、多媒体应用等领域，如SQLite</li>
</ul>
</li>
<li>按用户数分类<ul>
<li>单用户DBMS：仅支持单用户访问，如miniSQL</li>
<li>多用户DBMS：可支持多用户并行访问，如MySQL</li>
</ul>
</li>
<li>按系统部署分类<ul>
<li>集中式DBMS：数据库集中部署在单一物理机器中，针对中小型信息系统，如Access</li>
<li>分布式DBMS：数据库可分布在不同位置的物理机器中，针对跨区域的大规模信息系统，如Oracle Database</li>
</ul>
</li>
<li>按使用场景分类<ul>
<li>桌面级DBMS：适用于微小型的信息服务应用，针对小规模或个人信息服务，对数据处理能力要求不高，通常只支持单一语言的应用程序开发，如Access、SQLite等</li>
<li>企业级DBMS：适用于中大型的企业级应用，针对中大规模信息服务，对功能、可靠性和性能有较高要求，支持多种不同语言的应用程序开发，如DB2、Oracle Database、Sybase ASE等</li>
</ul>
</li>
<li>按软件版权分类<ul>
<li>产品DBMS：厂商拥有版权的数据库软件，面向市场出售技术服务，如SQL Server、 Oracle Database等</li>
<li>开源DBMS：开源组织提供的数据库软件，免费下载供学习科研使用，如MySQL、PostgreSQL等</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-5-PostgreSQL对象-关系数据库系统软件、"><a href="#1-5-PostgreSQL对象-关系数据库系统软件、" class="headerlink" title="1.5 PostgreSQL对象-关系数据库系统软件、"></a>1.5 PostgreSQL对象-关系数据库系统软件、</h1><h2 id="1-5-1–1-5-3-略"><a href="#1-5-1–1-5-3-略" class="headerlink" title="1.5.1–1.5.3 略"></a>1.5.1–1.5.3 略</h2><h2 id="1-5-4-PostgreSQL数据库软件的服务器程序的部分常用命令"><a href="#1-5-4-PostgreSQL数据库软件的服务器程序的部分常用命令" class="headerlink" title="1.5.4 PostgreSQL数据库软件的服务器程序的部分常用命令"></a>1.5.4 PostgreSQL数据库软件的服务器程序的部分常用命令</h2><ul>
<li>initdb:初始化PostgreSQL数据库</li>
<li>pg_controldata:显示一个PostgreSQL数据库集群的控制信息</li>
<li>pg_ctl:启动、停止或者控制PostgreSQL服务器</li>
<li>pg_resetxlog:重置一个数据库集群的预写日志以及其它控制内容</li>
<li>postgres:PostgreSQL数据库服务器进程</li>
<li>postmaster:PostgreSQL守护进程<h2 id="1-5-5-PostgreSQL数据库的常用管理工具"><a href="#1-5-5-PostgreSQL数据库的常用管理工具" class="headerlink" title="1.5.5 PostgreSQL数据库的常用管理工具"></a>1.5.5 PostgreSQL数据库的常用管理工具</h2></li>
<li>psql命令行管理工具：psql是一个PostgreSQL内置的客户端工具，该工具使用户通过执行命令以交互式方式实现PostgreSQL数据库管理</li>
<li>pgAdmin图形界面管理工具<h2 id="1-5-6-PostgreSQL数据库主要对象"><a href="#1-5-6-PostgreSQL数据库主要对象" class="headerlink" title="1.5.6 PostgreSQL数据库主要对象"></a>1.5.6 PostgreSQL数据库主要对象</h2></li>
<li>模式对象：一种构成数据库下级逻辑结构的数据库对象，用于按用户或按应用分类组织其它数据库对象</li>
<li>表对象：一种用户组织存储数据的数据库对象，主要有三种类型：<strong>关系表、继承表、外部表</strong></li>
<li>视图对象：一种基于虚拟表操作数据的数据库对象</li>
<li>序列对象：一种为代理键列提供自动增量序列值的数据库对象，提供自动增量序列值的数据库对象</li>
<li>函数对象：一种使用内置编程语言编写数据库访问操作功能程序的数据库对象，PostgreSQL没有单独的存储对象，而是通过函数来实现存储过程功能</li>
<li>触发器对象：一种事件触发、自动执行的数据库访问操作功能程序的数据库对象</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" rel="tag">数据库原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计网课程笔记3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/08/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03/"
    >计网课程笔记3</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/08/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03/" class="article-date">
  <time datetime="2022-03-08T06:54:04.000Z" itemprop="datePublished">2022-03-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%BD%91/">课程笔记_计网</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="依照学校教学安排，第三章为应用层（即网课第五章）"><a href="#依照学校教学安排，第三章为应用层（即网课第五章）" class="headerlink" title="依照学校教学安排，第三章为应用层（即网课第五章）"></a>依照学校教学安排，第三章为应用层（即网课第五章）</h1><h1 id="3-1-运输层协议概述"><a href="#3-1-运输层协议概述" class="headerlink" title="3.1 运输层协议概述"></a>3.1 运输层协议概述</h1><h2 id="3-1-1-进程之间的通信"><a href="#3-1-1-进程之间的通信" class="headerlink" title="3.1.1 进程之间的通信"></a>3.1.1 进程之间的通信</h2><ul>
<li><strong>运输层属于面向通信部分的最高层，同时也是用户功能中的最底层</strong>，运输层向它上面的应用提供通信服务</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到下三层的功能<br><img src="../photos/ComputerNetworkCourse/3_1.png" title="传输过程中各层与进程示意图"></li>
<li><strong>IP协议的作用范围是两个主机之间的所有链路和路由器</strong> <em>（提供主机之间的逻辑通信）</em></li>
<li><strong>运输层协议TCP和UDP的作用范围是从一台主机的某个进程到另一台主机的进程之间</strong> <em>（为相互通信的应用进程提供了逻辑通信）</em></li>
</ul>
<h2 id="3-1-2-运输层的两个主要协议"><a href="#3-1-2-运输层的两个主要协议" class="headerlink" title="3.1.2 运输层的两个主要协议"></a>3.1.2 运输层的两个主要协议</h2><ul>
<li>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信</li>
<li>运输层的两个重要功能：<strong>复用</strong>和<strong>分用</strong></li>
<li>根据应用程序的不同需求，运输层需要有两种不同的运输协议：<strong>面向连接的传输控制协议TCP</strong>和<strong>无连接的用户数据报UDP</strong><h3 id="基于端口的复用和分用功能"><a href="#基于端口的复用和分用功能" class="headerlink" title="基于端口的复用和分用功能"></a>基于端口的复用和分用功能</h3></li>
<li><strong>向下复用和向上分用</strong><ul>
<li>发送方应用层的多个应用进程通过各自端口传入运输层并在运输层中<strong>重复使用</strong>TCP和UDP协议，对应转化为TCP报文段和UDP用户数据报，随后在网络层中<strong>重复使用</strong>IP协议，转换为IP数据报传送至接收方。</li>
<li>接收方在网络层中<strong>分开使用</strong>IP协议，转化为TCP报文段和UDP用户数据报，在运输层中<strong>分开使用</strong>TCP协议和UDP协议，最后通过各自端口发给应用进程<br><img src="../photos/ComputerNetworkCourse/3_2.png" title="基于端口的复用和分用功能示意图"></li>
</ul>
</li>
<li>运输层向高层用户<strong>屏蔽</strong>了下面网络核心的细节，它使应用进程“看见”的仿佛是一条<strong>在两个运输层实体间的端到端的逻辑通信信道</strong>，但这条通信信道对上层的表现却因运输层使用的不同协议而有很大的差别<ul>
<li>当运输层采用<strong>面向连接的TCP协议</strong>时 <em>（对可靠性要求高）</em>，即使下面的网络不可靠，但逻辑通信信道相当于一条<strong>全双工的可靠信道</strong></li>
<li>当运输层采用<strong>无连接的UDP协议</strong>时 <em>（对效率要求高）</em>，这种逻辑通信信道是一条<strong>不可靠信道</strong></li>
</ul>
</li>
<li>TCP和UDP<ul>
<li><strong>运输协议数据单元</strong>：两个对等实体在通信时传送的数据单位</li>
<li><strong>TCP报文段</strong>：TCP传送的运输协议数据单元</li>
<li><strong>UDP报文/用户数据报</strong>：UDP传送的运输协议数据单元</li>
<li><strong>UDP：一种无连接协议</strong><ul>
<li>提供无连接服务</li>
<li><strong>在传输数据之前不需要先建立连接</strong></li>
<li>传送的数据单位是UDP报文/用户数据报</li>
<li>对方的运输层在收到UDP报文后，<strong>不需要给出任何确认</strong></li>
<li>虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式 <em>（因为要求少）</em></li>
</ul>
</li>
<li><strong>TCP：一种面向连接的协议</strong><ul>
<li>提供面向连接的服务</li>
<li>传送的数据单位协议是TCP报文段</li>
<li><strong>TCP不提供广播或多播服务</strong></li>
<li>由于TCP要提供<strong>可靠的、面向连接的运输服务</strong>，因此不可避免地增加了许多的开销，这不仅使数据单元的首部增大很多，还要占用许多的处理机资源</li>
</ul>
</li>
</ul>
</li>
<li>补充：运输层的UDP用户数据报与网际/网络层的IP数据报有很大区别<ul>
<li>IP数据报要经过互连网中许多路由器的存储转发</li>
<li>UDP用户数据报是在运输层的端到端<strong>抽象的</strong>逻辑信道中传送的</li>
</ul>
</li>
</ul>
<h2 id="3-1-3-运输层的端口"><a href="#3-1-3-运输层的端口" class="headerlink" title="3.1.3 运输层的端口"></a>3.1.3 运输层的端口</h2><ul>
<li>运行在计算机中的进程是用<strong>进程标识符</strong>来标识的</li>
<li><strong>运行在应用层的各种应用进程不应当让计算机操作系统指派它的进程标识符</strong>，这是因为互连网上使用的计算机的操作系统种类很多而不同的操作系统又使用不同格式的进程操作符</li>
<li>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须使用<strong>统一的方法</strong>对TCP/IP体系的应用进程进行标识<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3></li>
<li>为了解决不同操作系统下的应用进程在互连网上相互通信时进程标识符不统一的问题，我们在运输层使用<strong>协议端口号/端口</strong></li>
<li>虽然通信的终点是应用进程，但我们可以把端口想象为通信的终点，因为我们只要把统一格式的报文交到目的主机的一个合适的目的端口，剩下交付给进程的过程就交由TCP完成<h3 id="硬件端口与软件端口"><a href="#硬件端口与软件端口" class="headerlink" title="硬件端口与软件端口"></a>硬件端口与软件端口</h3></li>
<li><strong>软件端口</strong>：协议栈层间的抽象的协议端口</li>
<li><strong>硬件端口</strong>：路由器或交换机上的端口</li>
<li>硬件端口是不同硬件设备进行交互的端口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址<h3 id="TCP-IP运输层端口"><a href="#TCP-IP运输层端口" class="headerlink" title="TCP/IP运输层端口"></a>TCP/IP运输层端口</h3></li>
<li>端口用一个16位端口号进行标志 <em>（意味着最多可以有2的16次方个软件端口）</em></li>
<li>端口号只具有本地意义 <em>（两个主机的端口号可以相同）</em>，即端口号只是为了标识<strong>本计算机应用层中的各进程</strong></li>
<li>在互连网中，不同计算机的相同端口号是没有联系的</li>
<li>两个计算机中的进程要互相通信，不仅必须知道对方的IP地址 <em>（找计算机）</em>，而且还要知道对方的端口号 <em>（找进程）</em><h3 id="两大类端口"><a href="#两大类端口" class="headerlink" title="两大类端口"></a>两大类端口</h3></li>
<li><strong>服务器端使用的端口号</strong><ul>
<li>熟知端口：一般为1-1023</li>
<li>登记端口号：为1024-49151，供没有熟知端口号的应用程序使用的，使用这个范围的端口号必须在互联网数字分配机构IANA登记以防止重复</li>
</ul>
</li>
<li><strong>客户端使用的端口号</strong><ul>
<li>又称短暂端口号，为49152-65535，留给客户进程选择暂时使用</li>
<li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号，通信结束后这个端口号可供其他客户进程以后使用<br><img src="../photos/ComputerNetworkCourse/3_3.png" title="常用的熟知端口"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-2-用户数据报协议UDP"><a href="#3-2-用户数据报协议UDP" class="headerlink" title="3.2 用户数据报协议UDP"></a>3.2 用户数据报协议UDP</h1><h2 id="3-2-1-UDP概述"><a href="#3-2-1-UDP概述" class="headerlink" title="3.2.1 UDP概述"></a>3.2.1 UDP概述</h2><ul>
<li>UDP只在IP的数据报服务之上增加了一点功能：<ul>
<li>复用和分用的功能</li>
<li>差错检测的功能</li>
</ul>
</li>
<li>虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有特殊的优点</li>
<li>UDP的主要特点<ul>
<li><strong>UDP是无连接的</strong>：发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延</li>
<li><strong>UDP使用尽最大努力交付</strong>：UDP的尽最大努力是在IP的基础上的，即不保证可靠交付，因此主机不需要维持复杂的连接状态表</li>
<li><strong>UDP是面向报文的</strong><ul>
<li>发送方UDP对应用层交下来的报文，在添加首部后就向下交付IP层，<strong>既不合并，也不拆分</strong>，而是保留这些报文的边界</li>
<li>发送时应用层交给UDP多长的报文，UDP就照样发送，<strong>一次发送一个完整的报文</strong></li>
<li>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，<strong>一次交付一个完整的报文</strong></li>
<li>应用程序必须选择合适大小的报文<ul>
<li>若报文太长，UDP交给IP层后在传输时可能要进行<strong>分片</strong>，这会<strong>降低IP层的效率</strong></li>
<li>若报文太短，UDP交给IP层后在传输时IP数据报中<strong>首部的相对长度太大</strong>，这会<strong>降低IP层的效率</strong></li>
</ul>
</li>
<li>UDP发送的报文长度是应用进程给出的</li>
</ul>
</li>
<li><strong>UDP没有拥塞控制</strong>：：由于UDP不用实现可靠传送网络出现额拥塞不会使源主机发送速率降低，这对某些实时应用很重要，很适合多媒体通信的要求</li>
<li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong></li>
<li><strong>UDP的首部开销小</strong>：只有8字节，比TCP20个字节的首部要短，<strong>同时也意味着UDP的功能比TCP少</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-2-UDP的首部格式"><a href="#3-2-2-UDP的首部格式" class="headerlink" title="3.2.2 UDP的首部格式"></a>3.2.2 UDP的首部格式</h2><ul>
<li>UDP用户数据报有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>，首部字段只有8个字节</li>
<li>8个字节的首部构成：<strong>源端口(2字节)+目的端口(2字节)+数据长度(伪首部+有效数据的字节长度)(2字节)+校验和(2字节)</strong></li>
<li>12个字节的伪首部 <em>（不占报文的地址空间，但在计算校验和的时候会临时把伪首部和UDP用户数据报连接在一起）</em>构成：<strong>源IP地址(4字节)+目的IP地址(4字节)+8位全0(1字节)+8位协议（17）(1字节)+UDP长度(2字节)</strong></li>
<li><strong>UDP校验和的计算</strong>：将数据报空余的部分填0，将伪首部、首部、数据以一字节为一段，两字节为一行从上到下排列，进行加法计算，产生的进位溢出加到结果的末位，然后将结果取反即得到校验和。<br><img src="../photos/ComputerNetworkCourse/3_4.png" title="UDP首部、伪首部构成示意图"><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/roccoshi/p/13033014.html">UDP校验和计算教程</a></li>
</ul>
<hr>
<h1 id="3-3-传输控制协议TCP概述"><a href="#3-3-传输控制协议TCP概述" class="headerlink" title="3.3 传输控制协议TCP概述"></a>3.3 传输控制协议TCP概述</h1><h2 id="3-3-1-TCP最主要的特点"><a href="#3-3-1-TCP最主要的特点" class="headerlink" title="3.3.1 TCP最主要的特点"></a>3.3.1 TCP最主要的特点</h2><ul>
<li><strong>TCP是面向连接的运输层协议</strong>：先建立连接再传输</li>
<li>每一条TCP连接<strong>只能有两个端点</strong>，每一条TCP连接<strong>只能是点对点的、一对一的</strong></li>
<li>TCP提供<strong>可靠交付</strong>的服务：不重复、不丢失、不失序</li>
<li>TCP提供<strong>全双工通信</strong>：双方都可以发送和接收</li>
<li><strong>面向字节流</strong><ul>
<li>TCP中的“流”指的是流入或流出进程的字节序列</li>
<li>“面向字节流”的含义：虽然应用程序和TCP的交互时一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流</li>
<li>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，但接收方接收到的字节流必须和发送方应用程序发出的字节流完全一样：<strong>TCP不管你数据怎么分的块，但要求数据内容必须是一样的</strong></li>
<li>TCP不关心应用进程一次把多长的报文发送到TCP缓存</li>
<li>TCP对连续的字节流进行分段，形成TCP报文段，但<strong>分段是不定的</strong>，TCP<strong>根据对方给出的窗口值和当前网络拥塞的程度</strong>来决定一个报文段应包含多少字节</li>
</ul>
</li>
<li><strong>注意</strong>，TCP连接是运输层间的<strong>需连接</strong>，是逻辑上的通信信道<br><img src="../photos/ComputerNetworkCourse/3_5.png" title="TCP字节流发送、传输示意图"><h2 id="3-3-2-TCP的连接"><a href="#3-3-2-TCP的连接" class="headerlink" title="3.3.2 TCP的连接"></a>3.3.2 TCP的连接</h2></li>
<li>TCP把连接作为<strong>最基本的工作/功能的抽象</strong>：所有的工作都要以连接建立为根本前提</li>
<li>每一条TCP连接<strong>有两个端点</strong></li>
<li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议接口，<strong>TCP连接的端点叫做套接字或插口</strong></li>
<li><strong>套接字就是IP后面加上端口号</strong>，socket=（ip地址：端口号），每一条TCP连接唯一地被通信两端的两个套接字所确定 TCP连接={socket1，socket2}={(ip:port1),(ip:port2)}</li>
<li>同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中</li>
</ul>
<hr>
<h1 id="3-4-可靠传输的工作原理"><a href="#3-4-可靠传输的工作原理" class="headerlink" title="3.4 可靠传输的工作原理"></a>3.4 可靠传输的工作原理</h1><h2 id="3-4-1-停止等待协议"><a href="#3-4-1-停止等待协议" class="headerlink" title="3.4.1 停止等待协议"></a>3.4.1 停止等待协议</h2><h3 id="理想的传输条件有两个特点"><a href="#理想的传输条件有两个特点" class="headerlink" title="理想的传输条件有两个特点"></a>理想的传输条件有两个特点</h3><ul>
<li>传输信道不产生差错</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</li>
</ul>
<p><strong>然而实际的网络都不具备以上两个理想条件</strong>，故必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输</p>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul>
<li>“停止等待”的思路：每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li>
<li><strong>全双工通信的双方既是发送方也是接收方</strong> <em>（发送/接收数据和确认）</em></li>
</ul>
<h3 id="传输情况"><a href="#传输情况" class="headerlink" title="传输情况"></a>传输情况</h3><ul>
<li>无差错情况：A向B发送组1，发完暂停发送，等待B接收组1并传回确认后再发送组2</li>
<li>接收方B出现差错情况<ul>
<li>第一种：B接收组1时出现了差错，就丢弃组1，其它什么也不做（不传回确认）</li>
<li>第二种：组1在传输过程中丢失了，B当然什么都不知道，因此也什么都不做</li>
<li>在这两种情况下，B都不会发送信息</li>
</ul>
</li>
<li>确认出现差错情况：确认信息在传输过程中丢失了</li>
<li>解决方案：超时重传<ul>
<li>A为每个已经发送的组都设置了一个<strong>超时计时器</strong></li>
<li>A只要在超时计时器到期之前收到了确认就撤销该超时计时器，继续发送组2</li>
<li>如果超时计时器到期，就重新发送组1</li>
<li>由此可见<strong>传输过程中的问题都由发送方解决</strong></li>
</ul>
</li>
</ul>
<h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><ul>
<li>确认丢失<ul>
<li>若B所发送的对M1的确认丢失了，那么A在设定的超时重传时间内不能收到确认，但A无法知道是上述三种情况的哪种，因此<strong>A在超时计时器到期后就要重传组1</strong></li>
<li>假定B又收到了重传的组1（即确认信息丢失），此时B要采取两个行动<ul>
<li>丢弃这个重复的组1，不向上层交付</li>
<li>向A发送确认：就算给A发送过确认信息也要再发送，正是因为A没有收到确认信息所以才重发组1</li>
</ul>
</li>
</ul>
</li>
<li>确认迟到<ul>
<li>若B所发送的对组1的确认传到A的时间过长（在超时计时器到期后送达），则A将重新发送组1，以第二次发送组1收到的确认和第一次发送收到的确认中较早者为时间点发送组2，第二次收到的对组1确认将丢弃</li>
</ul>
</li>
<li><strong>注意</strong><ul>
<li>在发送完一个分组后，必须暂时保留已发送的分组的副本已备重发</li>
<li><strong>分组和确认分组都必须进行编号</strong></li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间<strong>更长一些</strong>，以减少重发次数<h2 id="3-4-2-连续ARQ协议"><a href="#3-4-2-连续ARQ协议" class="headerlink" title="3.4.2 连续ARQ协议"></a>3.4.2 连续ARQ协议</h2></li>
</ul>
</li>
<li><strong>通常A最终总是可以收到对所有发出的分组的确认</strong>，如果A不断重发却收不到确认，则说明通信线路太差，不能进行通信</li>
<li><strong>使用停止等待协议的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信</strong></li>
<li>像上述的这种可靠传输协议常称为<strong>自动重传请求ARQ</strong>,即重传请求是自动进行的，不需要接收方发送重传请求</li>
</ul>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><ul>
<li><strong>停止等待协议的优点是简单，缺点是信道利用率太低</strong></li>
<li>设分组发送所需时间为Td，确认发送所需时间为Ta（均不包含传送时间），两者的传送时间与分组确认接收时间总和为RTT，则信道利用率<strong>U=Td/(Td+RTT+Ta)</strong></li>
<li>可以看出，当往返时间RTT远大于分组发送时间Td时，信道的利用率就会非常低，若出现重传，则对传送有用的数据信息而言，信道的利用率还要降低、</li>
</ul>
<h3 id="连续ARQ协议-流水线传输"><a href="#连续ARQ协议-流水线传输" class="headerlink" title="连续ARQ协议/流水线传输"></a>连续ARQ协议/流水线传输</h3><ul>
<li>为了提高传输效率，发送方采用流水线传输</li>
<li>流水线传输就是发送方<strong>可连续发送多个分组，不必每发完一个分组就停下来等待对方确认</strong>，这样可以使信道上一直有数据不间断地传送</li>
<li>由于信道上一直有数据不间断地传送，这种传输方式可以获得很高的信道利用率</li>
<li><strong>仍然需要设置超时计时器</strong></li>
<li><strong>滑动窗口协议比较复杂，是TCP协议的精髓所在</strong><ul>
<li>发送方维持的<strong>发送窗口</strong>：位于发送窗口内的分组都可连续发送出去而不需要等待对方的确认</li>
<li>连续ARQ协议规定，<strong>发送方每收到一个确认，就把发送窗口（缓存中的一块区域）向前滑动一个分组的位置</strong><br><img src="../photos/ComputerNetworkCourse/3_6.png" title="连续ARQ协议发送窗口工作原理示意图"></li>
</ul>
</li>
</ul>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><ul>
<li>接收方一般采用<strong>累计确认</strong>的方式，即不必对收到的分组逐个发送确认，而是对<strong>按序到达的最后一个分组发送确认</strong>，表示到这个分组之前的所有分组都已经正确收到了</li>
<li>优点：容易实现，即使确认丢失也不必重传</li>
<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息</li>
<li>对于缺点的补充：<strong>Go-back-N(回退N)</strong><ul>
<li>如果发送方发送了x个分组，而其中第N个分组丢失了，此时接收方只能对<strong>第N个分组之前的所有分组发出确认</strong>，发送方无法得知第N个分组后其他分组的接收情况，只能<strong>将从第N个分组起的所有分组重新发送</strong>，即<strong>表示需要再退回来重传已发送过的分组</strong></li>
<li>可见当通信信道质量不好时，连续ARQ协议会带来不好的影响</li>
</ul>
</li>
</ul>
<h3 id="TCP可靠通信的具体实现"><a href="#TCP可靠通信的具体实现" class="headerlink" title="TCP可靠通信的具体实现"></a>TCP可靠通信的具体实现</h3><ul>
<li><strong>TCP连接的每一端都必须设有一个发送窗口和一个接收窗口</strong></li>
<li>TCP的可靠传输机制用字节的序号进行控制，TCP所有的确认都是基于序号而不是基于报文</li>
<li>TCP两端的四个窗口经常处于<strong>动态变化</strong>之中</li>
<li>TCP连接的往返时间RTT也不是固定不变的，需要使用特定的算法估算较为合理的时间</li>
</ul>
<hr>
<h1 id="3-5-TCP报文段的首部格式"><a href="#3-5-TCP报文段的首部格式" class="headerlink" title="3.5 TCP报文段的首部格式"></a>3.5 TCP报文段的首部格式</h1><ul>
<li>TCP虽然是面向字节流的，但TCP传送的数据单元确是报文段</li>
<li>一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中各字段的作用</li>
<li>TCP报文段首部的前20个字节是固定的，后面有4n（n为自然数）字节是根据需要而增加的选项，因此**TCP首部的最小长度是20字节)<br><img src="../photos/ComputerNetworkCourse/3_7.png" title="TCP首部格式示意图"></li>
<li>源端口和目的端口字段各占2字节，端口是运输层和应用层的服务接口，运输层的复用和分用功能都要通过端口才能实现</li>
<li>序号字段占4字节，TCP连接传送的数据流中的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的编号</li>
<li>确认号字段占4字节，是期望收到对方的下一个报文段的数据的第一个字节的编号</li>
<li>数据偏移（即首部长度）占4位，它指出TCP报文段的<strong>数据起始处</strong>距离TCP报文段的起始处有多远，数据偏移的单位是32位字（以4字节为计算单位）</li>
<li>保留字段占6位，保留为今后使用，但目前应置为0</li>
<li>六个标志位占六位<ul>
<li>紧急URG：当URG=1时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送</li>
<li>确认ACK：当ACK=1时，确认号字段有效，0则无效</li>
<li>推送PSH：当PSH=1时，就尽快的交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</li>
<li>复位RST：当RST=1时，表明TCP连接中出现严重差错（如主机崩溃），必须释放连接，然后再重新建立运输连接</li>
<li>同步SYN：SYN=1表明这是一个连接请求或连接接受报文（确认连接）</li>
<li>终止FIN：用于释放连接，FIN=1表示此报文段的发送端的数据已发送完毕，并要求释放运输连接</li>
</ul>
</li>
<li>窗口字段占2字节，用来让对方设置发送窗口的依据 <em>（告诉对方自己的接收窗口的大小）</em>，单位为字节</li>
<li>校验和占2字节，检验和字段检验的范围包括首部和数据两部分，计算检验和具体见3.2.2</li>
<li>紧急指针字段占2字节，指出在本报文段中紧急数据有多少个字节 *（紧急数据放在本报文段数据的最前面）</li>
<li>选项字段：长度可变。TCP最初只规定了一种选项，即<strong>最大报文段长度MSS</strong>，MSS高速对方TCP己方缓存能接收的报文段的数据字段（TCP报文段长度减去TCP首部长度）的最大长度是多少字节，字节数存储在MSS中。其他选项如下：<ul>
<li>窗口扩大选项占3字节，其中有一个字节表示移位S，新的2窗口值等于TCP首部中的窗口位数增大到16+S，相当于把窗口值向左移动S位后获得的实际的窗口大小</li>
<li>时间戳选项占10字节，其中最主要的字段<strong>时间戳值字段</strong>占4字节，<strong>时间戳回送回答字段</strong>占4字节</li>
<li>选择确认选项，见3.6.3</li>
</ul>
</li>
<li>规定MSS的原因<ul>
<li>MSS与接收窗口值没有关系</li>
<li><strong>若选择较小的MSS长度，网络的利用率就降低</strong>，因为TCP报文段越少，首部占比就越大，传输效率就越低，开销就显得大</li>
<li><strong>若TCP报文段很长，会使得开销增大</strong>，在IP层传输时就有可能要分解成多个端数据报片，在终点要把收到的各个短数据报片装配成原来的TCP报文段，当传输出错时还要进行重传，进而增大开销</li>
<li>综上，<strong>MSS应尽可能大些，只要在IP层传输时不需要再分片就行</strong></li>
<li>由于IP数据报的路径是动态变化的，因此在这条路径上确定的不需要分片的MSS，如果改走另一条路径就可能需要进行分片</li>
<li>综上，<strong>最佳的MSS很难确定</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-6-TCP可靠传输的实现"><a href="#3-6-TCP可靠传输的实现" class="headerlink" title="3.6 TCP可靠传输的实现"></a>3.6 TCP可靠传输的实现</h1><h2 id="3-6-1-以字节为单位的滑动窗口"><a href="#3-6-1-以字节为单位的滑动窗口" class="headerlink" title="3.6.1 以字节为单位的滑动窗口"></a>3.6.1 以字节为单位的滑动窗口</h2><ul>
<li>TCP的滑动窗口是以字节为单位的</li>
<li>先假定A收到了B发来的确认报文段，其中窗口（接收能力）是20字节，而确认号（下一个报文段开头的序号）是31（表明序号30为止的数据已经收到了），根据窗口和确认号，A就构造出自己的发送窗口。<ul>
<li>发送窗口表示：<strong>在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去</strong></li>
<li>发送窗口里面的序号表示允许发送的序号</li>
<li>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率</li>
<li><strong>TCP标准强烈不赞成发送窗口前沿向后收缩</strong><br><img src="../photos/ComputerNetworkCourse/3_8.png" title="发送窗口示意图"></li>
</ul>
</li>
<li>发送时遇到字节未按序收到的解决方案<ul>
<li>当一部分字节未收到确认时，重新从未收到字节中序号最靠前的那个字节开始重新发送</li>
<li>若发送窗口内的序号都已用完但还没有收到确认，必须停止发送 <em>（不再发送后续字节）</em></li>
</ul>
</li>
<li>发送方的应用进程把字节流写入TCP的发送缓存，发送缓存一般都比发送窗口大<br><img src="../photos/ComputerNetworkCourse/3_9.png" title="发送缓存、发送窗口关系示意图"></li>
<li>接收方的应用进程从TCP的接收缓存中读取字节流，接收缓存一般都比接收窗口大<br><img src="../photos/ComputerNetworkCourse/3_10.png" title="接收缓存、接收窗口关系示意图"></li>
<li><strong>需要注意</strong><ul>
<li>A的发送窗口并不总是和B的接收窗口一样大（因为有一定的时间滞后）</li>
<li>TCP标准没有规定对不按序到达的数据如何处理，通常是先临时放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li>
<li>TCP要求接收方必须有累计确认的功能，这样可以减少传输开销<h3 id="接收方发送确认"><a href="#接收方发送确认" class="headerlink" title="接收方发送确认"></a>接收方发送确认</h3></li>
</ul>
</li>
<li>接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上</li>
<li><strong>需要注意</strong>：<ul>
<li>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，浪费了网络的资源</li>
<li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据<h2 id="3-6-2-超时重传时间的选择"><a href="#3-6-2-超时重传时间的选择" class="headerlink" title="3.6.2 超时重传时间的选择"></a>3.6.2 超时重传时间的选择</h2></li>
</ul>
</li>
<li>重传机制是TCP中最重要和最复杂的问题之一</li>
<li>TCP每发送一个报文段，就对这个报文段设置一次计时器</li>
<li>只要计时器设置的重传时间已到但还没有收到确认，就要重传这一报文段</li>
<li><strong>重传时间的选择是TCP最复杂的问题之一</strong><ul>
<li>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大</li>
<li>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率</li>
</ul>
</li>
<li><strong>TCP采用了一种自适应算法</strong>，它记录一个报文段发出的时间，以及收到相应的确认的时间，这两个时间之差就是报文段的往返时间RTT</li>
<li><strong>往返时延的方差很大</strong>:由于TCP的下层是一个互联网环境，IP数据报所选择的路由变化很大，因而运输层的往返时间的方差也很大<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间"></a>加权平均往返时间</h3></li>
<li>TCP保留了RTT的一个加权平均往返时间RTT<sub>S</sub>（这又称为<strong>平滑的往返时间</strong>）</li>
<li>第一次测量到RTT样本时，RTT<sub>S</sub>值就取为所测量到的RTT样本值，以后每测量到一个新的RTT样本，就按下式重新计算一次RTT<sub>S</sub><br><img src="../photos/ComputerNetworkCourse/3_11.png" title="RTT&lt;sub&gt;S&lt;/sub&gt;迭代计算公式"></li>
<li>其中，0≤α≤1，若α很接近于0，表示RTT值更新较慢，若α接近于1，则表示RTT更新较快</li>
<li>RFC2988推荐的α值为0.125<h3 id="超时重传时间"><a href="#超时重传时间" class="headerlink" title="超时重传时间"></a>超时重传时间</h3></li>
<li><strong>RTO应略大于上面得出的加权平均往返时间RTT<sub>S</sub></strong></li>
<li>RFC2988建议使用<strong>RTO=RTT<sub>S</sub>+4xRTT<sub>D</sub><strong>计算RTO，其中RTT<sub>D</sub>是</strong>RTT的偏差的加权平均值</strong></li>
<li>RFC2988计算RTT<sub>D</sub>的计算方法：第一次测量时，RTT<sub>D</sub>值取为测量到的RTT样本值的一半，在以后的测量中，使用下式计算加权平均的RTT<sub>D</sub><br><img src="../photos/ComputerNetworkCourse/3_12.png" title="RTT&lt;sub&gt;D&lt;/sub&gt;迭代计算公式"></li>
<li>其中β是一个小于1的系数，推荐值为0.25<h3 id="往返时间RTT的测量相当复杂"><a href="#往返时间RTT的测量相当复杂" class="headerlink" title="往返时间RTT的测量相当复杂"></a>往返时间RTT的测量相当复杂</h3></li>
<li>问题描述：TCP报文段1没有收到确认，重传后收到了确认报文段ACK，<strong>如何判定ACK是对第一次发出的报文段的确认还是对重传的报文段的确认？</strong></li>
<li>解决方案：Karn算法<ul>
<li>思想：<strong>在计算平均往返时间RTT时，只要报文段重传了就不采用其往返时间样本</strong></li>
<li>优点：得出的加权平均往返时间RTT<sub>S</sub>和超时重传时间RTO就比较准确</li>
<li>缺点：当报文段的时延突然增大很多时，在原来得出的重传时间内不会收到确认报文段，导致需要重传的报文段占比增加，但根据Karn算法，这些报文段的往返时间样本将不予考虑，因此导致<strong>超时重传时间无法更新</strong></li>
<li><strong>修正的Karn算法</strong><ul>
<li>报文段每重传一次，就把RTO增大一些：<strong>新RTO=γx旧的RTO</strong></li>
<li>其中γ的典型值是2</li>
<li>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延RTT和超时重传时间RTO的数值</li>
<li>实践证明，这种策略较为合理<h2 id="3-6-3-选择确认SACK"><a href="#3-6-3-选择确认SACK" class="headerlink" title="3.6.3 选择确认SACK"></a>3.6.3 选择确认SACK</h2></li>
</ul>
</li>
</ul>
</li>
<li>针对的问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么<strong>能否设法只传送缺少的数据而不重传已经准确到达接收方的数据？</strong></li>
<li>接收方收到和前面字节流不连续的两个字节块，如果这些字节的序号都在接收窗口内，那么接收方就先收下这些数据，但**要把这些信息准确地高速发送方，使发送方不要再重复发送这些已收到的数据<h3 id="RFC2018的规定"><a href="#RFC2018的规定" class="headerlink" title="RFC2018的规定"></a>RFC2018的规定</h3></li>
<li>如果要使用SACK，那么在建立TCP连接时，就要在TCP首部的选项中加上“允许SACK”的选项，而双方都必须事先商定好</li>
<li>如果使用SACK，那么原来首部中的确认号字段的用法仍然不变，只是以后在TCP报文段的首部中都增加了SACK选项，以便报告收到的不连续的字节块的边界</li>
<li>由于首部选项的长度最多只有40字节，而指明一个边界就要用到4字节，因此在选项中<strong>最多只能指明4个字节块的边界信息</strong> </li>
</ul>
<hr>
<h1 id="3-7-TCP的流量控制"><a href="#3-7-TCP的流量控制" class="headerlink" title="3.7 TCP的流量控制"></a>3.7 TCP的流量控制</h1><h2 id="3-7-1-利用滑动窗口实现流量控制"><a href="#3-7-1-利用滑动窗口实现流量控制" class="headerlink" title="3.7.1 利用滑动窗口实现流量控制"></a>3.7.1 利用滑动窗口实现流量控制</h2><h2 id="3-7-2-TCP的传输效率"><a href="#3-7-2-TCP的传输效率" class="headerlink" title="3.7.2 TCP的传输效率"></a>3.7.2 TCP的传输效率</h2><hr>
<h1 id="3-8-TCP的拥塞控制"><a href="#3-8-TCP的拥塞控制" class="headerlink" title="3.8 TCP的拥塞控制"></a>3.8 TCP的拥塞控制</h1><hr>
<h1 id="3-9-TCP的运输连接管理"><a href="#3-9-TCP的运输连接管理" class="headerlink" title="3.9 TCP的运输连接管理"></a>3.9 TCP的运输连接管理</h1><hr>
<h1 id="3-10-补充"><a href="#3-10-补充" class="headerlink" title="3.10 补充"></a>3.10 补充</h1><ul>
<li>使用TCP的网络应用：HTTP\FTP\TELNET\SMTP</li>
<li>使用UDP的网络应用：流媒体\视频会议\DNS\Internet电话</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-需求文档"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/06/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/"
    >需求文档(v4.1)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/06/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/" class="article-date">
  <time datetime="2022-03-06T08:32:17.000Z" itemprop="datePublished">2022-03-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>截止日期：4.21号</strong><br><strong>统一Unity版本:2020.3</strong></p>
<h1 id="效果预期"><a href="#效果预期" class="headerlink" title="效果预期"></a>效果预期</h1><h2 id="三个场景"><a href="#三个场景" class="headerlink" title="三个场景"></a><strong>三个场景</strong></h2><ul>
<li><strong>主页面（标题，选择场景，制作名单）</strong></li>
<li><strong>游戏场景1：石碑刻字</strong><ul>
<li>石碑的场景是一个碑林，可以搭一个园林</li>
<li>有不同的碑文供临摹</li>
<li>临摹的过程是玩家手拿凿子去刻</li>
<li>玩家可随时查看作品的效果</li>
<li>给玩家提供碑文的介绍查阅</li>
</ul>
</li>
<li><strong>游戏场景2：猜灯谜</strong><ul>
<li>猜灯谜的场景最好是一个古代夜市（限制玩家移动范围）或者是一个封闭的游戏室</li>
<li>有不同的灯谜</li>
<li>玩家拼灯谜里的字<ul>
<li>拼字思路：每个字有一个数组，数组元素从第一个到最后一个均为各自对应笔画的个数，这样谜底的每个字都有独立编号，你往填字页面扔笔画组件，对应的数组元素内容++</li>
<li>拼字UI思路：有一个页面，玩家<strong>一个一个地拼</strong>页面上显示上述数组的一个表格，让玩家看到自己在当前字放了哪些笔画，然后有确定键，重来键，<strong>确定键提交全部字，重来键清空当前字</strong>。</li>
</ul>
</li>
<li>有一个能旋转的跑马灯，每切换一次题目就转一下（从慢到快再从快到慢最后停下）</li>
</ul>
</li>
<li><strong>其他</strong><ul>
<li>所有场景都提供到另外两个场景的选项</li>
</ul>
</li>
</ul>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="模型、美术素材"><a href="#模型、美术素材" class="headerlink" title="模型、美术素材"></a>模型、美术素材</h2><ul>
<li><strong>主页面</strong><ul>
<li>标题：书刀梦</li>
<li>标题字体 <strong>（已解决）</strong></li>
<li>主页面演出效果：搭一个夜市场景 <strong>（已解决）</strong></li>
</ul>
</li>
<li><strong>游戏场景1</strong><ul>
<li>石碑模型 <strong>（已解决）</strong></li>
<li>树林模型 <strong>（已解决）</strong></li>
<li>凿子模型 <strong>（已解决）</strong></li>
<li>石碑的材质（类似雪地但需要多刻一会才能留痕迹，同时要控制笔画的最大深度）<strong>（已解决）</strong></li>
<li>几张碑帖的高清图 <strong>（已解决）</strong></li>
<li>换一个天空盒 <strong>（已解决）</strong></li>
</ul>
</li>
<li><strong>游戏场景2</strong><ul>
<li>古代夜市场景，建筑素材 <strong>（已解决）</strong></li>
<li>水面（正在解决）</li>
<li>由于是夜市，所以需要适合的光照（这个的调整可能需要一定时间，所以越早确定场景2的具体内容越好）<strong>（已解决）</strong></li>
<li>灯笼模型（最好是跑马灯的样子和功能，能在上面贴几张古画更好）<strong>（已撤销方案）</strong><ul>
<li>灯笼分件建模，</li>
<li>画贴图，灯笼架子一套贴图灯笼上透光的纸要做另一套贴图 </li>
<li>贴图交由美工自由发挥</li>
</ul>
</li>
<li>选笔画的时候出一个选字页面，有几个按钮，按钮的外观是各个笔画的sprite，按一个按钮，就在旁边的一个盘子或者地上生成相应笔画，然后让玩家捡起来放到指定位置。</li>
<li>字体（暂定华文隶书）</li>
<li>笔画（思路是二维的笔画进行y轴上的拉伸得到柱体），<strong>这个等灯谜确定后我把需要拆分成组件的字发到群里然后做</strong>。</li>
</ul>
</li>
</ul>
<h2 id="玩家的功能"><a href="#玩家的功能" class="headerlink" title="玩家的功能"></a>玩家的功能</h2><ul>
<li>移动</li>
<li>旋转视角</li>
<li>拾取</li>
<li>刻字</li>
<li>UI交互</li>
</ul>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li>主页面需要提供选关页面/按键，标题（UI界面布局在群里）</li>
<li>弹窗显示信息（游戏场景1的碑文介绍功能要用到）</li>
<li>游戏场景1内需要提供让玩家控制弹窗（开启或关闭）、音量调整、碑文图片显示（开启或关闭）的UI</li>
</ul>
<h1 id="目前需要解决（想到的）的问题"><a href="#目前需要解决（想到的）的问题" class="headerlink" title="目前需要解决（想到的）的问题"></a>目前需要解决（<del>想到的</del>）的问题</h1><ul>
<li>游戏标题 <strong>（已解决）</strong></li>
<li>刻字效果的实现 <strong>（已解决）</strong></li>
<li>UI交互还未完全实现</li>
<li>美术素材：灯笼、标题字体、笔画模型<strong>（解决中）</strong></li>
<li>场景的具体内容 <strong>（解决中）</strong></li>
</ul>
<h1 id="目前需要关注的"><a href="#目前需要关注的" class="headerlink" title="目前需要关注的"></a>目前需要关注的</h1><ul>
<li>报名</li>
<li>PPT</li>
<li>学学剪映</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VR/" rel="tag">VR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E8%AE%BE/" rel="tag">计设</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-VR开发日记1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/03/VR%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B01/"
    >UnityVR学习笔记1：准备工作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/03/VR%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B01/" class="article-date">
  <time datetime="2022-03-03T09:59:39.000Z" itemprop="datePublished">2022-03-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.youtube.com/c/ValemVR">原视频作者主页</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">搬运链接</a><br>本文仅供个人学习和知识点记录用。<br>使用设备：Oculus Rift S<br>Unity版本：2020.3.30f1c1</p>
<hr>
<h1 id="Unity内的准备工作"><a href="#Unity内的准备工作" class="headerlink" title="Unity内的准备工作"></a>Unity内的准备工作</h1><p><strong>需要安装的</strong></p>
<ul>
<li>Window-&gt;Package Manager-&gt;XR Interaction Tookit</li>
<li>Edit-&gt;Project Settings-&gt;XR Plugin Management</li>
</ul>
<p><strong>需要设置的</strong><br>Edit-&gt;Project Settings-&gt;XR Plugin Management<br><img src="../photos/Unity/VR/1_1.png"><br><img src="../photos/Unity/VR/1_2.png"></p>
<h2 id="玩家的设置"><a href="#玩家的设置" class="headerlink" title="玩家的设置"></a>玩家的设置</h2><p><strong>玩家内容</strong><br><img src="../photos/Unity/VR/1_3.png" title="玩家内容"><br><strong>玩家组件</strong><br><img src="../photos/Unity/VR/1_4.png" title="玩家组件"><br><strong>相机设置</strong><br><img src="../photos/Unity/VR/1_5.png" title="相机设置"><br><strong>左手柄组件内容</strong><br><img src="../photos/Unity/VR/1_6.png" title="左手柄组件内容"><br><strong>右手传输射线设置</strong><br>Axis To Press Threshold用于设置阈值，当按的深度/力度超过这个阈值即触发传送<br><img src="../photos/Unity/VR/1_7.png" title="右手传输射线设置"></p>
<h1 id="备忘录——一些随便写的注释"><a href="#备忘录——一些随便写的注释" class="headerlink" title="备忘录——一些随便写的注释"></a>备忘录——一些随便写的注释</h1><ul>
<li>teleportation area和teleportation anchor的区别：前者是能传送到平面上任意一点，后者是只能传送到它的组件”Anchor”（锚点）的位置。</li>
<li>如果要使得某些物体不能和射线交互，要在<strong>Teleport Ray</strong>下的<strong>XR Ray Interactor</strong>内的<strong>Interaction Layer Mask</strong>里勾掉这些物体的Layer，一般的做法是专门新建一个被设定不能与射线交互的Layer便于管理。</li>
<li>传送射线的设置在XR Ray Interactor里，更改交互事件在Audio Events和Haptic Events里，勾选后弹出，Duration为持续时间，Intensity是强度</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VR/" rel="tag">VR</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计网课程笔记2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/25/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02/"
    >计网课程笔记2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/25/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02/" class="article-date">
  <time datetime="2022-02-25T11:20:26.000Z" itemprop="datePublished">2022-02-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%BD%91/">课程笔记_计网</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="依照学校教学安排，第二章为应用层（即网课第六章）"><a href="#依照学校教学安排，第二章为应用层（即网课第六章）" class="headerlink" title="依照学校教学安排，第二章为应用层（即网课第六章）"></a>依照学校教学安排，第二章为应用层（即网课第六章）</h1><h1 id="应用层协议的特点"><a href="#应用层协议的特点" class="headerlink" title="应用层协议的特点"></a>应用层协议的特点</h1><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决是通过位于不同主机中的多个应用之间的通信和协同工作来完成的，应用层的具体内容就是规定应用进程在通信时所遵循的协议。<br><strong>应用层的许多协议都是基于客户服务器方式</strong>，客户和服务器均为通信中所涉及的两个<strong>应用进程</strong>，客户服务器方式描述的是<strong>进程之间服务与被服务的关系</strong></p>
<h1 id="2-1-域名系统DNS"><a href="#2-1-域名系统DNS" class="headerlink" title="2.1 域名系统DNS"></a>2.1 域名系统DNS</h1><h2 id="2-1-1-什么是DNS"><a href="#2-1-1-什么是DNS" class="headerlink" title="2.1.1 什么是DNS"></a>2.1.1 什么是DNS</h2><ul>
<li><strong>域名系统</strong>：是互联网的一项服务，它是<strong>将域名和IP地址相互映射的一个分布式数据库</strong>，使人更容易地访问互联网、记忆网址</li>
<li>互联网采用层次结构的命名树作为主机的名字</li>
<li><strong>域名服务器</strong>：运行<strong>名字到IP地址的解析程序</strong>的机器，域名服务器程序在专设的结点上运行<h2 id="2-1-2-互联网的域名结构"><a href="#2-1-2-互联网的域名结构" class="headerlink" title="2.1.2 互联网的域名结构"></a>2.1.2 互联网的域名结构</h2></li>
<li>互联网采用层次树状结构的命名方法</li>
<li>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即<strong>域名</strong></li>
<li>域名的结构由标号序列组成，各标号之间用点隔开</li>
<li><strong>标号最长63个字符（不包含相隔的点），域名最长253个字符</strong></li>
</ul>
<p>例如：<a href="http://www.baidu.com，从左到右依次为：三级域名、二级域名、顶级域名，等级从低到高，有几段标号，www就是几级域名">www.baidu.com，从左到右依次为：三级域名、二级域名、顶级域名，等级从低到高，有几段标号，www就是几级域名</a></p>
<h3 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h3><ul>
<li>国家顶级域名nTLD:.cn/.us/.ru…</li>
<li>通用顶级域名gTLD:.gov（政府）/.edu（教育机构）/.org（非营利性组织）/.mil（军事部门）/.net（网络服务机构）/.int（国际组织）/.com或.biz（公司和企业）/.jobs（人力企业）/.coop（合作团体）/.aero（航空公司）/.pro（持有证书的专业人员）/.name（个人）/.museum（博物馆）…<strong>当.edu/.gov/.mil是顶级域名时，则域名均为美国专用，其他国家需要添加国家顶级域名</strong> <h2 id="2-1-3-域名服务器"><a href="#2-1-3-域名服务器" class="headerlink" title="2.1.3 域名服务器"></a>2.1.3 域名服务器</h2></li>
</ul>
<p><strong>既然域名系统是一个数据库，那么它放在哪里？</strong></p>
<ul>
<li><strong>区</strong>：一个服务器所负责管辖（或有权限的）范围</li>
<li>各单位根据具体情况来划分自己管辖范围的区，但在一个区内的所有节点必须是能够连通的</li>
<li>每一个区内所有主机的域名到IP地址的映射均存放在该区的<strong>权限域名服务器</strong>内</li>
<li>DNS服务器的管辖范围不以“域”为单位，而是以“区”为单位</li>
<li>找到域名对应的IP地址首先要找到<strong>根域名服务器</strong>，然后找其下的<strong>顶级域名服务器</strong>逐级往下直到找到域名</li>
<li><strong>根域名服务器共有13套装置，不是13个机器</strong>，这些装置对应的域名为从a.rootservers.net到m.rootservers.net，其中一套为<strong>主根服务器</strong>，其余12套为<strong>辅根服务器</strong>，截止到2016年2月，全世界已经在588个地点安装了根域名服务器 （有1000台以上的服务器）<em>（为了让世界上大部分DNS域名服务器都能就近找到一个域名服务器）</em>，所以<strong>根域名服务器不是13个机器，一套装置就是一个根服务器集群</strong>，访问根服务器的域名需要32个字节</li>
<li><strong>在IPV4下，为了在大多数的网络上进行传输，一个DNS数据包的大小规定小于等于512个字节</strong>，传输时在这个数据包的基础上还要加上8个字节大小的UDP头部，20个字节大小的IP，一定字节大小的数据链路层头部等等</li>
<li><strong>为什么根域名服务器只有13个</strong>:存放一个根域名服务器的域名需要32字节，而一个DNS数据包的大小规定小于等于512个字节，其中包含了13台根服务器的域名共416字节，为了省出足够空间存放其他参数，因此目前只有13台根服务器</li>
<li>根域名服务器不直接把域名转换成IP地址，在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的IP地址告诉本地域名服务器</li>
<li><strong>顶级域名服务器</strong>：负责管理在该顶级域名服务器注册的所有二级域名，当收到DNS查询请求时，就给出相应的回答 <em>（可能是最后的结果，也可能是下一步应当找的域名服务器的IP地址）</em></li>
<li><strong>分区域名服务器</strong>：负责一个区的域名服务器，当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户下一步应当找哪一个权限域名服务器</li>
<li><strong>本地域名服务器</strong>：当一个主机发出DNS查询请求时，这个查询请求报文就将发送给本地域名服务器，每一个互联网服务提供者ISP都可以拥有一个本地域名服务器，这种域名服务器也称为<strong>默认域名服务器</strong></li>
<li><strong>本地域名服务器采用迭代查询</strong>：当一个主机发出DNS查询请求时，这个请求将最先送到本地域名服务器，<strong>如果这个域名和对应的IP在服务器内没有存储或IP已经过期</strong>则本地域名服务器首先询问根域名服务器，获得顶级域名服务器IP，本地域名服务器再根据得到的IP询问顶级域名服务器，获得权限域名服务器IP，再根据得到的IP逐级向下询问次级权限域名服务器，直到获得完整的IP，本地域名服务器将域名和IP进行存储，最后将IP传给主机，完成查询。<strong>如果这个域名和对应的IP在服务器内存在或有效</strong>则本地域名服务器将存储的IP发送给主机，结束查询。</li>
<li><strong>本地域名服务器采用递归查询（少用）</strong>：<strong>如果这个域名和对应的IP在服务器内没有存储或IP已经过期</strong>，则本地域名服务器首先询问根域名服务器，根域名服务器再询问顶级域名服务器，顶级域名服务器再询问权限域名服务器，权限域名服务器逐级向下询问直到所有标号序列均查询完毕，询问顺序中最后一个权限域名服务器将完整的IP逐级返回到上一级域名服务器，根域名服务器将IP返回给本地域名服务器，本地域名服务器将域名和IP进行存储，最后将IP传给主机，完成查询。<strong>如果这个域名和对应的IP在服务器内存在或有效</strong>则本地域名服务器将存储的IP发送给主机，结束查询。由于根服务器是公共资源，我们希望根服务器的资源利用最大化，因此查询常常只发生在主机和本地域名服务器之间。</li>
<li>名字的高速缓存：<strong>每个域名服务器都维护一个高速缓存</strong>，存放最近用过的名字以及从何处获得名字映射信息的记录，这么做可以大大减轻根域名服务器的负荷，使互联网上的DNS查询请求和回答报文的数量大为减少。为了保持高速缓存中的内容正确，域名服务器应该为每项内容设置计时器，并处理超过合理时间的项。<strong>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值，增加此时间值可以减少网络开销，减少此时间值可以提高域名转换的准确性</strong></li>
</ul>
<hr>
<h1 id="2-2-文件传送协议"><a href="#2-2-文件传送协议" class="headerlink" title="2.2 文件传送协议"></a>2.2 文件传送协议</h1><h2 id="2-2-1-文件传送协议-File-Transfer-Protocol-FTP-概述"><a href="#2-2-1-文件传送协议-File-Transfer-Protocol-FTP-概述" class="headerlink" title="2.2.1 文件传送协议(File Transfer Protocol,FTP)概述"></a>2.2.1 文件传送协议(File Transfer Protocol,FTP)概述</h2><ul>
<li>FTP是互联网上使用最广泛的文件传送协议，有两种传输方式：<strong>ASCII传输</strong>和<strong>bit传输</strong></li>
<li>FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有存取权限</li>
<li>FTP屏蔽了各计算机系统的细节，因而适用于在异构网络中任意计算机之间传送文件</li>
<li>RFC959很早就成为了互联网的正式标准</li>
</ul>
<h2 id="2-2-2-FTP的基本工作原理"><a href="#2-2-2-FTP的基本工作原理" class="headerlink" title="2.2.2 FTP的基本工作原理"></a>2.2.2 FTP的基本工作原理</h2><ul>
<li>文件传送协议FTP只借助TCP可靠的运输服务提供文件传送的一些基本服务</li>
<li>FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性</li>
<li>FTP使用<strong>客户-服务器</strong>工作方式，一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由<strong>一个主进程和若干个从属进程两大部分</strong>组成，主进程负责接受新的请求，从属进程负责处理单个请求</li>
</ul>
<h3 id="主进程的工作步骤"><a href="#主进程的工作步骤" class="headerlink" title="主进程的工作步骤"></a>主进程的工作步骤</h3><ul>
<li>打开熟知端口（端口号为21），使客户进程能够连接上</li>
<li>等待客户进程发出连接请求</li>
<li>启动从属进程来处理客户进程发来的请求，从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其它一些子进程</li>
<li>回到等待状态，继续接受其他客户进程发来的请求，主进程与从属进程的处理是<strong>并发</strong>地进行</li>
</ul>
<h3 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h3><ul>
<li>控制连接在整个会话期间一直保持打开，FTP客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件</li>
<li>连接建立后，通过20号端口来进行数据连接（21号端口仍然打开），用于传输文件。服务器端的控制进程在接收到FTP客户发送来的文件传输请求后就创建<strong>数据传送进程</strong>和<strong>数据连接</strong>，用来连接客户端和服务器端的数据传送进程</li>
<li>数据传送进程实际完成文件的传送，在传送完毕后关闭数据传送连接并结束运行</li>
<li>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的<strong>熟知端口（21）</strong>，同时还要高速服务器进程自己的另一个端口号码用于数据传送连接，之后服务器用自己传送数据的<strong>熟知端口（20）</strong>与客户进程所提供的端口号码建立数据传送连接</li>
<li>使用两个不同端口号的好处<ul>
<li>使协议更加简单和更容易实现</li>
<li>在传输文件时还可以利用控制连接来控制传输文件进程。</li>
</ul>
</li>
</ul>
<h3 id="网络文件系统-Network-File-System，NFS-的思路"><a href="#网络文件系统-Network-File-System，NFS-的思路" class="headerlink" title="网络文件系统(Network File System，NFS)的思路"></a>网络文件系统(Network File System，NFS)的思路</h3><ul>
<li>NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据</li>
<li>NFS可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件，NFS软件把需要添加的数据和写数据请求一起发送到远地计算机的NFS服务器，NFS服务器更新文件后返回应答信息 <em>（比如git bash）</em></li>
<li><strong>NFS在网络上传送的只是少量的修改数据</strong></li>
</ul>
<h2 id="2-2-3-简单文件传送协议-Trival-File-Transfer-Protocal-TFTP"><a href="#2-2-3-简单文件传送协议-Trival-File-Transfer-Protocal-TFTP" class="headerlink" title="2.2.3 简单文件传送协议(Trival File Transfer Protocal,TFTP)"></a>2.2.3 简单文件传送协议(Trival File Transfer Protocal,TFTP)</h2><ul>
<li>TFTP是一个很小且易于实现的文件传送协议</li>
<li>TFTP使用客户服务器方式和使用UDP <em>（无连接运输）</em>数据报，因此TFTP需要有自己的差错改正措施</li>
<li>TFTP<strong>只支持文件传输</strong>而不支持交互</li>
<li>TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别</li>
</ul>
<hr>
<h1 id="2-3-远程终端协议TELNET（课程略）"><a href="#2-3-远程终端协议TELNET（课程略）" class="headerlink" title="2.3 远程终端协议TELNET（课程略）"></a>2.3 远程终端协议TELNET（课程略）</h1><hr>
<h1 id="2-4-万维网WWW"><a href="#2-4-万维网WWW" class="headerlink" title="2.4 万维网WWW"></a>2.4 万维网WWW</h1><hr>
<h1 id="2-5-电子邮件"><a href="#2-5-电子邮件" class="headerlink" title="2.5 电子邮件"></a>2.5 电子邮件</h1><h2 id="2-5-1电子邮件概述"><a href="#2-5-1电子邮件概述" class="headerlink" title="2.5.1电子邮件概述"></a>2.5.1电子邮件概述</h2><ul>
<li>电子邮件的传送方式是将邮件发送到收件人使用的邮件服务器并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取，是一种<strong>非即时</strong>的通信方式。</li>
<li>电子邮件具有<strong>方便、传递迅速、费用低廉的优点</strong></li>
<li>电子邮件的标准：<strong>发送邮件SMTP</strong>、<strong>读取邮件POP3和IMAP</strong>、<strong>同时传送多种类型数据MIME</strong></li>
<li>电子邮件的传送过程:发件人以SMTP标准借助TCP可靠的运输服务向发送方邮件服务器的25号端口传送邮件，发送方邮件服务器以SMTP标准借助TCP向接收方邮件服务器发送邮件，接收方邮件服务器以POP3/IMAP标准读取邮件，收件人以POP3/IMAP标准从接收方邮件服务器读取邮件 <strong>（POP3服务器和POP3客户之间的通信是由POP3客户发起的）</strong><br><img src="../photos/ComputerNetworkCourse/2_1.png" title="电子邮件发送-接收示意图"></li>
<li>用户代理(User Agent,UA)：用户与电子邮件系统的接口，是电子邮件客户端软件，功能是<strong>撰写、显示、处理和通信</strong>，邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况</li>
<li>TCP/IP体系的电子邮件系统规定电子邮件地址的格式：收件人邮箱名@邮箱所在主机的域名</li>
</ul>
<h2 id="2-5-2简单邮件传送协议SMTP"><a href="#2-5-2简单邮件传送协议SMTP" class="headerlink" title="2.5.2简单邮件传送协议SMTP"></a>2.5.2简单邮件传送协议SMTP</h2><ul>
<li>SMTP所规定的就是在两个相互通信的SMTP进程之间如何交换信息</li>
<li>由于SMTP使用<strong>客户-服务器</strong>工作方式，因此负责发送邮件的SMTP进程就是SMTP客户，而负责接收邮件的SMTP进程就是SMTP服务器</li>
<li><strong>SMTP通信的3个阶段</strong>：<strong>连接建立——邮件传送——连接释放</strong>（在发送主机的SMTP客户和负责接收的SMTP服务器之间建立连接，邮件发送完毕后，SMTP应释放TCP连接）<strong>SMTP不使用中间的邮件服务器</strong></li>
<li>缺陷：不能传送可执行文件或其他的二进制对象，仅限于传送7位的ASCII码，这意味着许多非英语国家的文字无法传送，SMTP服务器会拒收超过一定长度的邮件</li>
</ul>
<h2 id="2-5-3电子邮件的信息格式"><a href="#2-5-3电子邮件的信息格式" class="headerlink" title="2.5.3电子邮件的信息格式"></a>2.5.3电子邮件的信息格式</h2><ul>
<li>电子邮件的组成：<strong>信封和内容</strong></li>
<li>RFC822只规定了邮件内容中的首部格式，而对邮件的主体部分则让用户自由撰写，用户写好首部后，邮件系统将自动将信封所需的信息提取出来并写在信封上，无需用户填写，邮件内容首部包括一些关键字，后面加上冒号，最重要的关键字是<strong>To（后面填入收件人的电子邮件地址）、Subject（邮件的主题，便于用户查找）、Cc（表示应给某人发送一个邮件副本）、From和Date（分别表示发件人的电子邮件地址和发件日期）、Reply-To（对方回信所用的地址）</strong></li>
</ul>
<h2 id="2-5-4邮件读取协议POP3和IMAP4"><a href="#2-5-4邮件读取协议POP3和IMAP4" class="headerlink" title="2.5.4邮件读取协议POP3和IMAP4"></a>2.5.4邮件读取协议POP3和IMAP4</h2><ul>
<li>邮局协议POP是一个非常简单但功能有限的邮件读取协议，POP3是它的第三个版本，也是当前使用的版本。</li>
<li>POP也使用<strong>客户-服务器</strong>的工作方式，在接收邮件的用户PC机中必须运行POP客户程序，而在用户所连接的互联网服务提供商(Internet Service Provider,ISP)的邮件服务器中运行POP服务器程序</li>
<li>交互邮件访问协议IMAP也使用<strong>客户-服务器</strong>的工作方式，IMAP4是它的第四个版本，也是当前使用的版本。</li>
<li>用户在自己的PC机上就可以操纵ISP的邮件服务器的邮箱，就像在本地操纵一样</li>
<li><strong>IMAP是一个联机协议</strong>，当用户PC机上的IMAP客户程序打开IMAP服务器的邮箱时，用户就可看到邮件的首部，若用户需要打开某个邮件，则邮件才传到用户的PC机上</li>
<li>IMAP的优势<ul>
<li>用户可以在不同的地方使用不同的计算机随时上网阅读和处理的自己的邮件</li>
<li>IMAP允许收件人只读取邮件中的某一个部分</li>
</ul>
</li>
<li>IMAP的缺点：如果用户没有将邮件复制到自己的PC上，则邮件一直是存放在IMAP服务器上，因此用户需要经常与IMAP服务器建立连接</li>
</ul>
<h2 id="2-5-5基于万维网的电子邮件"><a href="#2-5-5基于万维网的电子邮件" class="headerlink" title="2.5.5基于万维网的电子邮件"></a>2.5.5基于万维网的电子邮件</h2><ul>
<li>发件方使用<strong>HTTP协议</strong>将邮件发送到邮件服务器，两个服务器之间的传送使用SMTP协议，邮件从服务器传到收件方是使用HTTP协议</li>
<li>万维网电子邮件的优势：只要能够找到可以上网的PC机，打开任何一种浏览器都可以方便地<strong>收发</strong>电子邮件，是一种“B-S”的方式（浏览器-服务器），而上述所提到的SMTP\POP3\IMAP都是“C-S”的方式（客户-服务器）</li>
</ul>
<h2 id="2-5-6通用互联网邮件扩充MIME"><a href="#2-5-6通用互联网邮件扩充MIME" class="headerlink" title="2.5.6通用互联网邮件扩充MIME"></a>2.5.6通用互联网邮件扩充MIME</h2><ul>
<li>由于SMTP能够传送的文件格式有限，因此MIME继续使用RFC822格式的同时增加了<strong>邮件主体的结构</strong>，定义了<strong>传送非ASCII码的编码规则</strong>，但<strong>MIME并没有改动SMTP或取代它</strong></li>
<li>MIME和SMTP的关系：邮件（非ASCII码）先通过MIME转换成7位ASCII码，再使用SMTP传输，然后通过MIME转回非ASCII码交给用户<br><img src="../photos/ComputerNetworkCourse/2_2.png" title="MIME和SMTP关系示意图"></li>
<li>MIME的三个主要部分<ul>
<li>首部字段：添加了5个新的首部字段，它们可包含在RFC822首部中，这些字段提供了有关邮件主体的信息</li>
<li>格式：定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li>
<li>传送编码：定义了新的传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-6-动态主机配置协议DHCP（课程略）"><a href="#2-6-动态主机配置协议DHCP（课程略）" class="headerlink" title="2.6 动态主机配置协议DHCP（课程略）"></a>2.6 动态主机配置协议DHCP（课程略）</h1><h1 id="2-7-简单网络管理协议SNMP（课程略）"><a href="#2-7-简单网络管理协议SNMP（课程略）" class="headerlink" title="2.7 简单网络管理协议SNMP（课程略）"></a>2.7 简单网络管理协议SNMP（课程略）</h1><hr>
<h1 id="2-8-应用进程跨越网络的通信"><a href="#2-8-应用进程跨越网络的通信" class="headerlink" title="2.8 应用进程跨越网络的通信"></a>2.8 应用进程跨越网络的通信</h1><h2 id="2-8-1系统调用和应用编程接口"><a href="#2-8-1系统调用和应用编程接口" class="headerlink" title="2.8.1系统调用和应用编程接口"></a>2.8.1系统调用和应用编程接口</h2><ul>
<li>大多数操作系统使用系统调用的机制在应用程序和操作系统间传递控制权</li>
<li>系统调用和程序中的函数调用较为相似，只是系统调用是将控制权传递给操作系统，而函数调用的控制权是在调用函数的那部分代码 </li>
</ul>
<h2 id="2-8-2几种常用的系统调用"><a href="#2-8-2几种常用的系统调用" class="headerlink" title="2.8.2几种常用的系统调用"></a>2.8.2几种常用的系统调用</h2><ul>
<li>应用编程接口API——应用进程和操作系统控制权进行转换的接口：当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口，此接口再将控制权传递给计算机的操作系统，操作系统将此调用转给某个内部进程，并执行所请求的操作，内部过程一旦执行完毕，控制权又通过系统调用接口返回给应用进程<ul>
<li>套接字接口</li>
<li>Windows Socket：采用套接字接口但稍有不同</li>
<li>TLI，为UNIX系统定义的一种API</li>
</ul>
</li>
<li><strong>套接字 <em>（IP地址+端口）</em>的作用**：当应用进程需要使用网络进行通信的时候就发出系统调用，请求操作系统为其创建套接字，以便把网络通信所需要的系统资源分配给该应用进程，操作系统为这些资源的综合用一个叫做</strong>套接字描述符**的号码来表示，并把此号码返回给应用进程，应用进程所进行的网络操作都必须使用这个号码。通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该号码相关的所有资源</li>
</ul>
<hr>
<h1 id="2-9-P2P应用"><a href="#2-9-P2P应用" class="headerlink" title="2.9 P2P应用"></a>2.9 P2P应用</h1><h2 id="2-9-0P2P工作方式概述"><a href="#2-9-0P2P工作方式概述" class="headerlink" title="2.9.0P2P工作方式概述"></a>2.9.0P2P工作方式概述</h2><ul>
<li>P2P出现的背景：自从互联网能够提供音频、视频服务后，宽带上网用户数量急剧增长，很多用户使用宽带接入的目的就是更快地下载音频视频文件</li>
<li>P2P工作方式：所有的音频、视频文件都是在普通的互联网用户之间传输，<strong>每个客户也可以是服务器</strong>，在P2P工作方式下，相当于有很多分散在各地的媒体服务器提供下载服务</li>
<li>在互联网流量中，P2P工作方式下的文件分发已占据最大的份额，比万维网应用所占的比例要大得多</li>
<li>优点：用户不必访问集中式服务器，缓解了集中式媒体服务器可能出现的瓶颈问题，多个用户拥有相同资源使得可以获得的资源来源更多，获取资源更为方便、快捷<h2 id="2-9-1具有集中目录服务器的P2P工作方式"><a href="#2-9-1具有集中目录服务器的P2P工作方式" class="headerlink" title="2.9.1具有集中目录服务器的P2P工作方式"></a>2.9.1具有集中目录服务器的P2P工作方式</h2></li>
<li>Napster<ul>
<li>是最早出现的P2P技术，用于提供MP3音乐的免费下载</li>
<li>Napster能够搜索音乐文件，所有的音乐<strong>文件地址</strong>击中存放在一个Napster目录服务器中，便于用户下载</li>
<li>用户要及时向Napster的目录服务器报告自己存有的音乐文件，当用户需要下载时，就向服务器发出询问，服务器根据检索结果返回地址，Napster<strong>文件传输是分散的，但文件的定位是集中的</strong></li>
<li>缺点：可靠性差（需要目录服务器）、侵犯版权</li>
</ul>
</li>
</ul>
<h2 id="2-9-2具有全分布式结构的P2P文件共享程序"><a href="#2-9-2具有全分布式结构的P2P文件共享程序" class="headerlink" title="2.9.2具有全分布式结构的P2P文件共享程序"></a>2.9.2具有全分布式结构的P2P文件共享程序</h2><ul>
<li>电驴eMule<ul>
<li>电驴使用<strong>分散定位和分散传输技术</strong>，把每一个文件划分为许多小文件块，使用<strong>多源文件传输协议MFTP</strong>进行传送。因此用户可以同时从很多地方<strong>并行下载一个文件中的不同文件块</strong>，这么做使得下载可以较快完成</li>
<li>电驴用户在下载文件的同时也在上传文件</li>
</ul>
</li>
<li>比特洪流BT**<del>种子！</del><strong>：BitTorrent所有对等方集合称为一个</strong>洪流<strong>，下载文件的数据单元为</strong>长度固定的文件块<strong>，基础设施节点则叫做</strong>追踪器**，用于获得对等方列表</li>
</ul>
<h2 id="2-9-3P2P文件分发的分析"><a href="#2-9-3P2P文件分发的分析" class="headerlink" title="2.9.3P2P文件分发的分析"></a>2.9.3P2P文件分发的分析</h2><ul>
<li>使用P2P方式下载文件会<strong>同时占用下载和上传带宽</strong></li>
<li>C/S方式下分发的最短时间<ul>
<li>从服务器端考虑，有N台主机从服务器下载一个大文件，所有主机分发完毕的最短时间T不可能小于NF/u（？为啥），其中F为文件大小，单位为bit；上传速率和下载速率分别为u和d，单位为bit/s</li>
<li>若下载速率最慢的主机的下载速率为dmin，则T不可能小于F/dmin</li>
<li>综上可知所有主机都下载完文件F的最少时间为T=max（NF/u，F/dmin）</li>
</ul>
</li>
</ul>
<h2 id="2-9-4在P2P对等方式中搜索对象"><a href="#2-9-4在P2P对等方式中搜索对象" class="headerlink" title="2.9.4在P2P对等方式中搜索对象"></a>2.9.4在P2P对等方式中搜索对象</h2><ul>
<li>现在广泛使用的索引和查找技术叫做<strong>分布式散列表DHT</strong>，也可译为<strong>分布式哈希表</strong>，它是由大量对等方共同维护的散列表</li>
<li>分布式散列表DHT利用散列函数，把资源名K及其存放的结点IP地址N都分别映射为资源名标识符KID和节点标识符NID</li>
<li>chord算法把结点按标识符数值从小到大沿顺时针排列成一个环形覆盖网络</li>
</ul>
<hr>
<h2 id="2-10补充"><a href="#2-10补充" class="headerlink" title="2.10补充"></a>2.10补充</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-使用git更新博客遇到的问题与解决方案"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/25/%E4%BD%BF%E7%94%A8git%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"
    >使用git bash更新博客遇到的问题与解决方案</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/25/%E4%BD%BF%E7%94%A8git%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/" class="article-date">
  <time datetime="2022-02-25T10:27:16.000Z" itemprop="datePublished">2022-02-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/hexo/">hexo</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>此帖仅供参考，不一定适合你的情况，请谨慎采纳，造成的一切后果作者不承担责任。</strong></p>
<h1 id="需要确认的"><a href="#需要确认的" class="headerlink" title="需要确认的"></a>需要确认的</h1><h2 id="sshkey是否生成并添加到github"><a href="#sshkey是否生成并添加到github" class="headerlink" title="sshkey是否生成并添加到github"></a>sshkey是否生成并添加到github</h2><p><strong>如果没有</strong><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/u014103733/article/details/79190004">解决方案</a></p>
<h1 id="问题描述与解决方案"><a href="#问题描述与解决方案" class="headerlink" title="问题描述与解决方案"></a>问题描述与解决方案</h1><p> <em>（框架为hexo6.0.0，git bash版本v2.34.1.windows.1主题是ayer）</em>作者在使用git bash部署博客到github时遇到的问题如下：</p>
<ul>
<li>error：10053<ul>
<li>解决方案1（上传较大文件时出现）：在git中输入<strong>git config –global http.postBuffer 524288000</strong></li>
<li>解决方案2(修改postBuffer后还是不行）：网络问题（github的服务器在国外所以连接不稳定），<strong>多hexo g &amp;&amp; hexo d几次就行</strong></li>
</ul>
</li>
<li><strong>添加了sshkey但还是出现了</strong>OpenSSL SSL_connect: Connection was aborted in connection to github.com:443<ul>
<li>解决方案1：挂梯子</li>
<li><strong>挂了梯子还是出现</strong>：看下面情况的解决方案1</li>
</ul>
</li>
<li>fatal: unable to access <a target="_blank" rel="noopener" href="https://github.com/">https://github.com/</a> xxxx: Failed to connect to 127.0.0.1 port xxxx:<ul>
<li>解决方案1（修改代理）：<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_42995270/article/details/114903306">解决方案</a>/<a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41102371/article/details/122213285?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-122213285.pc_agg_new_rank&utm_term=github%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E4%BD%86%E6%97%A0%E6%B3%95git&spm=1000.2123.3001.4430">查看id和端口post</a></li>
<li>解决方案2：挂梯子</li>
</ul>
</li>
<li>补充：修改代理可以直接在C盘用户文件夹内搜gitconfig文件，直接进行修改，修改完建议重启git bash以检验。</li>
</ul>
<p><strong>梯子推荐：</strong><a target="_blank" rel="noopener" href="https://mojie.me/#/login">魔戒(需付费)</a></p>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/connection-was-aborted/" rel="tag">connection was aborted</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git-bash/" rel="tag">git bash</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git-error-10053/" rel="tag">git_error 10053</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/git-error-443/" rel="tag">git_error 443</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/hexo/" rel="tag">hexo</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/test/" rel="tag">test</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-异常"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/14/%E5%BC%82%E5%B8%B8/"
    >异常与异常处理</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/14/%E5%BC%82%E5%B8%B8/" class="article-date">
  <time datetime="2022-02-14T08:02:45.000Z" itemprop="datePublished">2022-02-14</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">课程笔记_面向对象编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"><a href="#本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。" class="headerlink" title="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"></a>本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。</h2><h1 id="异常与异常处理"><a href="#异常与异常处理" class="headerlink" title="异常与异常处理"></a>异常与异常处理</h1><h2 id="什么是异常和异常处理"><a href="#什么是异常和异常处理" class="headerlink" title="什么是异常和异常处理"></a>什么是异常和异常处理</h2><p>异常：<strong>异常是在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序</strong>。在Java中，它是一种特殊的对象，类型为java.lang.Exception或其子类<br>如何解决呢？</p>
<ul>
<li>程序员通过代码堵住程序可能出现的漏洞</li>
<li>程序员在设计程序的阶段预测可能出现的异常并写好对应措施，当程序遇到这些异常时，会按照事先规定好的代码去处理异常而不含让程序中断运行</li>
<li>IDE和编程语言提供的<strong>异常处理机制</strong>（标红，报错等等）</li>
</ul>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul>
<li>Java的异常处理是通过<strong>try、catch、finally、throw和throws</strong>五个关键字来完成的，<strong>try执行可能产生异常的代码，catch捕获异常，无论是否发生异常，finally中的代码总能执行，throws声明方法可能要抛出的各种异常，throw手动抛出异常</strong></li>
<li>Java内的异常Exception是一个<strong>类</strong>，catch要捕获的是Exception类的对象<ul>
<li>常见的异常类型<ul>
<li><strong>Exception</strong>:异常层次结构的父类</li>
<li><strong>ArithmeticException</strong>:算术错误</li>
<li><strong>InputMismatchException</strong>：输入格式不匹配 <em>（比如要求输入int但得到字符串）</em></li>
<li><strong>ArrayIndexOutOfBoundsException</strong>:数组下标越界</li>
<li><strong>NullPointerException</strong>:尝试访问null对象成员 <em>（比如你将一个字符串用equals()跟指向null的字符串比较）</em></li>
<li><strong>ClassNotFoundException</strong>:不能加载所需的类 <em>（比如打错类名了）</em></li>
<li><strong>lllegalArgumentException</strong>:方法接收到非法参数</li>
<li><strong>ClassCastException</strong>:对象强制类型转换错误</li>
<li><strong>NumberFormatException</strong>:数字格式转换异常 <em>（比如把“abc”转换成数字）</em></li>
</ul>
</li>
</ul>
</li>
<li>在catch块中处理异常：<ul>
<li>使用**System.err.println()**来输出错误反馈信息</li>
<li>使用**e.printStackTrace()**来输出异常的堆栈信息并跟踪异常产生的位置和过程</li>
<li>使用**e.getMessage()**得到描述异常的字符串，而该字符串是printStackTrace()输出信息的一部分，如果异常没有描述字符串则输出null</li>
</ul>
</li>
<li>关于多重catch块<ul>
<li>排列catch语句的顺序：<strong>先子类后父类</strong></li>
<li>发生异常时按顺序逐个匹配</li>
<li><strong>只执行第一个与异常类型匹配的catch语句</strong></li>
</ul>
</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//使用try-catch-finally处理、捕捉异常，分为三种情况：</span><br><span class="line">public void method()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        //可能产生异常的代码块</span><br><span class="line">    &#125;</span><br><span class="line">    catch(异常类型 ex)&#123;</span><br><span class="line">        //对异常进行处理的代码段</span><br><span class="line">    &#125;</span><br><span class="line">    finally&#123;</span><br><span class="line">        //无论如何都会执行的代码段，除了极个别情况</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//第一种情况：无事发生，执行顺序：try——&gt;finally（跳过catch）</span><br><span class="line">//第二种情况：产生可以处理的异常：try（try内产生异常的行后面的代码不会被执行）——&gt;catch——&gt;finally（除非catch内的处理方法里有退出Java虚拟机方法System.exit(1)，否则继续）</span><br><span class="line">//第三种情况：产生异常类型不匹配：try——&gt;产生的异常会和catch的异常类型进行匹配，如果不匹配则中断运行，但是一定会在中断之前执行finally</span><br></pre></td></tr></table></figure>
<h3 id="使用throws声明异常"><a href="#使用throws声明异常" class="headerlink" title="使用throws声明异常"></a>使用throws声明异常</h3><p>如果一个方法体可能抛出异常，我们使用throws声明可能抛出的各种异常，异常之间用逗号隔开<br>调用者的对应方式有：</p>
<ul>
<li>处理异常</li>
<li>继续声明异常，比如a方法声明了异常，调用它的b方法不解决异常，可以继续声明a的异常，由于这些方法最后都会回到main方法，所以如果这些方法都不解决异常，就交给虚拟机处理 <em>main方法声明的异常由Java虚拟机处理</em></li>
</ul>
<h3 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h3><p>写法见以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">throw new 某类型Exception(&quot;异常信息&quot;);//当使用throw显式抛出异常，必须对异常处理，或throws声明异常</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>throw</th>
<th align="center">throws</th>
</tr>
</thead>
<tbody><tr>
<td>生成并抛出异常</td>
<td align="center">声明方法内抛出了异常</td>
</tr>
<tr>
<td>位于方法体内部，可作为单独语句使用</td>
<td align="center">必须跟在方法参数列表后面，不能单独使用</td>
</tr>
<tr>
<td>抛出一个异常对象，且只能是一个</td>
<td align="center">声明抛出异常类型，可以用来一次声明多个异常类型</td>
</tr>
</tbody></table>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>如果在try和catch中遇到return，<strong>先执行finally，再执行return</strong>、</li>
<li>try\catch\finally可以任意组合， 但必须有try，catch和finally至少出现一个</li>
<li>如果方法内产生异常却不在方法内处理 <em>有throw但没有catch</em>，就必须使用throws声明该异常</li>
</ul>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><p>我们注意到，Exception对象的直接父类是Throwable类，而Throwable类除了Exception类这个直接子类外，还有一个直接子类叫Error。Error为<strong>仅靠程序本身无法恢复的严重错误，代表Java虚拟机的底层问题</strong>（比如AWTError <em>（发生严重的Abstract Window Toolkit错误时抛出）</em>、线程意外终止ThreadDeath等、内存溢出OutOfMemoryError）而Exception为<strong>由Java应用程序抛出和处理的非严重错误</strong>。而Exception又进一步可细分为<strong>Checked异常和运行时异常RuntimeException</strong>，Checked异常在编译时会被检查出来，程序必须处理该类异常，如ClassNotFoundException、ClassCastException等。RuntimeException表示该异常为运行时可能出现的异常，在编译时不会检查的异常，不要求程序必须做出处理，如ArithmeticException算术异常、调用null对象异常NullPointerException等，这些异常一般是由程序的逻辑错误引起的。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h2 id="异常链与异常处理原则"><a href="#异常链与异常处理原则" class="headerlink" title="异常链与异常处理原则"></a>异常链与异常处理原则</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/try-catch-finally/" rel="tag">try-catch-finally</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%BC%82%E5%B8%B8/" rel="tag">异常</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boop/" rel="tag">面向对象编程oop</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-抽象类和接口"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/"
    >抽象类和接口</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/" class="article-date">
  <time datetime="2022-02-13T02:55:43.000Z" itemprop="datePublished">2022-02-13</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">课程笔记_面向对象编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"><a href="#本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。" class="headerlink" title="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"></a>本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。</h2><h1 id="抽象方法和抽象类（欧内的手方法和奥利安费类）"><a href="#抽象方法和抽象类（欧内的手方法和奥利安费类）" class="headerlink" title="抽象方法和抽象类（欧内的手方法和奥利安费类）"></a>抽象方法和抽象类（<del>欧内的手方法和奥利安费类</del>）</h1><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p><a target="_blank" rel="noopener" href="https://daniel-qi-114514.github.io/2022/02/09/%E5%A4%9A%E6%80%81/">书接上文</a></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public void cure(Pet pet)&#123;//父类作为方法的形参</span><br><span class="line">        if(pet.health&lt;50)&#123;</span><br><span class="line">          pet.cure();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pet&#123;//父类写法</span><br><span class="line">     public int health;</span><br><span class="line">     public String name;</span><br><span class="line">     public String sex;</span><br><span class="line">     public void cure()&#123;</span><br><span class="line">       //这里不要写属性的修改，因为要修改的是子类的属性（我好像在说废话x）</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Cat extends Pet&#123;//子类写法</span><br><span class="line">    public void cure()&#123;</span><br><span class="line">        System.out.println(&quot;打针&quot;);</span><br><span class="line">        this.heatlh=60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到，在上面Pet类里的cure方法内没有具体内容，而它的实现在子类里，此时我们就可以将它写成<strong>public abstract void cure();<strong>，也就是将其写成一个</strong>抽象方法</strong>。而抽象方法所在的类也要通过<strong>public abstract class Pet</strong>的改写来转变为<strong>抽象类</strong>。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当声明这个类的一个对象是没有意义的时候，就可以将这个类写为抽象类，<strong>抽象类不能被实例化</strong>。</p>
<h2 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h2><ul>
<li><strong>抽象类不能被实例化（不存在抽象构造方法），但可以创建一个抽象类的引用变量指向非抽象的子类实例</strong>。</li>
<li><strong>如果子类没有实现父类的所有抽象方法，子类必须被定义为抽象类</strong>。</li>
<li>抽象方法没有方法体</li>
<li><strong>抽象方法必须在抽象类里，而抽象类里可以没有抽象方法。</strong></li>
<li>不存在抽象静态方法</li>
<li><strong>抽象类可以有非抽象构造方法，因为构造非抽象子类实例时可能需要用到，这样可以节省代码</strong></li>
<li>抽象方法<strong>必须在子类中被实现</strong>，<strong>除非子类是抽象类</strong><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li>
<li>当子类们既有共性方法又有各自特性方法的时候，我们可以通过声明抽象方法和抽象类来简化代码、方便调用。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="我们为什么需要接口"><a href="#我们为什么需要接口" class="headerlink" title="我们为什么需要接口"></a>我们为什么需要接口</h2><p>我们知道一个类只能有一个父类，而当<strong>一个类需要继承多组相互之间不相关的方法</strong>时，这些方法都塞在一个父类里或者多个间接父类里显然不合理，因此我们需要多个<strong>接口</strong>来存放和管理各组方法。</p>
<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><ul>
<li>概念性的接口指系统对外提供的所有服务。</li>
<li><strong>interface</strong>定义的接口叫<strong>接口类型</strong>,<strong>但是接口不是类</strong></li>
<li>JDK8之前的接口特性<ul>
<li>接口中的变量默认都是静态常量，必须显式初始化</li>
<li>接口中所有方法默认都是抽象方法</li>
<li>接口没有构造方法，不可以被实例化，但可以被实现</li>
<li>通过<strong>implements</strong>关键字声明实现类，一个实现类可以实现多个接口</li>
<li>实现类必须实现接口的所有方法，<strong>除非实现类也是一个抽象类</strong></li>
</ul>
</li>
<li>JDK8新增接口特性1：<strong>接口内可以有默认方法</strong>了<ul>
<li>通过<strong>default</strong>关键字来声明默认方法，<strong>默认方法的用处在于简化代码，降低实现类和接口的耦合度，提升代码可维护性</strong></li>
<li>默认方法可以被继承，通过实例调用</li>
<li>如果一个类实现了多个接口，多个接口都定义了多个同样的默认方法<ul>
<li>实现方案1：实现类需要覆盖重写接口中的默认方法不然会报错</li>
<li>实现方案2：可以使用this来调用指定接口的默认方法</li>
</ul>
</li>
<li>如果一个类继承了一个抽象类，实现了一个接口，抽象类和接口存在相同的方法<ul>
<li>采取类优先的原则，有限继承抽象类的方法</li>
</ul>
</li>
</ul>
</li>
<li>JDK8新增接口特性2：**接口内可以声明（并且可以提供实现）静态方法了<ul>
<li>回顾：静态方法可以直接用类名调用（不用专门new一个对象了）</li>
<li>接口中的静态方法必须是public的，public修饰符可以省略，static修饰符不能省略</li>
<li>静态方法不能被继承及重写，所以只能被具体所在的接口调用</li>
<li>接口中可以有多个静态方法。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">/*接口格式</span><br><span class="line">访问修饰符 interface 接口名称 extends 其他接口名（如果有的话）&#123;</span><br><span class="line">    声明变量</span><br><span class="line">    声明方法</span><br><span class="line">&#125;*/</span><br><span class="line">//接口示例</span><br><span class="line">public interface Interface1&#123;</span><br><span class="line">     public static final double PI =3.14;//在接口里，你写个double PI =3.14 也等同于左边的写法</span><br><span class="line">     public void m2();//等同于 public abstract void m2();</span><br><span class="line">     default void m3()&#123;</span><br><span class="line">         System.out.println(&quot;已调用接口Interface1中的默认方法m3&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">//实现类示例</span><br><span class="line">public class Implementation implements Interface1&#123;//多个接口间用逗号隔开</span><br><span class="line">     public void m2()&#123;</span><br><span class="line">         System.out.println(&quot;实现用接口Interface1中的默认方法m2&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     public void usem3()&#123;</span><br><span class="line">         this.m3();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类和接口的比较"><a href="#抽象类和接口的比较" class="headerlink" title="抽象类和接口的比较"></a>抽象类和接口的比较</h2><ul>
<li>相同点<ul>
<li>代表系统的抽象层</li>
<li>都不能被实例化</li>
<li>都能包含抽象方法</li>
</ul>
</li>
<li>不同点<ul>
<li>在抽象类中可以为部分普通方法提供默认实现，而接口在JDK8之前只能包含抽象方法，JDK8之后接口可包含默认方法</li>
<li> 一个类只能继承一个直接的父类，但可以实现多个接口</li>
</ul>
</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8A%BD%E8%B1%A1%E7%B1%BB/" rel="tag">抽象类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%8E%A5%E5%8F%A3/" rel="tag">接口</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boop/" rel="tag">面向对象编程oop</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-多态"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/09/%E5%A4%9A%E6%80%81/"
    >方法重写与多态</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/09/%E5%A4%9A%E6%80%81/" class="article-date">
  <time datetime="2022-02-09T12:39:06.000Z" itemprop="datePublished">2022-02-09</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">课程笔记_面向对象编程</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"><a href="#本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。" class="headerlink" title="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"></a>本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。</h2><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><h2 id="我们为什么需要方法重写？"><a href="#我们为什么需要方法重写？" class="headerlink" title="我们为什么需要方法重写？"></a>我们为什么需要方法重写？</h2><p>有一个父类/超类叫pet，它有两个子类dog和cat，dog和cat有共同的属性名字和性别，有共同的输入和输出信息方法setInfo()和showInfo(),将这些属性和方法都写在父类里。现在有新的要求，dog增加了一个属性是品种，cat增加了一个属性是体重，这时候发现方法原来的写法不能同时满足两个子类不同属性的输出，此时我们提出三种解决方案：</p>
<ol>
<li>删除父类的方法，在子类内分别写方法并调用：这种方法简单粗暴，但是一旦像这样的同时具有相同和不同属性与方法的子类增多，会使得代码有很多重复的部分，增大了工作量。</li>
<li>保留父类的方法，同时将不同的部分分别写入子类专属的方法内：这种方法较上一种的工作量减少了，但是在调用的时候会变得麻烦，既然都是输入输出信息的功能，为什么不让它们名称相同呢？</li>
<li>子类<strong>重写</strong>父类方法：<ul>
<li>子类根据需求对从父类继承的方法进行重新编写</li>
<li>重写时，可以用super.方法的方式保留父类的方法</li>
<li><strong>构造方法不能被重写</strong></li>
</ul>
</li>
</ol>
<h2 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h2><ul>
<li><strong>方法名相同</strong></li>
<li><strong>参数列表相同</strong></li>
<li><strong>返回值类型相同或是其子类</strong></li>
<li><strong>访问权限不能严于父类</strong></li>
<li><strong>父类的私有方法不能被子类覆盖</strong></li>
<li><strong>子类方法不能抛出比父类方法更多的异常</strong></li>
<li><strong>父类的静态方法不能被子类覆盖为非静态方法，父类的非静态方法也不能被子类覆盖为静态方法</strong></li>
<li>由于super不能在静态方法中使用，因此子类可以定义与父类同名的静态方法，以便在子类中隐藏父类的静态方法</li>
</ul>
<h2 id="代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）"><a href="#代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）" class="headerlink" title="代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）"></a>代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（<del>说什么我都开摆！</del>）</h2><h3 id="父类写法"><a href="#父类写法" class="headerlink" title="父类写法"></a>父类写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Pet &#123;//父类</span><br><span class="line">    //按照方法1的写法，这里可以啥都没有x</span><br><span class="line">    public String name;//方法2中这里要保留</span><br><span class="line">    public String sex;</span><br><span class="line">    //方法3写法（方法2中父类的写法和方法3一致，故略）</span><br><span class="line">    public void setInfo(String name, String sex)&#123;</span><br><span class="line">    	this.name=name;</span><br><span class="line">    	this.sex=sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showInfo()&#123;</span><br><span class="line">    	System.out.println(&quot;宠物的名字是：&quot;+name+&quot;，宠物的性别是：&quot;+sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="子类写法"><a href="#子类写法" class="headerlink" title="子类写法"></a>子类写法</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public class Cat extends Pet&#123;//子类</span><br><span class="line">    private float weight;//体重</span><br><span class="line">    private String name;//名字</span><br><span class="line">    private String sex;//性别</span><br><span class="line">    /*方法1写法</span><br><span class="line">     public void setInfo(String name,String sex, float weight)&#123;</span><br><span class="line">    	 this.name = name;//这里实际上略写了name和sex的声明，这两个属性的声明可以在父类中以public关键字做保留，也可以在子类中写</span><br><span class="line">    	 this.sex = sex;</span><br><span class="line">    	 this.weight = weight;</span><br><span class="line">     &#125;</span><br><span class="line">     public void showInfo()&#123;</span><br><span class="line">    	 System.out.println(&quot;宠物的名字是：&quot;+name+&quot;，宠物的性别是：&quot;+sex+&quot;，猫的体重是&quot;+weight);</span><br><span class="line">     &#125;</span><br><span class="line">     */</span><br><span class="line">    /*方法2写法</span><br><span class="line">     public void setInfo(String name,String sex, float weight)&#123;</span><br><span class="line">    	 this.name = name;</span><br><span class="line">    	 this.sex = sex;</span><br><span class="line">    	 this.weight = weight;</span><br><span class="line">     &#125;</span><br><span class="line">     public void showCatInfo()&#123;//注意此处的改名</span><br><span class="line">         showInfo();</span><br><span class="line">    	 System.out.println(&quot;猫的体重是&quot;+weight);</span><br><span class="line">     &#125;</span><br><span class="line">     */</span><br><span class="line">    //方法3写法</span><br><span class="line"></span><br><span class="line">    public void showInfo()&#123;</span><br><span class="line">    	super.showInfo();</span><br><span class="line">        System.out.println(&quot;猫的体重是&quot;+weight+&quot;kg&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><ul>
<li>super可以用来访问父类的<strong>非私有（private）成员</strong></li>
<li><strong>静态方法中不能出现super</strong></li>
<li>当子类中定义了和父类同名的成员时，super可以使被屏蔽的成员可见</li>
<li>super只能出现在<strong>子类的方法和构造方法中</strong></li>
<li>super调用父类构造方法时，只能是super所在方法的第一句</li>
<li>super可以用于调用<strong>继承关系中最近</strong>的父类/间接父类的成员<ul>
<li>当子类、父类、间接父类中都有同名的成员时（子类重写/覆盖父类，父类重写/覆盖间接父类）时，子类中使用super只能访问父类的成员。</li>
<li>当子类和间接父类中有同名成员时，子类中使用super可以访问<strong>继承关系中最近</strong>的间接父类成员。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//访问父类方法</span><br><span class="line">super.print();</span><br><span class="line">//访问父类属性</span><br><span class="line">super.name;</span><br><span class="line">//访问父类构造方法</span><br><span class="line">super();</span><br><span class="line">super(name)</span><br></pre></td></tr></table></figure>
<h3 id="super和this比较"><a href="#super和this比较" class="headerlink" title="super和this比较"></a>super和this比较</h3><table>
<thead>
<tr>
<th>区别</th>
<th align="center">this</th>
<th align="right">super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td align="center">访问<strong>本类</strong>属性，如果没有则从父类找</td>
<td align="right">访问<strong>父类</strong>属性</td>
</tr>
<tr>
<td>访问普通方法</td>
<td align="center">访问<strong>本类</strong>普通方法，如果没有则从父类找</td>
<td align="right">访问<strong>父类</strong>普通方法</td>
</tr>
<tr>
<td>访问构造方法</td>
<td align="center">调用<strong>本类</strong>构造，放在构造方法首行</td>
<td align="right">调用<strong>父类</strong>构造，放在子类构造方法首行</td>
</tr>
</tbody></table>
<h3 id="继承条件下的构造方法"><a href="#继承条件下的构造方法" class="headerlink" title="继承条件下的构造方法"></a>继承条件下的构造方法</h3><ul>
<li>当子类构造方法没有通过super显式调用父类的<strong>带参</strong>构造方法，也没有通过this显式调用自身其他构造方法时，系统默认调用父类的<strong>无参构造方法</strong></li>
<li>相对的，当子类构造方法通过super显式调用父类的<strong>带参构造方法</strong>时，系统执行父类的带参构造方法而不执行父类的<strong>无参构造方法</strong></li>
<li>子类构造方法通过this显式调用自身的其他构造方法，在相应构造方法中应用上述两条规则</li>
<li><strong>注意，子类的构造方法在执行时，无论是否有显式给出，父类的构造方法在逻辑顺序上永远是第一个执行的</strong></li>
</ul>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="Object类是什么？"><a href="#Object类是什么？" class="headerlink" title="Object类是什么？"></a>Object类是什么？</h2><ul>
<li><strong>Object类是所有类的直接或间接父类</strong>，而且是继承关系<strong>最远</strong>的那个直接或间接父类<h2 id="Object类有什么？"><a href="#Object类有什么？" class="headerlink" title="Object类有什么？"></a>Object类有什么？</h2></li>
<li><strong>自己找个IDE（比如myeclipse），新建类然后写个this，Object类里的东西就在提示弹窗里显示出来了</strong></li>
<li>Object类被子类经常重写的方法<ul>
<li><strong>toString()</strong>: 返回当前对象本身的有关信息，按字符串对象返回</li>
<li><strong>equals()</strong>: 比较两个对象是否是同一个对象，是则返回true</li>
<li><strong>hashCode()</strong>: 返回该对象的哈希值</li>
<li><strong>getClass()</strong>: 获取当前对象所属的类信息，返回Class对象</li>
</ul>
</li>
</ul>
<p><strong>此处的小补充</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//equals函数判断是否是一个对象的依据是看两个对象是否占用同一处内存</span><br><span class="line">//这里假设有一个Student类</span><br><span class="line">Student s1 = new Student();</span><br><span class="line">Student s2 = new Student();</span><br><span class="line">Student s3 = s1;</span><br><span class="line">System.out.println(s1.equals(s3));//结果为true</span><br><span class="line">System.out.println(s1.equals(s2));//结果为false，因为二者成员虽然一样，但在不占用同一处内存。</span><br></pre></td></tr></table></figure>
<h2 id="重写Object类的方法（此处以重写equals方法为例）"><a href="#重写Object类的方法（此处以重写equals方法为例）" class="headerlink" title="重写Object类的方法（此处以重写equals方法为例）"></a>重写Object类的方法（此处以重写equals方法为例）</h2><p>我们接着上面的问题来，如果两个学生类的所有属性都一样，按理说它们指的就是一个人，但按照equals()的原理却不能认为两个对象相同，即当<strong>认为属性相同就是同一对象</strong>时，就有了重写equals()的需要。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//如果两个学生的属性（此处为姓名name和学号sid）相同，就认为是同一个学生对象。</span><br><span class="line">public boolean equals(Object obj)&#123;//注意，此处是Student的equals方法。</span><br><span class="line">    //如果占用的是同一处内存</span><br><span class="line">    if(this == obj)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //此处应用instanceof运算符，“对象a instanceof 类型b”的意思是判断a是否为b的实例</span><br><span class="line">    elif(!(obj instance of Student))&#123;//如果对象不是Student类型</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Student s = (Student)Obj;//将Obj强制转换为student类型，这里实际上也可以省去这一步，但是这样更保险一些。</span><br><span class="line">    if (this.name==s.name&amp;&amp;this.sid==s.sid)//这里判断name是否相同还有一种写法就是“this.name.equals(s.name)”，由此可见Java.lang.String已经重写过一遍equals方法，使其可以用于判断字符串是否相同。</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="我们为什么需要多态？"><a href="#我们为什么需要多态？" class="headerlink" title="我们为什么需要多态？"></a>我们为什么需要多态？</h2><p>接着上面说过的dog、cat和pet类继续讲，现在我们设定pet类增加了健康值health这个属性，当健康值小于50时，认定宠物生病了，需要治疗，我们将治疗方法cure()放在新建的主人类master里，治疗方法的内容是显示治疗方案和修改宠物实例的health值为60。而不同的宠物需要不同的治疗方式，我们设定治疗猫时需要显示“打针”，治疗狗时需要显示“吃药”。我们可以使用<strong>方法重载</strong>来实现，主人类的代码此时如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class Master&#123;</span><br><span class="line">    public void cure(Cat cat)&#123;</span><br><span class="line">        if(cat.health&lt;50)&#123;</span><br><span class="line">         System.out.println(&quot;打针&quot;);</span><br><span class="line">         cat.health=60;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    public void cure(Dog dog)&#123;</span><br><span class="line">        if(dog.health&lt;50)&#123;</span><br><span class="line">         System.out.println(&quot;吃药&quot;);</span><br><span class="line">         dog.health=60</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但当宠物的种类变多时，这种写法会需要频繁修改，更不用说如果不止是主人类需要有这个cure方法，<strong>还有其他和主人类类似的类需要有这个cure方法时</strong>，就会导致代码<strong>臃肿、可扩展性、可维护性差</strong>，因此我们需要多态来优化。</p>
<h2 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h2><p>多态：<strong>同一个引用类型，使用不同的实例而执行不同的操作</strong><br><strong>使用父类作为方法的形参，是Java中实现和使用多态的主要方式。</strong><br><strong>使用父类作为方法的返回值，也是Java中实现和使用多态的主要方式。</strong><br>我们接着来看刚才的例子。我们的优化思路是将治疗方法cure移到父类pet内，pet的各个子类重写父类的pet方法，此时主人类、父类、子类的代码简化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public void cure(Pet pet)&#123;//父类作为方法的形参</span><br><span class="line">        if(pet.health&lt;50)&#123;</span><br><span class="line">          pet.cure();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pet&#123;//父类写法</span><br><span class="line">     public int health;</span><br><span class="line">     public String name;</span><br><span class="line">     public String sex;</span><br><span class="line">     public void cure()&#123;</span><br><span class="line">       //这里不要写属性的修改，因为修改的是子类的属性（我好像在说废话x）</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Cat extends Pet&#123;//子类写法</span><br><span class="line">    public void cure()&#123;</span><br><span class="line">        System.out.println(&quot;打针&quot;);</span><br><span class="line">        this.heatlh=60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里附上一个<strong>父类作为方法的返回值</strong>的多态用法，假设我们要送动物给别人。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public Pet sendPet(int type)&#123;//以父类作为返回对象，也是多态的一种用法</span><br><span class="line">        Pet pet = null;</span><br><span class="line">        switch(type)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                 Pet pet=new Cat();</span><br><span class="line">                 break;</span><br><span class="line">            case 2:</span><br><span class="line">                 Pet pet=new Dog();</span><br><span class="line">                 break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;私密马赛！没有这种宠物&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return pet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，这时你再构建对象，你就得写成<strong>Pet xx = new Xx()<strong>，即</strong>向上转型</strong>这里和以前的写法规定不一样了。而当master的cure函数收到Pet类型的对象时，系统会<strong>找到这个对象指向的具体的类型Xx</strong>,也就是实际上在调用时将其<strong>视作Xx类型的对象</strong>。</p>
<h3 id="关于向上（向下）转型"><a href="#关于向上（向下）转型" class="headerlink" title="关于向上（向下）转型"></a>关于向上（向下）转型</h3><p>上文中我们把<strong>父类类型引用变量指向子类对象，自动进行类型转换</strong>的写法称为<strong>向上转型</strong>，自然地，我们也将<strong>父类类型引用变量强制转换为子类类型引用变量</strong>的写法称为<strong>向下转型</strong>。</p>
<h4 id="我们为什么需要转型"><a href="#我们为什么需要转型" class="headerlink" title="我们为什么需要转型"></a>我们为什么需要转型</h4><p>当我们需要以多态写法（我个人将多态理解成一种写法）去简化调用这些子类的方法时，我们需要将参数表里传入的类型向上转型成子类共同继承的父类类型来使方法在具备简洁的方法体的同时可以<strong>灵活调用各个子类重写的父类方法</strong>，而当我们需要调用子类的<strong>特有方法</strong>时，由于<strong>父类对象不能调用子类特有的方法</strong>就需要将其强制转换回子类，即向下转型，从而实现调用。</p>
<h4 id="转型需要注意的地方"><a href="#转型需要注意的地方" class="headerlink" title="转型需要注意的地方"></a>转型需要注意的地方</h4><ul>
<li><strong>向上转型后只能调用子类覆盖或继承父类的方法，不能调用子类特有的方法</strong></li>
<li>在向下转型的过程中<strong>如果没有转换成真实子类类型，会出现类型转换异常</strong>，来看下面的代码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test()&#123;//测试类</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        Pet dog = new Dog();//先来个向上转型</span><br><span class="line">        Cat cat = (Cat) dog;//再来个向下转型</span><br><span class="line">        cat.meow();//让猫（实际上是“变成猫”的狗）调用喵喵叫方法（狗肯定不会喵喵叫啊所以是猫的特有方法）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码在写的时候IDE不会给你报错，也就是没有语法问题。但当你编译它的时候，IDE会告诉你存在编译错误（至少我的Myeclipse是这样）<strong>java.lang.ClassCastException:Dog cannot be cast to Cat</strong>（<strong>类型转换异常</strong>：狗变不成猫！），所以注意，向下转型时如果没有转化为真实的子类类型，会触发类型转换异常。<br>如果想要避免类型转换异常的出现，我们可以借助<strong>instanceof</strong>来进行辅助判断，来看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class Test()&#123;//测试类</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        Pet dog = new Dog();//先来个向上转型</span><br><span class="line">        if (dog instanceof Dog)&#123;</span><br><span class="line">            dog.bark();//汪汪汪</span><br><span class="line">        &#125;</span><br><span class="line">        elif(dog instanceof Cat)&#123;</span><br><span class="line">            cat.meow();//喵喵喵</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>，使用instanceof时，对象的类型必须和instanceof后面的类<strong>在继承上有上下级关系</strong></li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Java/" rel="tag">Java</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Object%E7%B1%BB/" rel="tag">Object类</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/instanceof/" rel="tag">instanceof</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/super/" rel="tag">super</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%A4%9A%E6%80%81/" rel="tag">多态</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99/" rel="tag">方法重写</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8Boop/" rel="tag">面向对象编程oop</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Daniel Qi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.svg" alt="Welcome to DanielQi&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/photos/">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/1.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/2.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=139774&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>
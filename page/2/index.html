<!DOCTYPE html>


<html lang="en">
  

    <head>
      <meta charset="utf-8" />
        
      <meta
        name="viewport"
        content="width=device-width, initial-scale=1, maximum-scale=1"
      />
      <title> Welcome to DanielQi&#39;s Blog</title>
  <meta name="generator" content="hexo-theme-ayer">
      
      <link rel="shortcut icon" href="/favicon.ico" />
       
<link rel="stylesheet" href="/dist/main.css">

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/Shen-Yu/cdn/css/remixicon.min.css"
      />
      
<link rel="stylesheet" href="/css/custom.css">
 
      <script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script>
       
 

      <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@sweetalert2/theme-bulma@5.0.1/bulma.min.css"
      />
      <script src="https://cdn.jsdelivr.net/npm/sweetalert2@11.0.19/dist/sweetalert2.min.js"></script>

      <!-- mermaid -->
      
      <script src="https://mermaid-js.github.io/mermaid/"></script>
      
      <style>
        .swal2-styled.swal2-confirm {
          font-size: 1.6rem;
        }
      </style>
    </head>
  </html>
</html>


<body>
  <div id="app">
    
      
    <main class="content on">
      
<section class="cover">
    
  <div class="cover-frame">
    <div class="bg-box">
      <img src="/images/cover6.jpg" alt="image frame" />
    </div>
    <div class="cover-inner text-center text-white">
      <h1><a href="/">Welcome to DanielQi&#39;s Blog</a></h1>
      <div id="subtitle-box">
        
        <span id="subtitle"></span>
        
      </div>
      <div>
        
      </div>
    </div>
  </div>
  <div class="cover-learn-more">
    <a href="javascript:void(0)" class="anchor"><i class="ri-arrow-down-line"></i></a>
  </div>
</section>



<script src="https://cdn.jsdelivr.net/npm/typed.js@2.0.11/lib/typed.min.js"></script>


<!-- Subtitle -->

  <script>
    try {
      var typed = new Typed("#subtitle", {
        strings: ['from import to export', 'from asking to serving', 'from idea to reality'],
        startDelay: 0,
        typeSpeed: 200,
        loop: true,
        backSpeed: 100,
        showCursor: true
      });
    } catch (err) {
      console.log(err)
    }
  </script>
  
<div id="main">
  <section class="outer">
  
  
  
<div class="notice" style="margin-top:50px">
    <i class="ri-heart-fill"></i>
    <div class="notice-content">一个安静优雅的hexo主题，拥有轻量化页面。</div>
</div>


<style>
    .notice {
        padding: 20px;
        border: 1px dashed #e6e6e6;
        color: #969696;
        position: relative;
        display: inline-block;
        width: 100%;
        background: #fbfbfb50;
        border-radius: 10px;
    }

    .notice i {
        float: left;
        color: #999;
        font-size: 16px;
        padding-right: 10px;
        vertical-align: middle;
        margin-top: -2px;
    }

    .notice-content {
        display: initial;
        vertical-align: middle;
    }
</style>
  
  <article class="articles">
    
    
    
    
    <article
  id="post-数据库原理笔记3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B03/"
    >数据库原理笔记3</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B03/" class="article-date">
  <time datetime="2022-03-24T14:40:43.000Z" itemprop="datePublished">2022-03-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">课程笔记_数据库原理</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="依照学校教学安排，第三章为数据库操作SQL语言"><a href="#依照学校教学安排，第三章为数据库操作SQL语言" class="headerlink" title="依照学校教学安排，第三章为数据库操作SQL语言"></a>依照学校教学安排，第三章为数据库操作SQL语言</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="3-1-SQL语言概述"><a href="#3-1-SQL语言概述" class="headerlink" title="3.1 SQL语言概述"></a>3.1 SQL语言概述</h1><h2 id="3-1-1-SQL简介"><a href="#3-1-1-SQL简介" class="headerlink" title="3.1.1 SQL简介"></a>3.1.1 SQL简介</h2><p>结构化查询语言SQL是一种对关系数据库进行访问的数据操作语言，于上世纪70年代由SEQUEL语言演变而来。当下主流关系型数据库管理系统均支持SQL标准语言实现数据库操作。<br>SQL的语言特点：</p>
<ul>
<li>一体化：SQL语言命令集可以完成关系数据库的数据查询、数据定义、数据操纵、数据库管理、数据库控制等操作。</li>
<li>使用方式灵活：既可以以交互命令方式操作访问数据库，也可以嵌入到程序语言中编程访问数据库。</li>
<li>非过程化：SQL对数据库的操作只需告诉DBMS做什么而不需要告诉它怎么做。</li>
<li>语言语法简单：语句少且简洁。</li>
</ul>
<h2 id="3-1-2-SQL对关系数据库的操作原理"><a href="#3-1-2-SQL对关系数据库的操作原理" class="headerlink" title="3.1.2 SQL对关系数据库的操作原理"></a>3.1.2 SQL对关系数据库的操作原理</h2><p>用户（数据库应用程序）对关系数据库进行任何操作，都需要将SQL语句提交给DBMS执行，DBMS执行时将SQL语句转为对数据库文件的输入输出操作，并将读取的数据组装为<strong>操作结果集</strong>返回给用户（数据库应用程序）<br>SQL主要操作功能：</p>
<ul>
<li>数据库对象创建、修改、删除</li>
<li>数据库表的数据插入、修改、删除、查询、统计</li>
<li>存储过程、触发器、函数等程序执行</li>
<li>数据库权限、角色、用户等管理</li>
</ul>
<h2 id="3-1-3-SQL语言语句类型"><a href="#3-1-3-SQL语言语句类型" class="headerlink" title="3.1.3 SQL语言语句类型"></a>3.1.3 SQL语言语句类型</h2><ul>
<li>数据定义语句DDL：是SQL语言中用于创建、修改或删除数据库对象的语句，DDL不但可以用于数据库对象的管理，也可以定义数据库对象约束<ul>
<li>CREATE DATABASE - 创建新数据库 </li>
<li>DROP DATABASE - 删除数据库</li>
<li>ALTER DATABASE - 修改数据库属性</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 修改数据库表结构</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引</li>
<li>DROP INDEX - 删除索引</li>
</ul>
</li>
<li>数据操纵语句DML：是SQL语言中用于增加、修改、删除的语句<ul>
<li>INSERT - 向数据库表中插入语句</li>
<li>UPDATE - 更新数据库表中的数据</li>
<li>DELETE - 从数据库表中删除数据</li>
</ul>
</li>
<li>数据查询语句DQL：是SQL语言中用于对数据库进行数据查询的语句<ul>
<li>SELECT - 对表的内容进行查询</li>
<li>DESC - 查看关系表结构</li>
</ul>
</li>
<li>数据控制语句DCL：是SQL语言中用于对数据库对象访问权进行控制的语句<ul>
<li>GRANT - 授予用户对数据库对象的权限</li>
<li>DENY - 拒绝授予用户对数据库对象的权限</li>
<li>REVOKE - 撤销用户对数据库对象的权限</li>
</ul>
</li>
<li>事务处理语句TPL：是SQL语言中用于数据库内部事务处理的语句<ul>
<li>BEGIN TRANSACTION - 开始事务</li>
<li>COMMIT - 提交事务</li>
<li>ROLLBACK - 回滚事务</li>
</ul>
</li>
<li>游标控制语言CCL：是SQL语言中用于数据库游标操作的语句，游标是是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据<ul>
<li>DECLARE CURSOR - 定义游标 </li>
<li>FETCH INTO - 提交游标数据</li>
<li>CLOSE CURSOR - 关闭游标</li>
</ul>
</li>
</ul>
<h2 id="3-1-4-SQL语言的数据类型"><a href="#3-1-4-SQL语言的数据类型" class="headerlink" title="3.1.4 SQL语言的数据类型"></a>3.1.4 SQL语言的数据类型</h2><ul>
<li>SQL语言基本数据类型<ul>
<li>字符：CHAR\VARCHAR\TEXT…</li>
<li>整数：SMALLINT\INTEGER…</li>
<li>浮点数：NUMBER\FLOAT…</li>
<li>日期：DATE\DATETIME…</li>
<li>货币：MONEY…<br><img src="../photos/DataBaseCourse/3_1.png" title="PostgreSQL主要数据类型"><br><img src="../photos/DataBaseCourse/3_2.png" title="SQL Server数据类型"><br><img src="../photos/DataBaseCourse/3_3.png" title="MySQL数据类型"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-2-数据定义SQL语句"><a href="#3-2-数据定义SQL语句" class="headerlink" title="3.2 数据定义SQL语句"></a>3.2 数据定义SQL语句</h1><h2 id="3-2-1-数据库创建SQL语句"><a href="#3-2-1-数据库创建SQL语句" class="headerlink" title="3.2.1 数据库创建SQL语句"></a>3.2.1 数据库创建SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句创建数据库</li>
</ul>
<h2 id="3-2-2-数据库、关系表修改SQL语句"><a href="#3-2-2-数据库、关系表修改SQL语句" class="headerlink" title="3.2.2 数据库、关系表修改SQL语句"></a>3.2.2 数据库、关系表修改SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//修改方式语句类型</span><br><span class="line">//ADD修改方式，用于添加新列或列完整性约束</span><br><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新列名称&gt; &lt;数据类型&gt; 完整性约束;</span><br><span class="line"></span><br><span class="line">//DROP修改方式，用于删除指定列或列的完整性约束条件</span><br><span class="line">ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;;</span><br><span class="line">ALTER TABLE &lt;表名&gt; DROP CONSTRAINT;&lt;完整性约束名&gt;;</span><br><span class="line"></span><br><span class="line">//RENAME修改方式，用于修改表名称、列名称</span><br><span class="line">ALTER TABLE &lt;表名&gt; RENAME TO &lt;新表名&gt;;</span><br><span class="line">ALTER TABLE &lt;表名&gt; RENAME &lt;原列名&gt; TO &lt;新列名&gt;;</span><br><span class="line"></span><br><span class="line">//ALTER修改方式，用于修改数据库名、表名、列的数据类型</span><br><span class="line">ALTER DATABASE &lt;数据库名&gt; &lt;修改内容&gt;;</span><br><span class="line">ALTER TABLE &lt;表名&gt; 修改方式;</span><br><span class="line">ALTER TABLE &lt;表名&gt; ALTER COLUMN &lt;列名&gt; TYPE &lt;新的数据类型&gt;;</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句修改数据库或数据库内容</li>
</ul>
<h2 id="3-2-3-数据库、关系表删除SQL语句"><a href="#3-2-3-数据库、关系表删除SQL语句" class="headerlink" title="3.2.3 数据库、关系表删除SQL语句"></a>3.2.3 数据库、关系表删除SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP DATABASE &lt;数据库名&gt;;</span><br><span class="line">DROP TABLE &lt;表名&gt;;</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句删除数据库或数据库内容</li>
</ul>
<h2 id="3-2-4-数据库表创建SQL语句"><a href="#3-2-4-数据库表创建SQL语句" class="headerlink" title="3.2.4 数据库表创建SQL语句"></a>3.2.4 数据库表创建SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;列名1&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   ...</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句创建数据库关系表</li>
</ul>
<h2 id="3-2-5-列完整性约束"><a href="#3-2-5-列完整性约束" class="headerlink" title="3.2.5 列完整性约束"></a>3.2.5 列完整性约束</h2><ul>
<li>约束类型<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">PRIMARY KEY //主键</span><br><span class="line">NOT NULL //非空值</span><br><span class="line">NULL //空值</span><br><span class="line">UNIQUE //值唯一</span><br><span class="line">CHECK //有效性检查</span><br><span class="line">DEFAULT //缺省值</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句添加列完整性约束</li>
</ul>
<h2 id="3-2-6-表约束定义主键"><a href="#3-2-6-表约束定义主键" class="headerlink" title="3.2.6 表约束定义主键"></a>3.2.6 表约束定义主键</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//PRIMARY KEY定义表的主键列只能定义单列主键，若要定义由多个列构成的复合主键，则需要使用表约束方式来定义</span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;列名1&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">...</span><br><span class="line">   CONSTRAINT &lt;约束名&gt; PRIMARY Key (主键列名1,主键列名2)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句定义主键、复合主键</li>
<li>使用表约束定义主键的优点：<ul>
<li>便于定义复合主键</li>
<li>可命名主键约束</li>
<li>便于定义代理键</li>
</ul>
</li>
</ul>
<h2 id="3-2-7-表约束定义代理键"><a href="#3-2-7-表约束定义代理键" class="headerlink" title="3.2.7 表约束定义代理键"></a>3.2.7 表约束定义代理键</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//在一些关系表中，为了方便数据处理，可以使用代理键去替代复合主键。在SQL语句中，关系表的代理键采用表约束方式来定义</span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;代理键列名&gt; &lt;Serial数据类型&gt; NOT NULL,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">...</span><br><span class="line">   CONSTRAINT &lt;约束名&gt; PRIMARY Key (代理键列名)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句定义代理键</li>
</ul>
<h2 id="3-2-8-表约束定义外键"><a href="#3-2-8-表约束定义外键" class="headerlink" title="3.2.8 表约束定义外键"></a>3.2.8 表约束定义外键</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//在数据库中，一些关系表之间存在关联，在一个表中作为主键的列，在另外的关联表中则作为外键</span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;列名1&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">...</span><br><span class="line">   CONSTRAINT &lt;约束名&gt; FOREIGN Key (外键列名)</span><br><span class="line">       REFERENCES  外键列所在表名(外键列名)</span><br><span class="line">     ON DELETE CASCADE//联级删除，如果主表中的一个列被删除了，那么应用该列的从表中的所有记录也被删除</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句定义外键</li>
</ul>
<h2 id="3-2-9-数据库索引操作语句、"><a href="#3-2-9-数据库索引操作语句、" class="headerlink" title="3.2.9 数据库索引操作语句、"></a>3.2.9 数据库索引操作语句、</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul>
<li>索引是一种按照关系表中指定列的取值顺序组织元组数据存储的数据结构，使用它可以加快表中数据的查询访问</li>
<li>在索引数据结构中，采用树结构的各个结点存储索引值及其指针，索引叶结点的指针指向数据库文件中的元组数据块地址<br><img src="../photos/DataBaseCourse/3_4.png" title="B树索引结构图"></li>
<li>索引作用及其特点<ul>
<li>索引作用：支持对数据库表中数据快速查找</li>
<li>索引优点<ul>
<li>提高数据检索速度</li>
<li>可快速连接关联表</li>
<li>减少分组和排序时间</li>
</ul>
</li>
<li>索引开销<ul>
<li>创建和维护索引都需要较大开销</li>
<li>索引会占用额外存储空间</li>
<li>数据操纵困难因维护索引带来系统性能开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库索引创建、修改、删除语句"><a href="#数据库索引创建、修改、删除语句" class="headerlink" title="数据库索引创建、修改、删除语句"></a>数据库索引创建、修改、删除语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 数据库索引创建语句</span><br><span class="line">CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; &lt;(列名)&gt;;</span><br><span class="line"></span><br><span class="line">// 数据库索引修改语句</span><br><span class="line">ALTER INDEX &lt;索引名&gt; 修改项;//具体修改语法见3.2.2</span><br><span class="line"></span><br><span class="line">// 数据库索引删除语句</span><br><span class="line">DROP INDEX &lt;索引名&gt;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-3-数据操纵SQL语句"><a href="#3-3-数据操纵SQL语句" class="headerlink" title="3.3 数据操纵SQL语句"></a>3.3 数据操纵SQL语句</h1><h2 id="3-3-1-数据插入SQL语句"><a href="#3-3-1-数据插入SQL语句" class="headerlink" title="3.3.1 数据插入SQL语句"></a>3.3.1 数据插入SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">//插入一个元组语法如下，插入几个元组就写几行</span><br><span class="line">INSERT INTO 表名或视图名    如果元组只有个别列有数据，这里可以再写一个列名表表示要给哪几个列赋值，不写的话缺省值默认为NULL并自动补全 VALUES (该元组的所有数据从左到右排列，之间用逗号隔开);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-2-数据修改SQL语句"><a href="#3-3-2-数据修改SQL语句" class="headerlink" title="3.3.2 数据修改SQL语句"></a>3.3.2 数据修改SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">UPDATE 表名或视图名 //UPDATE关键字指定修改的是哪个表或视图</span><br><span class="line">SET 列名1=新数据 //SET关键字指定对哪些列设定新值，注意字符串要给单引号</span><br><span class="line">WHERE 条件表达式;//WHERE关键字给出修改的前提条件，比如需要指定行用到的 xxx=xxx</span><br><span class="line">//看不懂的见下图</span><br></pre></td></tr></table></figure>
<img src="../photos/DataBaseCourse/3_5.png" title="数据更新实例"></li>
</ul>
<h2 id="3-3-3-数据删除SQL语句"><a href="#3-3-3-数据删除SQL语句" class="headerlink" title="3.3.3 数据删除SQL语句"></a>3.3.3 数据删除SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//一次删除一个元组，删几个元组写几遍</span><br><span class="line">DELETE</span><br><span class="line">FROM 表名或视图名</span><br><span class="line">WHERE 条件表达式</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="3-4-数据查询SQL语句"><a href="#3-4-数据查询SQL语句" class="headerlink" title="3.4 数据查询SQL语句"></a>3.4 数据查询SQL语句</h1><h2 id="3-4-1-单表数据查询"><a href="#3-4-1-单表数据查询" class="headerlink" title="3.4.1 单表数据查询"></a>3.4.1 单表数据查询</h2><h3 id="数据查询SQL语句格式"><a href="#数据查询SQL语句格式" class="headerlink" title="数据查询SQL语句格式"></a>数据查询SQL语句格式</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SELECT ALL或DISTINCT 目标列 //选ALL就是有啥输出啥，有DISTINCT就是去掉重复的数据行，如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">INTO 新表</span><br><span class="line">FROM 表名或视图名 //多个表名或视图名可以用逗号隔开，往后续</span><br><span class="line">//如果是条件查询 就写 &quot;WHERE 条件表达式&quot;</span><br><span class="line">//如果是分组统计查询就写 &quot;GROUP BY 列名&quot;,如果有条件接着写 &quot;HAVING 条件表达式&quot;</span><br><span class="line">//如果查询结果需要排序输出就写 &quot;ORDER BY 列名&quot;这个子句要放在WHERE后面（如果有的话）,如果接着写&quot;ASC或DESC&quot;, ASC是升序排列，DESC是降序排列</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="从单个表读取指定列"><a href="#从单个表读取指定列" class="headerlink" title="从单个表读取指定列"></a>从单个表读取指定列</h3><p>在关系数据库中，最简单的数据查询操作就是从单个关系表中读取指定列的数据，即关系的投影操作 <em>（说白了就是把列拎出来组成结果集）</em></p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT 目标列//如果有多个目标列可以用逗号隔开，接着往后续，如果要查询所有列数据，就写个 *</span><br><span class="line">FROM 关系表名;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="从单个表读取指定行"><a href="#从单个表读取指定行" class="headerlink" title="从单个表读取指定行"></a>从单个表读取指定行</h3><p>SQL查询语句也可以从一个关系表中读取满足条件的指定行数据，即完成关系数据的元组选择操作</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 关系表</span><br><span class="line">WHERE 条件表达式;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="从单个表读取指定行和列"><a href="#从单个表读取指定行和列" class="headerlink" title="从单个表读取指定行和列"></a>从单个表读取指定行和列</h3><p>在SQL查询语句中，还可以从一个关系表中读取指定行与指定列范围内的数据。既完成关系的行选择，又完成关系的列投影操作。</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SELECT 目标列//如果有多个目标列可以用逗号隔开，接着往后续，如果要查询所有列数据，就写个 *</span><br><span class="line">FROM 关系表</span><br><span class="line">WHERE 条件表达式;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="WHERE条件子句"><a href="#WHERE条件子句" class="headerlink" title="WHERE条件子句"></a>WHERE条件子句</h3><p>使用WHERE子句中可以使用如下方式，指定范围数据</p>
<ul>
<li>使用<strong>BETWEEN…AND</strong>关键词来限定列值范围，还可以使用关键词LIKE与通配符来限定查询条件</li>
<li>使用通配符来限定字符串数据范围。_通配符用于代表一个未指定的字符，%通配符用于代表一个或多个未指定的字符<br>在SQL查询WHERE子句中，还可以使用多个条件表达式，并通过逻辑运算符AND\OR\NOT连接操作，以及使用IN\NOT IN关键词，进一步限定结果集的数据范围</li>
</ul>
<h3 id="对结果集进行排序"><a href="#对结果集进行排序" class="headerlink" title="对结果集进行排序"></a>对结果集进行排序</h3><p>在SELECT查询语句返回的结果集中，行的顺序是任意的。如果需要结果集排序，可以在SELECT语句中加入ORDER BY 关键字<br>在ORDER子句中可以使用ASC和DESC指定排序是升序还是降序，也可以ASC和DESC搭配使用，若要先按某列数据升序\降序排列元组，再对其中数据相同的元组以别的列的数据升序\降序排列元组，则在ORDER BY后的这几个列之间用逗号隔开。</p>
<h2 id="3-4-2-内置函数与分组统计"><a href="#3-4-2-内置函数与分组统计" class="headerlink" title="3.4.2 内置函数与分组统计"></a>3.4.2 内置函数与分组统计</h2><h3 id="SQL内置函数类型"><a href="#SQL内置函数类型" class="headerlink" title="SQL内置函数类型"></a>SQL内置函数类型</h3><p>SQL语言提供了大量内置函数，支持对SELECT查询结果数据进行处理<br>典型SQL内置函数类型如下：</p>
<ul>
<li>聚合函数</li>
<li>算术函数</li>
<li>字符串函数</li>
<li>日期时间函数</li>
<li>数据类型转换函数</li>
</ul>
<h3 id="SQL聚合函数"><a href="#SQL聚合函数" class="headerlink" title="SQL聚合函数"></a>SQL聚合函数</h3><p>聚合函数是一些对关系表中数值属性列进行计算并以表的形式返回查询结果的函数<br>AVG() 计算结果集指定列数据的平均值<br>COUNT() 计算结果集行数<br>MIN() 找出结果集指定列数据的最小值<br>MAX() 找出结果集指定列数据的最大值<br>SUM() 计算结果集指定列数据的总和</p>
<h3 id="SQL内置函数与分组统计"><a href="#SQL内置函数与分组统计" class="headerlink" title="SQL内置函数与分组统计"></a>SQL内置函数与分组统计</h3><p>在SQL语言中，可使用内置函数对查询结果集进行分组数据统计。这是通过在SELECT语句中加入Group By子语句来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">//分组统计SQL语句基本格式：</span><br><span class="line">SELECT 统计函数/目标列</span><br><span class="line">FROM 表名</span><br><span class="line">//如果需要添加条件就写&quot;WHERE 条件表达式&quot;</span><br><span class="line">GROUP BY 目标列</span><br><span class="line">//HAVING字句 是对GROUP BY的结果进行限制，如要添加，则写&quot;HAVING 条件表达式&quot;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-3-多表关联查询"><a href="#3-4-3-多表关联查询" class="headerlink" title="3.4.3 多表关联查询"></a>3.4.3 多表关联查询</h2><h3 id="子查询与多表关联"><a href="#子查询与多表关联" class="headerlink" title="子查询与多表关联"></a>子查询与多表关联</h3><p>在实际应用中，通常需要关联多表才能获得所需的信息。在SELECT查询语句中，可使用子查询方式实现多表关联查询。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//子查询SQL语句基本格式：</span><br><span class="line">SELECT 目标列 //如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件中嵌套另一关系表的SELECT查询结果集</span><br><span class="line">;</span><br><span class="line">//例子见下表</span><br></pre></td></tr></table></figure>
<p><img src="../photos/DataBaseCourse/3_6.png" title="子查询示例"></p>
<h3 id="使用连接关联多表查询"><a href="#使用连接关联多表查询" class="headerlink" title="使用连接关联多表查询"></a>使用连接关联多表查询</h3><p>在使用多个表查询时，子查询只有在结果数据均来自一个表的情况下才有用。但如果需要从两个或多个表中获取结果数据，就不能使用子查询，而需要采用连接关联多表查询</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//关联多表查询SQL语句基本格式：</span><br><span class="line">SELECT 目标列 //如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">FROM 表名  //如果数据来自多个表可以用逗号隔开，接着往后续</span><br><span class="line">WHERE 关系表之间的连接关联条件</span><br><span class="line">;</span><br><span class="line">//例子见下表</span><br></pre></td></tr></table></figure>
<p><img src="../photos/DataBaseCourse/3_7.png" title="关联多表查询示例"></p>
<h3 id="SQL-JOIN…ON连接查询语句"><a href="#SQL-JOIN…ON连接查询语句" class="headerlink" title="SQL JOIN…ON连接查询语句"></a>SQL JOIN…ON连接查询语句</h3><p>在SQL语言中，实现多表连接关联查询还可以使用JOIN…ON关键词的语句格式。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//两表连接关联查询的JOIN...ON语句格式：</span><br><span class="line">SELECT 目标列 //如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">FROM 表名1 JOIN 表名2 ON 连接条件</span><br><span class="line">//有具体排序需要可以添加ORDER BY子句;</span><br><span class="line">//例子见下表</span><br></pre></td></tr></table></figure>
<p><img src="../photos/DataBaseCourse/3_8.png" title="使用JOIN...ON语句进行关联多表查询示例"></p>
<h3 id="外部连接"><a href="#外部连接" class="headerlink" title="外部连接"></a>外部连接</h3><p>在一些特殊情况下，如关联表中的一些行的主键与外键不匹配（比如某个属性作为主键时的行数和在其它表中做外键时的行数不同），查询结果集就会丢失部分数据，此时就不能找出在某表中存在但在其它表没有的元组。在SQL应用中，有时候也希望输出那些不满足连接条件的元组数据。此时，可使用JOIN…ON外连接方式实现。其实现方式有三种形式，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//搭配2.2.5食用风味更佳</span><br><span class="line">LEFT JOIN //即使没有与右表关联列值匹配，也从左表返回所有的行</span><br><span class="line">RIGHT JOIN //即使没有与左表关联列值匹配，也从右表返回所有的行</span><br><span class="line">FULL JOIN //全外连接，同时进行左连接和右连接，返回所有行</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-5-数据控制SQL语句"><a href="#3-5-数据控制SQL语句" class="headerlink" title="3.5 数据控制SQL语句"></a>3.5 数据控制SQL语句</h1><h2 id="3-5-1-什么是数据控制SQL语句"><a href="#3-5-1-什么是数据控制SQL语句" class="headerlink" title="3.5.1 什么是数据控制SQL语句"></a>3.5.1 什么是数据控制SQL语句</h2><p>在SQL语言中，数据控制SQL语句是一种可对用户数据访问权进行控制的操作语句，它可以控制特定用户或角色对数据表、视图、存储过程、触发器等数据库对象的访问权限</p>
<ul>
<li>数据控制SQL语句分类<ul>
<li>GRANT授权语句：是一种由数据库对象创建者或管理员执行的权限授予语句，它可以把访问数据库对象权限赋予给其他用户或角色</li>
<li>REVOKE收权语句：是一种由数据库对象创建或管理员赋予其它用户或角色的权限进行收回的语句，它可以收回原赋予给其他用户或角色的权限</li>
<li>DENY拒绝权限语句：是一种用于拒绝给当前数据库内的用户或者角色授予权限并防止用户或角色通过其组或角色成员继承权限的语句</li>
</ul>
</li>
</ul>
<h3 id="GRANT授权语句"><a href="#GRANT授权语句" class="headerlink" title="GRANT授权语句"></a>GRANT授权语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GRANT 权限列表  ON 数据库对象 TO 用户或角色</span><br><span class="line">//若后面接&quot;WITH GRANT OPTION&quot;子句，则被授权角色或用户还可将这些权限赋给其他用户或角色</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="REVOKE收权语句"><a href="#REVOKE收权语句" class="headerlink" title="REVOKE收权语句"></a>REVOKE收权语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库对象 FROM 用户或角色</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="DENY拒绝权限语句"><a href="#DENY拒绝权限语句" class="headerlink" title="DENY拒绝权限语句"></a>DENY拒绝权限语句</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DENY 权限列表 ON 数据库对象 TO 用户或角色</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-6-视图SQL语句"><a href="#3-6-视图SQL语句" class="headerlink" title="3.6 视图SQL语句"></a>3.6 视图SQL语句</h1><h2 id="3-6-1-什么是视图"><a href="#3-6-1-什么是视图" class="headerlink" title="3.6.1 什么是视图"></a>3.6.1 什么是视图</h2><p><strong>视图</strong>是一种通过基础表或其它视图构建的虚拟表，它本身没有自己的数据，而是使用了存储在基础表中的数据</p>
<h2 id="3-6-2-视图创建SQL语句"><a href="#3-6-2-视图创建SQL语句" class="headerlink" title="3.6.2 视图创建SQL语句"></a>3.6.2 视图创建SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE VIEW 视图名 AS SELECT查询//SELECT语句用于指定目标列</span><br><span class="line">FROM 表名</span><br><span class="line">//如果有条件限制 就加上 &quot;WHERE 条件表达式&quot;</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-6-3-视图调用SQL语句"><a href="#3-6-3-视图调用SQL语句" class="headerlink" title="3.6.3 视图调用SQL语句"></a>3.6.3 视图调用SQL语句</h2><p>当视图在数据库中创建后，用户可以像访问关系表一样去操作访问视图</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">SELECT 列名表/*</span><br><span class="line">FROM 视图名</span><br><span class="line">//如果要特殊排列，则添加&quot;ORDER BY 列名&quot;子句</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-6-4-视图删除SQL语句"><a href="#3-6-4-视图删除SQL语句" class="headerlink" title="3.6.4 视图删除SQL语句"></a>3.6.4 视图删除SQL语句</h2><p>当数据库不再需要某视图时，可以在数据库中删除该视图</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DROP VIEW 视图名//</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-6-5-视图应用"><a href="#3-6-5-视图应用" class="headerlink" title="3.6.5 视图应用"></a>3.6.5 视图应用</h2><h3 id="使用视图简化复杂SQL查询操作"><a href="#使用视图简化复杂SQL查询操作" class="headerlink" title="使用视图简化复杂SQL查询操作"></a>使用视图简化复杂SQL查询操作</h3><p>数据库开发人员可以将复杂的SQL查询语句封装在视图内，外部程序只需使用简单的试图访问方式，便可获取所需要的数据<br><img src="../photos/DataBaseCourse/3_9.png" title="创建关联表语句写法"><br><img src="../photos/DataBaseCourse/3_10.png" title="创建视图语句写法"><br><del>Emm…感觉视图写法更复杂了…</del><br>当视图被创建完成后，外部程序就可以通过SELECT语句查询视图数据 <em>(具体写法见3.6.3)</em></p>
<h3 id="使用视图提高数据访问安全性"><a href="#使用视图提高数据访问安全性" class="headerlink" title="使用视图提高数据访问安全性"></a>使用视图提高数据访问安全性</h3><p>通过视图可以将数据表内敏感数据隐藏起来，外部用户无法得知数据表的完整数据，降低数据库被攻击的风险，还可以保护用户隐私数据</p>
<h3 id="提供一定程度的数据逻辑独立性"><a href="#提供一定程度的数据逻辑独立性" class="headerlink" title="提供一定程度的数据逻辑独立性"></a>提供一定程度的数据逻辑独立性</h3><p>通过视图，可提供一定程度的数据逻辑独立性。当数据表结构发生改变，只要视图结构不变，应用程序可以不作修改</p>
<h3 id="集中展示用户所感兴趣的特定数据"><a href="#集中展示用户所感兴趣的特定数据" class="headerlink" title="集中展示用户所感兴趣的特定数据"></a>集中展示用户所感兴趣的特定数据</h3><p>通过视图，可以将用户不关心的部分数据进行过滤</p>
<hr>
<h1 id="3-7-PostgreSQL数据库实践（略）"><a href="#3-7-PostgreSQL数据库实践（略）" class="headerlink" title="3.7 PostgreSQL数据库实践（略）"></a>3.7 PostgreSQL数据库实践（略）</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" rel="tag">数据库原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-论文翻译1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/24/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%911/"
    >论文翻译1_粒子系统</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/24/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%911/" class="article-date">
  <time datetime="2022-03-24T04:11:11.000Z" itemprop="datePublished">2022-03-24</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E4%B8%AA%E4%BA%BA%E7%BF%BB%E8%AF%91/">个人翻译</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p><strong>原文作者：William T.Reeves, Lucasfilm.Ltd</strong><br><strong>原文题目：Particle Systems-A Technique for Modeling a Class of Fuzzy Objects</strong>(Computer Graphics, Volume 17, Number 3, July 1983)<br><strong>翻译仅供个人学习，勿做他用</strong><br><strong>部分地方为了语义通顺，在尊重原文意思的同时使用了意译</strong><br><strong>翻译限于个人水平，敬请见谅</strong></p>
<hr>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><ul>
<li>  当下的计算机图像合成技术对诸如云、雾、水和火等自然事物进行建模已经被证明是困难的。这些“模糊”的物体并没有平滑、界限清晰、闪闪发亮的表面，而是拥有不平整、复杂、界限模糊的表面。我们对这些事物形体的动态、流动变化深感兴趣。它们的动作既不一成不变也不能被计算机图像中的常见简单仿射变换所描绘。</li>
<li>  本文提供了一种对模糊物体的建模方法，称为“粒子系统”。粒子系统在图像合成方面与一般使用的呈现方式有三个基本的不同点。第一， 物体并不由一系列基本的面元素如多面形或色块所呈现，且它的边界也不为这些元素所定义，而是借助基本粒子组成的云团来定义它的体积；第二，粒子系统并不是确切的实体，它的粒子随着时间的变化而改变外观，粒子新旧更替。第三，由粒子系统所呈现的物体的外形并不被明确规定，因此其不具确定性。此外，随机处理被用于生成和改变物体的外观。</li>
<li>  在模糊物体的建模过程中，相较于传统以面为导向的技术，粒子系统方法有几个重要的优势。首先，粒子（目前将其想象为三维空间的一个点）是比多边形更加原始和简易的，是表面呈现方式中最为简化的。因此，在相同的计算时间内采用粒子系统可以处理更多的基元并产生更加复杂的图像。由于粒子是简易的，所以它也易于运动模糊。时态混叠效应下快速运动的物体导致的运动模糊现象在计算机图像合成中已经被长久地忽视了；第二个优势是模型定义是程序性的，并且由随机数控制。因此，相比于通常使用现有的基于表面的系统，使用粒子系统获得一个十分精细的模型并不一定需要人们长时间设计。由于它是程序性的，所以粒子系统可以调整其细节级别以适应特定的一组查看参数。使用分形曲面，使用粒子系统放大可以显示越来越多的细节；第三，使用粒子系统建模的物体是“活的”，也就是说，它们会在一段时间内改变外观。而这种复杂的动力学形式使用基于曲面的建模技术则难以实现。</li>
<li>  建模时将物体做成粒子的集合并非新想法。十五年前，最早的电脑磁带游戏将太空飞船的爆炸描绘成充满屏幕的许多光点。尽管在文献中很少提及它们，但在许多三维建模系统中，点源被用作图形数据类型。俄亥俄州的Roger Wilson使用粒子来建模从烟囱中冒出的烟雾。在他的模型中既没有随机控制，也没有动力学。Alvy Ray Smith和Jim Blinn在他们的系列节目《宇宙》（Cosmos）中使用粒子来给恒星消亡建模。Alan Norton使用粒子生成和显示三维分形形状。Jim Blinn讨论过模拟光通过和被粒子层反射的光反射函数。他的技术被用于生成土星环的图片。Blinn并没有解决模糊物体的建模问题，这也是他论文的主题。体积表示法也被认为是曲面表示的可行替代方案。实体建模是体积表示的一种，就如Norm Badler和Joe O’Rourke的《泡泡人》（Bubble-man）的一样。在分形建模中，随机建模的使用将我们的工作和最新的进展联系起来。</li>
<li>  第二部分更加详尽地描述了粒子系统的基本框架。第三部分研究了在《星际迷航2：可汗之怒》中粒子系统是怎样用于在“创世纪演示”中生成火，第四部分展现了粒子系统的另外几个应用，第五部分讨论了该领域未来的进一步研究。</li>
</ul>
<hr>
<h1 id="2-粒子系统的基本模型"><a href="#2-粒子系统的基本模型" class="headerlink" title="2 粒子系统的基本模型"></a>2 粒子系统的基本模型</h1><ul>
<li>  粒子系统是许多微小粒子的集合，它们共同表示一个模糊的物体。在一段时间内，许多粒子将被生成为一个系统、在这个系统内移动和改变外观，最后随着这个系统销毁。</li>
<li>  为了在动态演示中计算每一帧，需要进行以下步骤：(1)新粒子被生成到系统内，（2）每个粒子都被分配独立的属性，（3）系统中任何存在时间超过预定寿命的粒子都会被销毁，（4）剩余的粒子根据它们的动力学属性被移动和转化，（5）最后在帧缓存器中渲染活动粒子的图像。粒子系统可通过编程被设定为在每一步执行任何一组指令。由于它是程序性的，所以这种方法可以结合任何描述物体外观或动力学的计算模型。举个例子，粒子的运动和变换能够与一组偏微分方程的解联系在一起，或者粒子的属性能够基于统计力学被分配。因此，我们能利用那些已经在其它科学或工程学科中被开发的模型。</li>
<li>  在本文的研究中，我们是用简易的随机过程作为帧生成的每个步骤的程序性要素。为了在粒子系统中控制粒子的形状、外观和动力学特性，模型设计者需要用到一组参数。一般来说，每组参数表明了粒子属性值的范围。我们通常使用平均值和最大方差来指定这些范围。</li>
<li>  后续小节更加详尽地描述了粒子系统的基本模型和在我们编写的软件中这些粒子是如何被控制和规定的。</li>
</ul>
<h2 id="2-1-粒子生成"><a href="#2-1-粒子生成" class="headerlink" title="2.1 粒子生成"></a>2.1 粒子生成</h2><ul>
<li>  粒子在系统中以受控随机过程生成。该过程确定在每个时间间隔（给定帧）内进入系统的粒子数。生成的粒子数目很重要，因为它强烈影响模糊物体的密度。</li>
<li>  模型设计者可以在下面两种方法中选择一种来控制新粒子的数目。第一种方法是，设计者控制每帧内生成的粒子的平均数量及其方差。在帧f上生成的实际粒子数为：<center>NParts<sub>f</sub> = MeanParts<sub>f</sub> + Rand( ) × VarParts<sub>f</sub>，</center>
其中Rand是一个程序过程，它返回一个在-1.0和+1.0之间概率均匀分布的随机数，MeanParts<sub>f</sub>是粒子数量的平均数，VarParts<sub>f</sub>是粒子数量的方差。</li>
<li>  第二种方法是新粒子的数量取决于物体在屏幕上的大小。模型设计者控制每个屏幕单位面积内生成粒子的平均数及其方差。程序化粒子系统可以决定每一个特定帧的视图参数，计算其覆盖的大致区域，并相应地设定新粒子的数量。对应的方程为：<center>NParts<sub>f</sub> = (MeanParts<sub>sa<sub>f</sub></sub> + Rand( ) × VarParts<sub>sa<sub>f</sub></sub>) x ScreenArea，</center>
其中MeanParts<sub>sa</sub>是每单位屏幕面积粒子数的平均值，MeanParts<sub>sa<sub>f</sub></sub>是其方差，ScreenArea则是粒子系统在屏幕上所占的面积。这个方法
控制了粒子系统细节的级别，从而控制渲染其图像所需的时间。举个例子，我们没必要在屏幕上4个像素大小的区域生成100000个粒子。</li>
<li>  为了使粒子系统能够在密度上增减，设计者可以随时间去改变每帧生成的粒子的平均数量（即，MeanParts<sub>f</sub>和MeanParts<sub>sa<sub>f</sub></sub>是如上所述的帧数函数）。目前，我们使用一个简单的线性函数：<center>MeanParts<sub>f</sub> = InitialMeanParts + DeltaMeanParts<sub>sa<sub>f</sub></sub> x (f - f<sub>0</sub>) </center>
或
<center>MeanParts<sub>sa<sub>f</sub></sub>= InitialMeanParts<sub>sa</sub> + DeltaMeanParts<sub>sa</sub> x ( f - f<sub>0</sub>), </center>
其中f是当前帧，f<sub>0</sub>是粒子系统处于活动状态的第一帧，InitialMeanParts<sub>sa</sub>表示该第一帧的粒子平均数，VarParts<sub>sa<sub>f</sub></sub>表示其变化率，方差约束量VarParts<sub>sa<sub>f</sub></sub>和VarParts<sub>f</sub>目前在所有帧上都是常量。更复杂的二次型、三次型甚至随机变化在均值和方差参数中都很容易添加。</li>
<li>  为了控制粒子系统中的粒子生成，设计者指定f<sub>0</sub>和参数InitialMeanParts、DeltaMeanParts和VarParts，或和参数InitialMeanParts<sub>sa</sub>、DeltaMeanParts<sub>sa</sub>和VarParts<sub>sa</sub>。</li>
</ul>
<h2 id="2-2-粒子属性"><a href="#2-2-粒子属性" class="headerlink" title="2.2 粒子属性"></a>2.2 粒子属性</h2><ul>
<li>  对于每个被生成的新粒子，粒子系统必须指定其以下属性值：</li>
<li>初始位置</li>
<li>初始速度（包含速率和方向）</li>
<li>初始大小</li>
<li>初始颜色</li>
<li>初始透明度</li>
<li>形状</li>
<li>寿命</li>
<li>  粒子系统的几个参数控制着粒子的初始位置。粒子系统在三维空间内有一个用于定义原点的位置，通过原点绕坐标系旋转的两个角度得出其方向 <em>（球坐标系）</em>。粒子系统也有一个 <em>生成形状</em>，它定义了一个关于其原点的区域，新产生的粒子被随机放置在该区域内。我们已经实现的生成形状有：半径为r的球体，坐标系内xoy平面上的半径为r的圆形，以及坐标系内xoy平面上的长l宽w的矩形。图1展示了一个典型的球形生成形状的粒子系统。基于物理系统或混沌吸引子的更复杂的生成形状已被构思出来但仍未实现。<br>（插图）</li>
<li>  粒子系统的生成形状也描述了新粒子移动的初始方向。在一个球形生成形状内，粒子从粒子系统的原点向外移动。在圆形或矩形形状中，粒子从x-y平面向上移动，但被允许根据另一个参数——“放射”角度——偏移垂直方向。粒子的初始速度由该公式决定：<center>InitialSpeed = MeanSpeed + Rand( ) x VarSpeed，</center>
其中MeanSpeed和VarSpeed是粒子系统的另外两个参数，它们分别表示平均速度和速度的方差。</li>
<li>  为了确定一个粒子的初始颜色，粒子系统需要一个平均颜色和与该颜色的最大偏差。粒子透明度和粒子大小也由平均值和最大变化范围决定。这些方程与上面给出的初速公式类似。</li>
<li>  粒子系统有一个用于明确每个被生成粒子的形状的参数。目前已实现的粒子形状有球形、矩形和条纹球形。后者被用于运动态模糊化粒子——一个在给快速移动物体建模时十分重要的特性。我们在2.5小节和3小节更加详细地探讨了条纹粒子。</li>
<li>  可能的属性控制参数及其变体的数量是无限的。我们目前呈现的是已经找到的最有用和最有趣的。</li>
</ul>
<h2 id="2-3-粒子动力学"><a href="#2-3-粒子动力学" class="headerlink" title="2.3 粒子动力学"></a>2.3 粒子动力学</h2><ul>
<li>  在粒子系统内的单个粒子在三维空间内随着时间移动，并改变颜色、透明度和尺寸。</li>
<li>  将粒子从一帧移动到下一帧（的位置）易如反掌，只需将它的速度矢量加到它的位置矢量上即可。更复杂一些，粒子系统也使用加速度在帧与帧之间修改黎姿的速度。通过这个参数，模型设计师能够模拟重力并让粒子以抛物线轨迹而不是直线轨迹运动。</li>
<li>  粒子随着时间的颜色变化是由颜色变化率这一参数所规定的。粒子的透明度和尺寸也是这么被控制的。在我们的实现方案中，这些变化率在粒子系统中的影响对所有粒子而言是全局的，我们也很容易想到将这个参数也做成随机变化的。</li>
</ul>
<h2 id="2-4-粒子销毁"><a href="#2-4-粒子销毁" class="headerlink" title="2.4 粒子销毁"></a>2.4 粒子销毁</h2><ul>
<li>  粒子在被生成时赋予了一个以帧为衡量单位的寿命。随着每一帧被计算，（剩余）寿命也逐渐减少。当粒子的（剩余）寿命减为0时，粒子就被销毁了。</li>
<li>  只要粒子对图像没有任何贡献，也可以用其它机制来安排粒子的销毁。如果根据颜色和透明度计算的粒子强度低于指定阈值，则该粒子将被销毁。从其父粒子系统的原点沿指定方向移动的距离超过规定值的粒子也会被销毁。这一机制能够被用于去除在关注区域以外的粒子。</li>
</ul>
<h2 id="2-5-粒子渲染"><a href="#2-5-粒子渲染" class="headerlink" title="2.5 粒子渲染"></a>2.5 粒子渲染</h2><ul>
<li>  一旦一帧内所有粒子的位置和外形参数都被计算了，渲染算法就会生成一张图片。一般的粒子渲染问题与更常见的图元（如多边形和曲面）组成的物体对象的渲染一样复杂。粒子可以在屏幕深度上遮挡其它粒子。它们既能变得透明也能在其它粒子上投射阴影。此外，粒子可以在场景中与基于曲面的建模基元的物体共存，而且这些物体能够和粒子交合。</li>
<li>  在我们已有的系统中，有两个假设允许我们简化渲染算法。第一个假设是，我们假设粒子系统不与其它基于曲面的建模基元交合，因此我们的渲染算法只需处理粒子。使用其它技术建模的对象将在渲染后的合成阶段与粒子系统对象合成在一起。为了让粒子系统和其它物体交合或在它们后面，渲染系统将基于在模型坐标空间中定义的剪裁平面使粒子系统图像分为多个子图像，然后在合成阶段将这些子图像与其它图像混合。</li>
<li>  另外一个在目前的渲染系统中做出的假设是每个粒子能够被显示为一个点光源。借助这个假设，确定隐藏曲面不再是一个问题。每个粒子都向它覆盖的像素增加一点光强。一个在其它粒子后面的粒子不再被遮挡，而是给其覆盖的像素添加更多光强。添加的光强及其颜色取决于粒子的透明度和颜色。目前，增加光强的数值不再取决于粒子间距和观察位置，但这些是简单的拓展。观察到的变化、粒子的尺寸和它的形状决定了哪个像素要被遮挡。为了防止时间混叠和残影（的出现），所有粒子的形状都进行反锯齿绘制处理。许多粒子的光可能叠加到一个像素上，因此渲染算法固定红、绿、蓝通道的强度值固定在帧缓存器的最大强度值处，而不是让它们任意溢出。</li>
<li>  借助上述算法和假设，我们不再需要给粒子排序，它们以任意生成顺序渲染到帧缓存器。阴影不再是问题，因为粒子不再反射光而是发光。</li>
</ul>
<h2 id="2-6-粒子层级"><a href="#2-6-粒子层级" class="headerlink" title="2.6 粒子层级"></a>2.6 粒子层级</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/3D%E5%BB%BA%E6%A8%A1/" rel="tag">3D建模</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%89%A9%E7%90%86%E6%A8%A1%E6%8B%9F/" rel="tag">物理模拟</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E7%B2%92%E5%AD%90%E7%B3%BB%E7%BB%9F/" rel="tag">粒子系统</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%91/" rel="tag">论文翻译</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-FinalIK和Ragdoll(2)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/22/FinalIK%E5%92%8CRagdoll(2)/"
    >FinalIK和Ragdoll(2)：FullyBodyBipedIK</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/22/FinalIK%E5%92%8CRagdoll(2)/" class="article-date">
  <time datetime="2022-03-22T14:15:30.000Z" itemprop="datePublished">2022-03-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CW411N7ri?spm_id_from=333.999.0.0">教程视频</a><br>本文仅供个人学习和知识点记录用。<br>Unity版本：2021.2.15f1c1<br>Final IK版本：2.1<del>（工作室群文件里有）</del><br>Low Poly模型素材包：Heist<br>状态机来源：Unity Standard Assets</p>
<hr>
<h1 id="2-1-FullyBodyBipedIK介绍"><a href="#2-1-FullyBodyBipedIK介绍" class="headerlink" title="2.1 FullyBodyBipedIK介绍"></a>2.1 FullyBodyBipedIK介绍</h1><h2 id="FullyBodyBipedIK还是BipedIK？"><a href="#FullyBodyBipedIK还是BipedIK？" class="headerlink" title="FullyBodyBipedIK还是BipedIK？"></a>FullyBodyBipedIK还是BipedIK？</h2><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/ddcd668345b5">分析链接</a></p>
<h2 id="FullyBodyBipedIK提供了哪些功能？"><a href="#FullyBodyBipedIK提供了哪些功能？" class="headerlink" title="FullyBodyBipedIK提供了哪些功能？"></a>FullyBodyBipedIK提供了哪些功能？</h2><p>FullyBodyBipedIK自动将模型的骨骼点添加入Reference内，可以通过FullyBodyBipedIK调整骨骼各个结点位置、旋转角度、扭曲程度受IK影响的权重和计算中结点的位置，由于你可以更改这些结点的位置（比如用一个别的什么物体的位置来替代它们），因此可以做出各种效果，比如躯体的扭曲。你也可以通过更改这些替代者的位置来改变模型的姿态。</p>
<h2 id="2-1-1-来看看FullyBodyBipedIK里面有些啥"><a href="#2-1-1-来看看FullyBodyBipedIK里面有些啥" class="headerlink" title="2.1.1 来看看FullyBodyBipedIK里面有些啥"></a>2.1.1 来看看FullyBodyBipedIK里面有些啥</h2><p><img src="../photos/Unity/FinalIK/2_1.png" title="FullyBodyBipedIK"></p>
<ul>
<li>Fix Transforms：勾选则每一帧刷新一次结点状态（对算力消耗大）。</li>
<li>References：IK计算时需要的各个结点位置。<ul>
<li>Root Node：</li>
<li>Weight：一切Weight的权重基数，1为完全受IK影响，0为完全受状态机影响（本处及下文所提到的所有Weight都具有该共性，故仅提一次），它和后面各个结点的Weight是相乘关系（若某结点的Weight是0而References的Weight是1则该结点不受IK影响，若References的Weight是0则无论如何所有结点都不受IK影响。</li>
<li>Iterations：</li>
</ul>
</li>
<li>Target：</li>
<li>Position Weight：结点位置受IK影响的权重。</li>
<li>Rotation Weight：结点旋转受IK影响的权重。</li>
<li>Use Thighs：</li>
<li>Spine Stiffness：</li>
<li>Pull Body Vertical：</li>
<li>Pull Body Horizontal：</li>
<li>Spine Iterations：</li>
<li>Spine Twist Weight：结点扭曲受IK影响的权重。</li>
<li>Maintain Head Rot：</li>
<li>Maintain Relative Position：</li>
<li>Pull：</li>
<li>Push：</li>
<li>Push Parent：</li>
<li>Reach：</li>
<li>Bend Goal：</li>
<li>Bend Goal Weight：</li>
<li>Mapping Weight：</li>
</ul>
<h1 id="2-1-x-问题解决方案"><a href="#2-1-x-问题解决方案" class="headerlink" title="2.1.x 问题解决方案"></a>2.1.x 问题解决方案</h1><ul>
<li>如果有红色/黄色的骨骼点，首先锁住模型的Inspector（在Inspector的右上角）以方便在你调整出错位置时骨骼点仍然显示,对问题骨骼点进行调整直至为蓝点。</li>
<li>如果运动时发现模型的某个部位没有随着模型一起运动（越远离根结点模型的该部位越朝起点倾斜），则要检查FullyBodyBipedIK内的该部位的<strong>Body Effector的Target</strong>是否绑定了该结点。</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Final-IK/" rel="tag">Final IK</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ragdoll/" rel="tag">Ragdoll</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-FinalIK和Ragdoll(1)"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/22/FinalIK%E5%92%8CRagdoll(1)/"
    >FinalIK和Ragdoll(1)：准备工作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/22/FinalIK%E5%92%8CRagdoll(1)/" class="article-date">
  <time datetime="2022-03-22T11:34:03.000Z" itemprop="datePublished">2022-03-22</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1CW411N7ri?spm_id_from=333.999.0.0">教程视频</a><br>本文仅供个人学习和知识点记录用。<br>Unity版本：2021.2.15f1c1<br>Final IK版本：2.1<del>（工作室群文件里有）</del><br>Low Poly模型素材包：Heist<br>状态机来源：Unity Standard Assets</p>
<hr>
<h1 id="1-1-一些问题的解决方案"><a href="#1-1-一些问题的解决方案" class="headerlink" title="1.1 一些问题的解决方案"></a>1.1 一些问题的解决方案</h1><h2 id="1-1-1-导入Final-IK如果报错："><a href="#1-1-1-导入Final-IK如果报错：" class="headerlink" title="1.1.1 导入Final IK如果报错："></a>1.1.1 导入Final IK如果报错：</h2><p><img src="../photos/Unity/FinalIK/1_1.png" title="error"><br><strong>解决方案</strong>：双击error进入问题所在脚本，在最上面写“using UnityEngine，UI”,然后把“GUIText”改为“Text”</p>
<h2 id="1-1-2-挂了ThirdPersonAnimatorController但按WASD角色没反应"><a href="#1-1-2-挂了ThirdPersonAnimatorController但按WASD角色没反应" class="headerlink" title="1.1.2 挂了ThirdPersonAnimatorController但按WASD角色没反应"></a>1.1.2 挂了ThirdPersonAnimatorController但按WASD角色没反应</h2><p><strong>解决方案</strong>：<strong>Project Settings-&gt;Player-&gt;Other Settings-&gt;Configuration-&gt;Active Input Handing-&gt;Both</strong></p>
<h1 id="1-2-简要了解Final-IK"><a href="#1-2-简要了解Final-IK" class="headerlink" title="1.2 简要了解Final IK"></a>1.2 简要了解Final IK</h1><h2 id="1-2-1-什么是IK"><a href="#1-2-1-什么是IK" class="headerlink" title="1.2.1 什么是IK"></a>1.2.1 什么是IK</h2><ul>
<li>正向动力学（Forward Kinematics）：每一个子关节的位置、方向由父关节支配（父关节动，子关节跟着动，子关节动，父关节未必动）的动力学模型，比如走路。使用FK做这类动作比较简单（你自己走几下就知道如何设计游戏人物的走路动作）<strong>计算速度快</strong>，但<strong>工作效率低</strong>（因为<strong>几乎所有的父关节都要人工调整</strong>）。</li>
<li>反向动力学（Inverse Kinematics）：依据某些子关节的最终位置、角度反求出整个骨架形态的动力学模型，比如在战斗中挥剑抵挡攻击，让剑去抵挡，也就是依据剑或者持剑的手的状态来调整手的父节点（手腕、肘部、上臂、肩膀和脊柱等）的位置的时候，使用IK能够让格挡动作易于实现，<strong>不必人工调整父节点，交由计算机计算</strong>减少了工作量，但是这么做会<strong>占用计算机资源</strong>，使用IK的关节越多，这种负面效果越明显。</li>
<li>一般的做法：<ul>
<li>FPS游戏（骨骼动画+IK）：在跑动、走路、跳跃、匍匐这类姿势比较单一的动作中使用骨骼动画，而在角色和环境互动的部分（主要是手、脚）使用IK，使得人在上坡时脚面贴着斜坡，可以跨过不同高度的障碍物，拿取不同高度的物品等，充分利用<strong>IK的灵活性</strong>和<strong>IK受物理环境影响</strong>的特性。</li>
<li>需要夸大肢体动作，夸大物理效果的动作类游戏（比如人类一败涂地）：借助IK<strong>依据子关节调整父关节</strong>的特性，做出一些搞笑的效果。</li>
<li>VR：由于VR世界中可以供玩家输入的设备只有头戴显示器和手柄，对应虚拟世界中的头和手，如果我们需要通过手柄和头的动作让虚拟形象其他部位的动作贴近真实，我们可以借助IK技术。</li>
</ul>
</li>
</ul>
<h2 id="1-2-2-为什么是Final-IK"><a href="#1-2-2-为什么是Final-IK" class="headerlink" title="1.2.2 为什么是Final IK"></a>1.2.2 为什么是Final IK</h2><ul>
<li>易于上手，便于学习（在Inspector内就可以做出大部分调整，不用一遍遍回到脚本里改）</li>
<li>可视界面，较为友好（早期甚至不用接触代码）</li>
<li>可以调整的部位比Unity IK多</li>
</ul>
<hr>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Final-IK/" rel="tag">Final IK</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Ragdoll/" rel="tag">Ragdoll</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据库原理笔记2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B02/"
    >数据库原理笔记2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B02/" class="article-date">
  <time datetime="2022-03-21T12:43:38.000Z" itemprop="datePublished">2022-03-21</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">课程笔记_数据库原理</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="依照学校教学安排，第二章为数据库关系模型"><a href="#依照学校教学安排，第二章为数据库关系模型" class="headerlink" title="依照学校教学安排，第二章为数据库关系模型"></a>依照学校教学安排，第二章为数据库关系模型</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="2-1-关系及其相关概念"><a href="#2-1-关系及其相关概念" class="headerlink" title="2.1 关系及其相关概念"></a>2.1 关系及其相关概念</h1><h2 id="2-1-1-关系模型的提出"><a href="#2-1-1-关系模型的提出" class="headerlink" title="2.1.1 关系模型的提出"></a>2.1.1 关系模型的提出</h2><p>关系模型以关系代数理论为数学基础，将数据操作抽象为关系处理，其关系表结构简单，便于理解和访问。关系模型在当今几乎所有商业数据库中得到广泛应用，该理论由E.F.Codd于1970年发表。</p>
<h2 id="2-1-2-实体、关系的概念"><a href="#2-1-2-实体、关系的概念" class="headerlink" title="2.1.2 实体、关系的概念"></a>2.1.2 实体、关系的概念</h2><ul>
<li><strong>实体</strong>：包含有数据特征的事物对象在概念模型世界中的抽象名称，可以理解成对象</li>
<li><strong>关系</strong>：在关系模型中，使用关系来存储实体中的数据，关系指<strong>具有关系特征、用于存放实体数据的二维表</strong>，关系也常被称为关系表</li>
<li><strong>关系特征</strong>：在关系表中，每一行称为<strong>元组</strong>，每一列称为<strong>属性</strong><ul>
<li>表中每行存储实体的一个示例数据</li>
<li>表中每列包含实体的一项属性数据</li>
<li>表中单元格只能存储单个值</li>
<li>不允许有重复的行、列</li>
<li>行列顺序可任意</li>
</ul>
</li>
</ul>
<h2 id="2-1-3-关系的数学定义"><a href="#2-1-3-关系的数学定义" class="headerlink" title="2.1.3 关系的数学定义"></a>2.1.3 关系的数学定义</h2><ul>
<li><strong>定义</strong>：关系是指在集合域D<sub>1</sub>、…、D<sub>n</sub>上运算笛卡尔积 *(设A、B是两个集合，称集合AxB={&lt;a,b&gt;|(a∈A)^(b∈B)}为集合A与B的笛卡尔积)*的有意义子集，其数学描述为R⊆D<sub>1</sub>xD<sub>2</sub>x、…、xD<sub>n</sub>，其中每一个向量(d1,d2,…dn)称为一个<strong>n元组</strong>，简称元组。想两种的每个di称为分量。若集合域D<sub>i</sub>(i=1,2,…,n)为有限集，每个域的基数为m<sub>i</sub>(i=1,2,…,n)，则笛卡尔积D<sub>1</sub>xD<sub>2</sub>x、…、xD<sub>n</sub>的基数M为m<sub>i</sub>从1到n的累乘</li>
<li><strong>注意</strong>：关系R只是该笛卡尔积的<strong>有意义子集</strong>，即关系R的元组数≤笛卡尔积的元组数</li>
</ul>
<h2 id="2-1-4-关系的键定义"><a href="#2-1-4-关系的键定义" class="headerlink" title="2.1.4 关系的键定义"></a>2.1.4 关系的键定义</h2><ul>
<li>在关系中，可以用来唯一标识元组的属性列称为<strong>键</strong>，其它属性列都为非键列</li>
<li><strong>复合键</strong>：关系中用来唯一标识元组的<strong>多列</strong></li>
<li><strong>候选键</strong>：关系中可能有多个列均适合作为键，将其中每个都称为候选键</li>
<li><strong>主键</strong>：关系表中最有代表性的一个候选键，每个关系表中只能定义一个主键<ul>
<li>主键作用<ul>
<li>唯一标识关系表的每行（元组）</li>
<li>与关联表的外键建立联系，实现关系表之间连接</li>
<li>数据库文件使用主键值来组织关系表的数据存储</li>
<li>数据库使用主键索引快速检索数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>代理键</strong>：采用DBMS自动生成的数字序列作为关系表的主键<ul>
<li>代理键的作用：由DBMS自动生成的数字序列作为主键，可替代复合主键，以便获得更高性能的数据访问操作处理</li>
</ul>
</li>
</ul>
<h2 id="2-1-5-关系模式语句表示"><a href="#2-1-5-关系模式语句表示" class="headerlink" title="2.1.5 关系模式语句表示"></a>2.1.5 关系模式语句表示</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RELATION_NAME(Column01,Column02,...,LastColumn)//关系名称(主键属性,属性名2,...,最后一个属性名)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-2-关系模型原理"><a href="#2-2-关系模型原理" class="headerlink" title="2.2 关系模型原理"></a>2.2 关系模型原理</h1><h2 id="2-2-1-关系模型及其组成"><a href="#2-2-1-关系模型及其组成" class="headerlink" title="2.2.1 关系模型及其组成"></a>2.2.1 关系模型及其组成</h2><ul>
<li><strong>关系模型</strong>：一种基于二维表结构存储数据实体及实体间联系的数据模型<ul>
<li>数据结构：关系模型由若干二维表组成，并且表之间存在一定的联系，它们一起组织、存储数据</li>
<li>数据操作：关系模型中可以进行集合运算操作（选择、投影、连接、交、并、差……）、专门关系运算操作（数据行插入、修改、删除）</li>
<li>数据约束：在关系模型中，数据关系约束是指关系表中实体数据完整性、关联表之间数据一致性（属性列取值类型、属性列取值范围、属性列取值是否唯一、属性列是否允许空值）等要求，一般由业务需求来确定</li>
</ul>
</li>
</ul>
<h2 id="2-2-2-关系模型数据操作"><a href="#2-2-2-关系模型数据操作" class="headerlink" title="2.2.2 关系模型数据操作"></a>2.2.2 关系模型数据操作</h2><p>关系模型数据操作采用基于关系代数的数据操作，包括传统的集合运算操作和专门的关系运算操作</p>
<ul>
<li>关系并运算操作：关系并运算的结果集是由属于R或属于S的所有元组组成</li>
<li>关系差运算操作：关系差运算的结果集是由属于R但不属于S的所有元组组成</li>
<li>关系交运算操作：关系交运算的结果集是由既属于R又属于S的所有元组组成</li>
<li>关系笛卡尔积操作：关系笛卡尔积的结果集是由所有属于R的元组和所有属于S的元组进行组合而成</li>
</ul>
<h2 id="2-2-3-关系模型完整性"><a href="#2-2-3-关系模型完整性" class="headerlink" title="2.2.3 关系模型完整性"></a>2.2.3 关系模型完整性</h2><p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束</p>
<ul>
<li>完整性约束作用<ul>
<li>消除关系表的元组重复存储</li>
<li>保持关联表的数据一致性 </li>
<li>实现业务数据规则</li>
</ul>
</li>
<li>关系模型完整性约束组成<ul>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义完整性约束</li>
</ul>
</li>
</ul>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性是指在关系表中实施的主键取值约束，以保证关系表中的每个元组可以被唯一标识</p>
<ul>
<li>实体完整性约束规则<ul>
<li>每个关系表中的主键属性列都不允许为空值，否则就不可能标识实体</li>
<li>现实世界中的实体是靠主键来标识，主键取值应该唯一，并区分关系表中的每个元组</li>
</ul>
</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据一致性</p>
<ul>
<li><strong>外键</strong>：在关联的两个主系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</li>
<li>参照完整性约束规则：若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致</li>
</ul>
<h3 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h3><p>用户自定义完整性是指用户根据具体业务对数据处理规则要求所定义的数据约束</p>
<ul>
<li>用户可以定义如下类型的完整性约束：<ul>
<li>定义列的数据类型和数据范围</li>
<li>定义类的缺省值 <em>（无干预情况下的默认值）</em></li>
<li>定义列是否允许取空值</li>
<li>定义列取值唯一性</li>
<li>定义列之间的数据依赖性</li>
</ul>
</li>
</ul>
<h2 id="2-2-4-ON条件、where条件"><a href="#2-2-4-ON条件、where条件" class="headerlink" title="2.2.4 ON条件、where条件"></a>2.2.4 ON条件、where条件</h2><ul>
<li>ON条件：在生成临时表时使用的条件，它不管on中的条件是否都为真，都会返回左表中的记录</li>
<li>where条件：在临时表生成好后，再对临时表进行过滤的条件，此时已经没有leftjoin的含义，条件不为真的就全部过滤掉、</li>
</ul>
<h2 id="2-2-5-自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接"><a href="#2-2-5-自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接" class="headerlink" title="2.2.5 自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接"></a>2.2.5 自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接</h2><ul>
<li>自然连接：自然连接不用指定连接列，也不能使用ON语句，它默认比较两张表里相同的列</li>
<li>内连接：内连接可以自定义两张表的不同列字段，内连接有两种形式：显式（有INNER JOIN，形成的中间表为两个表经过ON条件过滤后的笛卡尔积）和隐式（没有INNER JOIN，形成的中间表为两个表的笛卡尔积）</li>
<li>外连接<ul>
<li>左外连接：返回指定左表的全部行+右表对应的行，如果左表中数据在右表中没有与其相匹配的行，则在查询结果集合中显示为空值 <em>（null）</em>。</li>
<li>右外连接：与左外连接类似，是左外连接的反向链接</li>
<li>全外连接：将左右两表进行自然连接，左表或右表只要有一个没有就显示NULL<br><a target="_blank" rel="noopener" href="https://www.w3school.com.cn/sql/sql_join_inner.asp">关键字使用参考</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-3-PostgreSQL数据库关系操作实践（略）"><a href="#2-3-PostgreSQL数据库关系操作实践（略）" class="headerlink" title="2.3 PostgreSQL数据库关系操作实践（略）"></a>2.3 PostgreSQL数据库关系操作实践（略）</h1> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" rel="tag">数据库原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-数据库原理笔记1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B01/"
    >数据库原理笔记1</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B01/" class="article-date">
  <time datetime="2022-03-10T13:10:54.000Z" itemprop="datePublished">2022-03-10</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/">课程笔记_数据库原理</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="依照学校教学安排，第一章为数据库系统概论"><a href="#依照学校教学安排，第一章为数据库系统概论" class="headerlink" title="依照学校教学安排，第一章为数据库系统概论"></a>依照学校教学安排，第一章为数据库系统概论</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="1-1-数据库及其系统概念"><a href="#1-1-数据库及其系统概念" class="headerlink" title="1.1 数据库及其系统概念"></a>1.1 数据库及其系统概念</h1><h1 id="1-1-1-什么是数据库？"><a href="#1-1-1-什么是数据库？" class="headerlink" title="1.1.1 什么是数据库？"></a>1.1.1 什么是数据库？</h1><ul>
<li>在任何信息系统的技术实现中均需要一类<strong>用于组织和存储数据的数据容器</strong></li>
<li>支持应用程序对数据的共享操作访问</li>
<li>将信息系统的各类数据如<strong>文本数据、图表数据、音视频数据等</strong>进行组织存储并<strong>提供能对外访问</strong></li>
<li><strong>数据库的定义</strong>：一种依照特定<strong>数据模型</strong>组织、存储和管理数据的文件集合，这些文件一般存放在外部存储器中，以便长久保存数据，并可快速访问</li>
<li><strong>数据库文件组成</strong>：<strong>数据文件</strong>和<strong>日志文件</strong></li>
<li><strong>数据库的本质就是一类数据文件</strong></li>
<li>数据库与普通数据文件的主要区别<ul>
<li>数据库可以支持不同应用对数据共享访问，普通数据文件难以支持</li>
<li>数据库可以实现复杂的数据管理，普通数据文件难以实现</li>
<li>数据库可独立于应用程序，普通数据文件与应用程序紧耦合</li>
<li>数据库的操作访问与控制管理由数据库管理系统软件实现，普通数据文件的操作访问与控制管理都必须由应用程序实现</li>
</ul>
</li>
</ul>
<h1 id="1-1-2-什么是数据模型"><a href="#1-1-2-什么是数据模型" class="headerlink" title="1.1.2 什么是数据模型"></a>1.1.2 什么是数据模型</h1><ul>
<li>数据模型是指描述事物对象的<strong>数据结构组成</strong>、<strong>数据语义联系</strong>、<strong>数据约束的抽象结构及其说明</strong>，由数据结构、数据操作和数据约束组成<ul>
<li>数据结构：用于描述事物对象的静态特征，包括事物对象的数据组成、数据类型、数据性质等</li>
<li>数据操作：用于描述事物对象的动态特征，包括数据的插入、修改、删除和查询等访问操作</li>
<li>数据约束：用于描述数据结构中数据之间的语义联系，数据之间的制约和依存关系，以及数据动态变化的规则等</li>
</ul>
</li>
</ul>
<h1 id="1-1-3-数据库使用的数据模型"><a href="#1-1-3-数据库使用的数据模型" class="headerlink" title="1.1.3 数据库使用的数据模型"></a>1.1.3 数据库使用的数据模型</h1><ul>
<li><strong>层次数据模型</strong>：最早使用的一种数据模型<ul>
<li>采用树结构来组织、存储和管理数据，每个结点存储一个数据记录，数据结点之间通过链接指针相互联系，通过结点遍历访问方法实现查询数据</li>
<li>由于树结构受限于上下结点层次访问，缺乏灵活性，故后来使用网状数据模型</li>
</ul>
</li>
<li><strong>网状数据模型</strong><ul>
<li>采用网状图结构组织、存储和管理数据，在网状图中，中间结点不但可以上下层次访问，还可以横向关联访问</li>
<li>优点：可灵活地表示数据之间的复杂关系，数据冗余小</li>
<li>缺点：结构复杂，增加了数据查询、数据修改 <em>（需要更改数据结点和关联指针）</em>和数据定位的难度，因此使用关系数据模型</li>
</ul>
</li>
<li><strong>关系数据模型</strong><ul>
<li>采用二维表结构组织、存储和管理数据，并以关联列实现表之间的关系</li>
<li>优点：数据结构简单、操作灵活，支持关系与集合运算操作，支持广泛使用的SQL数据库操作语言标准，拥有众多产品与用户</li>
<li>缺点：只用于结构化数据的组织与存储管理，支持的数据类型较简单，难以支持互联网广泛应用的非结构化数据和复杂数据管理</li>
</ul>
</li>
<li><strong>其它数据模型</strong>：如对象数据模型、键值对数据模型、列式数据模型、文档数据模型、图形数据模型等</li>
</ul>
<h1 id="1-1-4-数据库系统"><a href="#1-1-4-数据库系统" class="headerlink" title="1.1.4 数据库系统"></a>1.1.4 数据库系统</h1><ul>
<li>定义：<strong>一类基于数据库进行数据管理与信息服务的软件系统</strong></li>
<li>组成：<strong>数据库用户、数据库应用程序、数据库管理系统、数据库</strong><ul>
<li>数据库用户：由应用程序员 <em>（开发）</em>、系统分析员 <em>（开发）</em>、数据库管理员 <em>（使用DBMS提供的工具维护数据库系统）</em>、最终用户构成</li>
<li>数据库应用程序：是一种在DBMS支持下对数据库中数据进行访问处理的应用程序，基本功能有：<ul>
<li>通过输入框采集用户输入数据</li>
<li>通过接口连接访问数据库</li>
<li>执行用户数据查询</li>
<li>通过表单列表输出结果数据</li>
<li>…</li>
</ul>
</li>
<li>数据库管理系统DBMS：一种专门用于**创建、管理 <em>（包括读写、修改、删除数据等）</em>、维护、提供外部访问数据库支持 <em>（执行数据访问规则）</em>、执行数据库备份和恢复**的系统软件</li>
<li>数据库：一种依照特定数据模型组织、存储和管理数据的文件集合</li>
</ul>
</li>
</ul>
<h1 id="1-1-5-关系数据库中的数据内容"><a href="#1-1-5-关系数据库中的数据内容" class="headerlink" title="1.1.5 关系数据库中的数据内容"></a>1.1.5 关系数据库中的数据内容</h1><ul>
<li>在关系数据库中，除了存储和管理应用的<strong>用户数据</strong> <em>（存放于用户表）</em>外，还需要存与管理数据库本身的<strong>元数据、索引数据、运行数据</strong> <em>（存放于系统表）</em>等系统数据</li>
</ul>
<h1 id="1-1-6-关系数据库的对象组织"><a href="#1-1-6-关系数据库的对象组织" class="headerlink" title="1.1.6 关系数据库的对象组织"></a>1.1.6 关系数据库的对象组织</h1><ul>
<li>用户表：存储用户的应用数据</li>
<li>系统表：存储数据库系统自身数据</li>
<li>视图：通过虚拟表实现数据查询处理</li>
<li>索引：通过目录数据结构支持快速数据查询</li>
<li>约束：对关系表及其数据施加规则</li>
<li>存储过程：在数据库内部实现特定功能程序的数据处理</li>
<li>触发器：在数据库内部实现数据操作事件触发自动执行的过程程序</li>
</ul>
<hr>
<h1 id="1-2-数据库技术发展"><a href="#1-2-数据库技术发展" class="headerlink" title="1.2 数据库技术发展"></a>1.2 数据库技术发展</h1><h2 id="1-2-1数据管理技术发展阶段"><a href="#1-2-1数据管理技术发展阶段" class="headerlink" title="1.2.1数据管理技术发展阶段"></a>1.2.1数据管理技术发展阶段</h2><ul>
<li>人工管理阶段<ul>
<li>应用需求：科学计算</li>
<li>硬件背景：简单的计算机，纸带打孔I/O</li>
<li>软件背景：没有操作系统</li>
<li>数据管理：人工在代码中控制处理</li>
<li>管理特点：<ul>
<li>程序员组织与管理数据</li>
<li>应用程序依赖数据集</li>
<li>应用之间无数据共享、数据冗余度大</li>
<li>数据集无结构</li>
</ul>
</li>
</ul>
</li>
<li>文件系统管理阶段<ul>
<li>应用需求：科学计算、信息管理</li>
<li>硬件背景：磁鼓、磁带、磁盘等外部存储设备的出现</li>
<li>软件背景：操作系统、文件系统等系统软件的出现</li>
<li>数据管理：文件方式组织和存储数据，应用程序可通过文件系统提供的文件存取方法接口访问数据文件</li>
<li>管理特点：<ul>
<li>由文件组织与存储数据</li>
<li>数据文件的数据记录具有简单的字段结构，但文件整体无结构</li>
<li>应用程序依赖于数据文件，需自己维护数据文件</li>
<li>数据独立性差，难以实现应用程序之间的数据共享访问</li>
</ul>
</li>
</ul>
</li>
<li>数据库系统管理阶段<ul>
<li>应用需求：大规模信息管理</li>
<li>硬件背景：大容量磁盘、磁盘阵列的出现，支持大容量数据管理</li>
<li>软件背景：数据库管理系统出现</li>
<li>数据管理：数据库管理系统组织、存储和访问数据</li>
<li>管理特点：<ul>
<li>数据集结构化，易于查询和统计处理</li>
<li>不同应用程序可以实现数据共享访问</li>
<li>数据独立性高，应用可扩展</li>
<li>数据由DBMS统一管理和操作访问<h2 id="1-2-2数据库技术发展经历时代"><a href="#1-2-2数据库技术发展经历时代" class="headerlink" title="1.2.2数据库技术发展经历时代"></a>1.2.2数据库技术发展经历时代</h2></li>
</ul>
</li>
</ul>
</li>
<li>第一代数据库技术：20世纪60年代末出现的层次模型数据库技术和网状模型数据库技术</li>
<li>第二代数据库技术：20世纪70年代出现的关系模型数据库技术</li>
<li>第三代数据库技术：20世纪90年代出现的面向对象数据库技术和对象-关系数据模型数据库技术</li>
<li>第四代数据库技术：本世纪初期出现的半结构化数据库技术，以及当今面向互联网应用的非结构化数据库技术、大规模分布式数据库技术<h2 id="1-2-3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术"><a href="#1-2-3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术" class="headerlink" title="1.2.3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术"></a>1.2.3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术</h2><h2 id="1-2-4数据库技术发展趋势"><a href="#1-2-4数据库技术发展趋势" class="headerlink" title="1.2.4数据库技术发展趋势"></a>1.2.4数据库技术发展趋势</h2></li>
<li>数据库规模朝两级发展，大型数据库系统越来越大，小型数据库系统越来越小</li>
<li>从数据库行数据访问模式，到列数据访问模式</li>
<li>从结构化数据库，到半结构化XML数据库、非结构化数据库</li>
<li>从操作型数据库系统，到数据仓库、商业智能数据分析、大数据处理</li>
<li>从通用数据库，到实时数据库、多媒体数据库、空间数据库、分布式数据库、并行数据库等专业领域数据库</li>
</ul>
<hr>
<h1 id="1-3-数据库应用系统"><a href="#1-3-数据库应用系统" class="headerlink" title="1.3 数据库应用系统"></a>1.3 数据库应用系统</h1><h2 id="1-3-1数据库应用系统类型"><a href="#1-3-1数据库应用系统类型" class="headerlink" title="1.3.1数据库应用系统类型"></a>1.3.1数据库应用系统类型</h2><ul>
<li>业务处理系统TPS：运用数据库应用程序对机构业务活动信息进行记录、计算、检索、汇总、统计等数据处理，为机构操作层面提供基本业务服务，提高业务处理效率的信息系统。</li>
<li>管理信息系统MIS：一种以机构职能管理为主导，利用计算机软硬件、网络通信、数据库等IT技术，实现机构职能整体信息化管理，以达到规范化管理和提高机构工作效率，并支持机构职能服务的信息系统</li>
<li>决策支持系统DSS：以管理科学、运筹学、控制论和行为科学为基础，以计算机技术、数据库技术、人工智能技术为手段，针对特定领域问题解决，为管理者提供辅助决策服务与方案的信息系统 <h2 id="1-3-2数据库系统应用结构"><a href="#1-3-2数据库系统应用结构" class="headerlink" title="1.3.2数据库系统应用结构"></a>1.3.2数据库系统应用结构</h2></li>
<li>单机用户结构：整个数据库应用系统都装在一台计算机上，由一个用户进行访问操作，<strong>数据不能共享，数据冗余度大</strong></li>
<li>集中式结构：数据库系统的应用程序、DBMS、数据都部署在同一服务器上运行，多个用户使用自己的计算机终端网络连接服务器，并可实现共享访问数据库，<strong>结构简单，易于维护，但当终端用户增加到一定数量后，服务器及网络将成为数据存取访问的瓶颈，使系统的性能大大降低</strong></li>
<li>客户/服务器结构：数据库应用程序的数据集中在数据库服务器管理、应用分布客户机处理。客户端应用程序通过网络并发访问数据库服务器中的数据库，客户机程序与数据库服务器<strong>分工进行数据处理，提高系统负载分担能力，但仍会因大量客户端并发访问数据库服务器，导致系统性能瓶颈</strong></li>
<li>分布式结构：分布式结构下的各服务器结点数据库在逻辑上是一个整体，但物理分布在计算机网络的不同服务器结点上运行，每个数据库服务器可通过网络既支持多个本地客户机访问，也支持远程客户机访问。<strong>既实现数据分布，又实现处理分布，并执行全局应用</strong>，适合跨地区的大型机构及企业等组织对数据库应用的要求，<strong>处理性能强，但数据库的分布处理与维护有一定的开销和技术难度</strong><h2 id="1-3-3数据库应用系统生命周期"><a href="#1-3-3数据库应用系统生命周期" class="headerlink" title="1.3.3数据库应用系统生命周期"></a>1.3.3数据库应用系统生命周期</h2></li>
<li><strong>需求分析</strong>：系统分析人员与用户交流，利用软件工程方法获取系统数据需求信息，并采用需求模型定义系统数据组成及其数据字典</li>
<li><strong>系统设计</strong>：系统设计人员根据系统功能和性能需求，对系统数据库进行设计，包括系统概念数据模型、系统逻辑数据模型和系统物理数据模型设计</li>
<li><strong>系统实现</strong>：按照系统设计方案进行数据库创建与应用编程实现，主要包括DBMS安装部署、数据库创建、数据对象创建、应用编程实现等方面的工作</li>
<li><strong>系统测试</strong>：系统测试人员将测试数据上载到数据库中，对数据库对象进行测试操作访问，实现数据库功能和性能测试</li>
<li><strong>系统运行与维护</strong>：系统运维人员在信息系统投入运行过程中，对数据库系统进行定期维护和优化，以保证数据库系统正常地、高效地运行</li>
</ul>
<hr>
<h1 id="1-4-典型数据库管理系统"><a href="#1-4-典型数据库管理系统" class="headerlink" title="1.4 典型数据库管理系统"></a>1.4 典型数据库管理系统</h1><h2 id="1-4-1-数据库管理系统类型"><a href="#1-4-1-数据库管理系统类型" class="headerlink" title="1.4.1 数据库管理系统类型"></a>1.4.1 数据库管理系统类型</h2><ul>
<li>按用途分类<ul>
<li>通用DBMS：支持公共领域数据库应用，广泛应用在各个机构的业务信息系统、办公管理系统、商业信息系统中，如 SQL Server</li>
<li>专用领域DBMS：支持专用领域数据库应用，如嵌入式应用、实时计算、多媒体应用等领域，如SQLite</li>
</ul>
</li>
<li>按用户数分类<ul>
<li>单用户DBMS：仅支持单用户访问，如miniSQL</li>
<li>多用户DBMS：可支持多用户并行访问，如MySQL</li>
</ul>
</li>
<li>按系统部署分类<ul>
<li>集中式DBMS：数据库集中部署在单一物理机器中，针对中小型信息系统，如Access</li>
<li>分布式DBMS：数据库可分布在不同位置的物理机器中，针对跨区域的大规模信息系统，如Oracle Database</li>
</ul>
</li>
<li>按使用场景分类<ul>
<li>桌面级DBMS：适用于微小型的信息服务应用，针对小规模或个人信息服务，对数据处理能力要求不高，通常只支持单一语言的应用程序开发，如Access、SQLite等</li>
<li>企业级DBMS：适用于中大型的企业级应用，针对中大规模信息服务，对功能、可靠性和性能有较高要求，支持多种不同语言的应用程序开发，如DB2、Oracle Database、Sybase ASE等</li>
</ul>
</li>
<li>按软件版权分类<ul>
<li>产品DBMS：厂商拥有版权的数据库软件，面向市场出售技术服务，如SQL Server、 Oracle Database等</li>
<li>开源DBMS：开源组织提供的数据库软件，免费下载供学习科研使用，如MySQL、PostgreSQL等</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-5-PostgreSQL对象-关系数据库系统软件、"><a href="#1-5-PostgreSQL对象-关系数据库系统软件、" class="headerlink" title="1.5 PostgreSQL对象-关系数据库系统软件、"></a>1.5 PostgreSQL对象-关系数据库系统软件、</h1><h2 id="1-5-1–1-5-3-略"><a href="#1-5-1–1-5-3-略" class="headerlink" title="1.5.1–1.5.3 略"></a>1.5.1–1.5.3 略</h2><h2 id="1-5-4-PostgreSQL数据库软件的服务器程序的部分常用命令"><a href="#1-5-4-PostgreSQL数据库软件的服务器程序的部分常用命令" class="headerlink" title="1.5.4 PostgreSQL数据库软件的服务器程序的部分常用命令"></a>1.5.4 PostgreSQL数据库软件的服务器程序的部分常用命令</h2><ul>
<li>initdb:初始化PostgreSQL数据库</li>
<li>pg_controldata:显示一个PostgreSQL数据库集群的控制信息</li>
<li>pg_ctl:启动、停止或者控制PostgreSQL服务器</li>
<li>pg_resetxlog:重置一个数据库集群的预写日志以及其它控制内容</li>
<li>postgres:PostgreSQL数据库服务器进程</li>
<li>postmaster:PostgreSQL守护进程<h2 id="1-5-5-PostgreSQL数据库的常用管理工具"><a href="#1-5-5-PostgreSQL数据库的常用管理工具" class="headerlink" title="1.5.5 PostgreSQL数据库的常用管理工具"></a>1.5.5 PostgreSQL数据库的常用管理工具</h2></li>
<li>psql命令行管理工具：psql是一个PostgreSQL内置的客户端工具，该工具使用户通过执行命令以交互式方式实现PostgreSQL数据库管理</li>
<li>pgAdmin图形界面管理工具<h2 id="1-5-6-PostgreSQL数据库主要对象"><a href="#1-5-6-PostgreSQL数据库主要对象" class="headerlink" title="1.5.6 PostgreSQL数据库主要对象"></a>1.5.6 PostgreSQL数据库主要对象</h2></li>
<li>模式对象：一种构成数据库下级逻辑结构的数据库对象，用于按用户或按应用分类组织其它数据库对象</li>
<li>表对象：一种用户组织存储数据的数据库对象，主要有三种类型：<strong>关系表、继承表、外部表</strong></li>
<li>视图对象：一种基于虚拟表操作数据的数据库对象</li>
<li>序列对象：一种为代理键列提供自动增量序列值的数据库对象，提供自动增量序列值的数据库对象</li>
<li>函数对象：一种使用内置编程语言编写数据库访问操作功能程序的数据库对象，PostgreSQL没有单独的存储对象，而是通过函数来实现存储过程功能</li>
<li>触发器对象：一种事件触发、自动执行的数据库访问操作功能程序的数据库对象</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/" rel="tag">数据库原理</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计网课程笔记3"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/08/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03/"
    >计网课程笔记3</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/08/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03/" class="article-date">
  <time datetime="2022-03-08T06:54:04.000Z" itemprop="datePublished">2022-03-08</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%BD%91/">课程笔记_计网</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="依照学校教学安排，第三章为应用层（即网课第五章）"><a href="#依照学校教学安排，第三章为应用层（即网课第五章）" class="headerlink" title="依照学校教学安排，第三章为应用层（即网课第五章）"></a>依照学校教学安排，第三章为应用层（即网课第五章）</h1><h1 id="3-1-运输层协议概述"><a href="#3-1-运输层协议概述" class="headerlink" title="3.1 运输层协议概述"></a>3.1 运输层协议概述</h1><h2 id="3-1-1-进程之间的通信"><a href="#3-1-1-进程之间的通信" class="headerlink" title="3.1.1 进程之间的通信"></a>3.1.1 进程之间的通信</h2><ul>
<li><strong>运输层属于面向通信部分的最高层，同时也是用户功能中的最底层</strong>，运输层向它上面的应用提供通信服务</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到下三层的功能<br><img src="../photos/ComputerNetworkCourse/3_1.png" title="传输过程中各层与进程示意图"></li>
<li><strong>IP协议的作用范围是两个主机之间的所有链路和路由器</strong> <em>（提供主机之间的逻辑通信）</em></li>
<li><strong>运输层协议TCP和UDP的作用范围是从一台主机的某个进程到另一台主机的进程之间</strong> <em>（为相互通信的应用进程提供了逻辑通信）</em></li>
</ul>
<h2 id="3-1-2-运输层的两个主要协议"><a href="#3-1-2-运输层的两个主要协议" class="headerlink" title="3.1.2 运输层的两个主要协议"></a>3.1.2 运输层的两个主要协议</h2><ul>
<li>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信</li>
<li>运输层的两个重要功能：<strong>复用</strong>和<strong>分用</strong></li>
<li>根据应用程序的不同需求，运输层需要有两种不同的运输协议：<strong>面向连接的传输控制协议TCP</strong>和<strong>无连接的用户数据报UDP</strong><h3 id="基于端口的复用和分用功能"><a href="#基于端口的复用和分用功能" class="headerlink" title="基于端口的复用和分用功能"></a>基于端口的复用和分用功能</h3></li>
<li><strong>向下复用和向上分用</strong><ul>
<li>发送方应用层的多个应用进程通过各自端口传入运输层并在运输层中<strong>重复使用</strong>TCP和UDP协议，对应转化为TCP报文段和UDP用户数据报，随后在网络层中<strong>重复使用</strong>IP协议，转换为IP数据报传送至接收方。</li>
<li>接收方在网络层中<strong>分开使用</strong>IP协议，转化为TCP报文段和UDP用户数据报，在运输层中<strong>分开使用</strong>TCP协议和UDP协议，最后通过各自端口发给应用进程<br><img src="../photos/ComputerNetworkCourse/3_2.png" title="基于端口的复用和分用功能示意图"></li>
</ul>
</li>
<li>运输层向高层用户<strong>屏蔽</strong>了下面网络核心的细节，它使应用进程“看见”的仿佛是一条<strong>在两个运输层实体间的端到端的逻辑通信信道</strong>，但这条通信信道对上层的表现却因运输层使用的不同协议而有很大的差别<ul>
<li>当运输层采用<strong>面向连接的TCP协议</strong>时 <em>（对可靠性要求高）</em>，即使下面的网络不可靠，但逻辑通信信道相当于一条<strong>全双工的可靠信道</strong></li>
<li>当运输层采用<strong>无连接的UDP协议</strong>时 <em>（对效率要求高）</em>，这种逻辑通信信道是一条<strong>不可靠信道</strong></li>
</ul>
</li>
<li>TCP和UDP<ul>
<li><strong>运输协议数据单元</strong>：两个对等实体在通信时传送的数据单位</li>
<li><strong>TCP报文段</strong>：TCP传送的运输协议数据单元</li>
<li><strong>UDP报文/用户数据报</strong>：UDP传送的运输协议数据单元</li>
<li><strong>UDP：一种无连接协议</strong><ul>
<li>提供无连接服务</li>
<li><strong>在传输数据之前不需要先建立连接</strong></li>
<li>传送的数据单位是UDP报文/用户数据报</li>
<li>对方的运输层在收到UDP报文后，<strong>不需要给出任何确认</strong></li>
<li>虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式 <em>（因为要求少）</em></li>
</ul>
</li>
<li><strong>TCP：一种面向连接的协议</strong><ul>
<li>提供面向连接的服务</li>
<li>传送的数据单位协议是TCP报文段</li>
<li><strong>TCP不提供广播或多播服务</strong></li>
<li>由于TCP要提供<strong>可靠的、面向连接的运输服务</strong>，因此不可避免地增加了许多的开销，这不仅使数据单元的首部增大很多，还要占用许多的处理机资源</li>
</ul>
</li>
</ul>
</li>
<li>补充：运输层的UDP用户数据报与网际/网络层的IP数据报有很大区别<ul>
<li>IP数据报要经过互连网中许多路由器的存储转发</li>
<li>UDP用户数据报是在运输层的端到端<strong>抽象的</strong>逻辑信道中传送的</li>
</ul>
</li>
</ul>
<h2 id="3-1-3-运输层的端口"><a href="#3-1-3-运输层的端口" class="headerlink" title="3.1.3 运输层的端口"></a>3.1.3 运输层的端口</h2><ul>
<li>运行在计算机中的进程是用<strong>进程标识符</strong>来标识的</li>
<li><strong>运行在应用层的各种应用进程不应当让计算机操作系统指派它的进程标识符</strong>，这是因为互连网上使用的计算机的操作系统种类很多而不同的操作系统又使用不同格式的进程操作符</li>
<li>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须使用<strong>统一的方法</strong>对TCP/IP体系的应用进程进行标识<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3></li>
<li>为了解决不同操作系统下的应用进程在互连网上相互通信时进程标识符不统一的问题，我们在运输层使用<strong>协议端口号/端口</strong></li>
<li>虽然通信的终点是应用进程，但我们可以把端口想象为通信的终点，因为我们只要把统一格式的报文交到目的主机的一个合适的目的端口，剩下交付给进程的过程就交由TCP完成<h3 id="硬件端口与软件端口"><a href="#硬件端口与软件端口" class="headerlink" title="硬件端口与软件端口"></a>硬件端口与软件端口</h3></li>
<li><strong>软件端口</strong>：协议栈层间的抽象的协议端口</li>
<li><strong>硬件端口</strong>：路由器或交换机上的端口</li>
<li>硬件端口是不同硬件设备进行交互的端口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址<h3 id="TCP-IP运输层端口"><a href="#TCP-IP运输层端口" class="headerlink" title="TCP/IP运输层端口"></a>TCP/IP运输层端口</h3></li>
<li>端口用一个16位端口号进行标志 <em>（意味着最多可以有2的16次方个软件端口）</em></li>
<li>端口号只具有本地意义 <em>（两个主机的端口号可以相同）</em>，即端口号只是为了标识<strong>本计算机应用层中的各进程</strong></li>
<li>在互连网中，不同计算机的相同端口号是没有联系的</li>
<li>两个计算机中的进程要互相通信，不仅必须知道对方的IP地址 <em>（找计算机）</em>，而且还要知道对方的端口号 <em>（找进程）</em><h3 id="两大类端口"><a href="#两大类端口" class="headerlink" title="两大类端口"></a>两大类端口</h3></li>
<li><strong>服务器端使用的端口号</strong><ul>
<li>熟知端口：一般为1-1023</li>
<li>登记端口号：为1024-49151，供没有熟知端口号的应用程序使用的，使用这个范围的端口号必须在互联网数字分配机构IANA登记以防止重复</li>
</ul>
</li>
<li><strong>客户端使用的端口号</strong><ul>
<li>又称短暂端口号，为49152-65535，留给客户进程选择暂时使用</li>
<li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号，通信结束后这个端口号可供其他客户进程以后使用<br><img src="../photos/ComputerNetworkCourse/3_3.png" title="常用的熟知端口"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-2-用户数据报协议UDP"><a href="#3-2-用户数据报协议UDP" class="headerlink" title="3.2 用户数据报协议UDP"></a>3.2 用户数据报协议UDP</h1><h2 id="3-2-1-UDP概述"><a href="#3-2-1-UDP概述" class="headerlink" title="3.2.1 UDP概述"></a>3.2.1 UDP概述</h2><ul>
<li>UDP只在IP的数据报服务之上增加了一点功能：<ul>
<li>复用和分用的功能</li>
<li>差错检测的功能</li>
</ul>
</li>
<li>虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有特殊的优点</li>
<li>UDP的主要特点<ul>
<li><strong>UDP是无连接的</strong>：发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延</li>
<li><strong>UDP使用尽最大努力交付</strong>：UDP的尽最大努力是在IP的基础上的，即不保证可靠交付，因此主机不需要维持复杂的连接状态表</li>
<li><strong>UDP是面向报文的</strong><ul>
<li>发送方UDP对应用层交下来的报文，在添加首部后就向下交付IP层，<strong>既不合并，也不拆分</strong>，而是保留这些报文的边界</li>
<li>发送时应用层交给UDP多长的报文，UDP就照样发送，<strong>一次发送一个完整的报文</strong></li>
<li>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，<strong>一次交付一个完整的报文</strong></li>
<li>应用程序必须选择合适大小的报文<ul>
<li>若报文太长，UDP交给IP层后在传输时可能要进行<strong>分片</strong>，这会<strong>降低IP层的效率</strong></li>
<li>若报文太短，UDP交给IP层后在传输时IP数据报中<strong>首部的相对长度太大</strong>，这会<strong>降低IP层的效率</strong></li>
</ul>
</li>
<li>UDP发送的报文长度是应用进程给出的</li>
</ul>
</li>
<li><strong>UDP没有拥塞控制</strong>：：由于UDP不用实现可靠传送网络出现额拥塞不会使源主机发送速率降低，这对某些实时应用很重要，很适合多媒体通信的要求</li>
<li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong></li>
<li><strong>UDP的首部开销小</strong>：只有8字节，比TCP20个字节的首部要短，<strong>同时也意味着UDP的功能比TCP少</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-2-UDP的首部格式"><a href="#3-2-2-UDP的首部格式" class="headerlink" title="3.2.2 UDP的首部格式"></a>3.2.2 UDP的首部格式</h2><ul>
<li>UDP用户数据报有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>，首部字段只有8个字节</li>
<li>8个字节的首部构成：<strong>源端口(2字节)+目的端口(2字节)+数据长度(伪首部+有效数据的字节长度)(2字节)+校验和(2字节)</strong></li>
<li>12个字节的伪首部 <em>（不占报文的地址空间，但在计算校验和的时候会临时把伪首部和UDP用户数据报连接在一起）</em>构成：<strong>源IP地址(4字节)+目的IP地址(4字节)+8位全0(1字节)+8位协议（17）(1字节)+UDP长度(2字节)</strong></li>
<li><strong>UDP校验和的计算</strong>：将数据报空余的部分填0，将伪首部、首部、数据以一字节为一段，两字节为一行从上到下排列，进行加法计算，产生的进位溢出加到结果的末位，然后将结果取反即得到校验和。<br><img src="../photos/ComputerNetworkCourse/3_4.png" title="UDP首部、伪首部构成示意图"><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/roccoshi/p/13033014.html">UDP校验和计算教程</a></li>
</ul>
<hr>
<h1 id="3-3-传输控制协议TCP概述"><a href="#3-3-传输控制协议TCP概述" class="headerlink" title="3.3 传输控制协议TCP概述"></a>3.3 传输控制协议TCP概述</h1><h2 id="3-3-1-TCP最主要的特点"><a href="#3-3-1-TCP最主要的特点" class="headerlink" title="3.3.1 TCP最主要的特点"></a>3.3.1 TCP最主要的特点</h2><ul>
<li><strong>TCP是面向连接的运输层协议</strong>：先建立连接再传输</li>
<li>每一条TCP连接<strong>只能有两个端点</strong>，每一条TCP连接<strong>只能是点对点的、一对一的</strong></li>
<li>TCP提供<strong>可靠交付</strong>的服务：不重复、不丢失、不失序</li>
<li>TCP提供<strong>全双工通信</strong>：双方都可以发送和接收</li>
<li><strong>面向字节流</strong><ul>
<li>TCP中的“流”指的是流入或流出进程的字节序列</li>
<li>“面向字节流”的含义：虽然应用程序和TCP的交互时一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流</li>
<li>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，但接收方接收到的字节流必须和发送方应用程序发出的字节流完全一样：<strong>TCP不管你数据怎么分的块，但要求数据内容必须是一样的</strong></li>
<li>TCP不关心应用进程一次把多长的报文发送到TCP缓存</li>
<li>TCP对连续的字节流进行分段，形成TCP报文段，但<strong>分段是不定的</strong>，TCP<strong>根据对方给出的窗口值和当前网络拥塞的程度</strong>来决定一个报文段应包含多少字节</li>
</ul>
</li>
<li><strong>注意</strong>，TCP连接是运输层间的<strong>需连接</strong>，是逻辑上的通信信道<br><img src="../photos/ComputerNetworkCourse/3_5.png" title="TCP字节流发送、传输示意图"><h2 id="3-3-2-TCP的连接"><a href="#3-3-2-TCP的连接" class="headerlink" title="3.3.2 TCP的连接"></a>3.3.2 TCP的连接</h2></li>
<li>TCP把连接作为<strong>最基本的工作/功能的抽象</strong>：所有的工作都要以连接建立为根本前提</li>
<li>每一条TCP连接<strong>有两个端点</strong></li>
<li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议接口，<strong>TCP连接的端点叫做套接字或插口</strong></li>
<li><strong>套接字就是IP后面加上端口号</strong>，socket=（ip地址：端口号），每一条TCP连接唯一地被通信两端的两个套接字所确定 TCP连接={socket1，socket2}={(ip:port1),(ip:port2)}</li>
<li>同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中</li>
</ul>
<hr>
<h1 id="3-4-可靠传输的工作原理"><a href="#3-4-可靠传输的工作原理" class="headerlink" title="3.4 可靠传输的工作原理"></a>3.4 可靠传输的工作原理</h1><h2 id="3-4-1-停止等待协议"><a href="#3-4-1-停止等待协议" class="headerlink" title="3.4.1 停止等待协议"></a>3.4.1 停止等待协议</h2><h3 id="理想的传输条件有两个特点"><a href="#理想的传输条件有两个特点" class="headerlink" title="理想的传输条件有两个特点"></a>理想的传输条件有两个特点</h3><ul>
<li>传输信道不产生差错</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</li>
</ul>
<p><strong>然而实际的网络都不具备以上两个理想条件</strong>，故必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输</p>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul>
<li>“停止等待”的思路：每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li>
<li><strong>全双工通信的双方既是发送方也是接收方</strong> <em>（发送/接收数据和确认）</em></li>
</ul>
<h3 id="传输情况"><a href="#传输情况" class="headerlink" title="传输情况"></a>传输情况</h3><ul>
<li>无差错情况：A向B发送组1，发完暂停发送，等待B接收组1并传回确认后再发送组2</li>
<li>接收方B出现差错情况<ul>
<li>第一种：B接收组1时出现了差错，就丢弃组1，其它什么也不做（不传回确认）</li>
<li>第二种：组1在传输过程中丢失了，B当然什么都不知道，因此也什么都不做</li>
<li>在这两种情况下，B都不会发送信息</li>
</ul>
</li>
<li>确认出现差错情况：确认信息在传输过程中丢失了</li>
<li>解决方案：超时重传<ul>
<li>A为每个已经发送的组都设置了一个<strong>超时计时器</strong></li>
<li>A只要在超时计时器到期之前收到了确认就撤销该超时计时器，继续发送组2</li>
<li>如果超时计时器到期，就重新发送组1</li>
<li>由此可见<strong>传输过程中的问题都由发送方解决</strong></li>
</ul>
</li>
</ul>
<h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><ul>
<li>确认丢失<ul>
<li>若B所发送的对M1的确认丢失了，那么A在设定的超时重传时间内不能收到确认，但A无法知道是上述三种情况的哪种，因此<strong>A在超时计时器到期后就要重传组1</strong></li>
<li>假定B又收到了重传的组1（即确认信息丢失），此时B要采取两个行动<ul>
<li>丢弃这个重复的组1，不向上层交付</li>
<li>向A发送确认：就算给A发送过确认信息也要再发送，正是因为A没有收到确认信息所以才重发组1</li>
</ul>
</li>
</ul>
</li>
<li>确认迟到<ul>
<li>若B所发送的对组1的确认传到A的时间过长（在超时计时器到期后送达），则A将重新发送组1，以第二次发送组1收到的确认和第一次发送收到的确认中较早者为时间点发送组2，第二次收到的对组1确认将丢弃</li>
</ul>
</li>
<li><strong>注意</strong><ul>
<li>在发送完一个分组后，必须暂时保留已发送的分组的副本已备重发</li>
<li><strong>分组和确认分组都必须进行编号</strong></li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间<strong>更长一些</strong>，以减少重发次数<h2 id="3-4-2-连续ARQ协议"><a href="#3-4-2-连续ARQ协议" class="headerlink" title="3.4.2 连续ARQ协议"></a>3.4.2 连续ARQ协议</h2></li>
</ul>
</li>
<li><strong>通常A最终总是可以收到对所有发出的分组的确认</strong>，如果A不断重发却收不到确认，则说明通信线路太差，不能进行通信</li>
<li><strong>使用停止等待协议的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信</strong></li>
<li>像上述的这种可靠传输协议常称为<strong>自动重传请求ARQ</strong>,即重传请求是自动进行的，不需要接收方发送重传请求</li>
</ul>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><ul>
<li><strong>停止等待协议的优点是简单，缺点是信道利用率太低</strong></li>
<li>设分组发送所需时间为Td，确认发送所需时间为Ta（均不包含传送时间），两者的传送时间与分组确认接收时间总和为RTT，则信道利用率<strong>U=Td/(Td+RTT+Ta)</strong></li>
<li>可以看出，当往返时间RTT远大于分组发送时间Td时，信道的利用率就会非常低，若出现重传，则对传送有用的数据信息而言，信道的利用率还要降低、</li>
</ul>
<h3 id="连续ARQ协议-流水线传输"><a href="#连续ARQ协议-流水线传输" class="headerlink" title="连续ARQ协议/流水线传输"></a>连续ARQ协议/流水线传输</h3><ul>
<li>为了提高传输效率，发送方采用流水线传输</li>
<li>流水线传输就是发送方<strong>可连续发送多个分组，不必每发完一个分组就停下来等待对方确认</strong>，这样可以使信道上一直有数据不间断地传送</li>
<li>由于信道上一直有数据不间断地传送，这种传输方式可以获得很高的信道利用率</li>
<li><strong>仍然需要设置超时计时器</strong></li>
<li><strong>滑动窗口协议比较复杂，是TCP协议的精髓所在</strong><ul>
<li>发送方维持的<strong>发送窗口</strong>：位于发送窗口内的分组都可连续发送出去而不需要等待对方的确认</li>
<li>连续ARQ协议规定，<strong>发送方每收到一个确认，就把发送窗口（缓存中的一块区域）向前滑动一个分组的位置</strong><br><img src="../photos/ComputerNetworkCourse/3_6.png" title="连续ARQ协议发送窗口工作原理示意图"></li>
</ul>
</li>
</ul>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><ul>
<li>接收方一般采用<strong>累计确认</strong>的方式，即不必对收到的分组逐个发送确认，而是对<strong>按序到达的最后一个分组发送确认</strong>，表示到这个分组之前的所有分组都已经正确收到了</li>
<li>优点：容易实现，即使确认丢失也不必重传</li>
<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息</li>
<li>对于缺点的补充：<strong>Go-back-N(回退N)</strong><ul>
<li>如果发送方发送了x个分组，而其中第N个分组丢失了，此时接收方只能对<strong>第N个分组之前的所有分组发出确认</strong>，发送方无法得知第N个分组后其他分组的接收情况，只能<strong>将从第N个分组起的所有分组重新发送</strong>，即<strong>表示需要再退回来重传已发送过的分组</strong></li>
<li>可见当通信信道质量不好时，连续ARQ协议会带来不好的影响</li>
</ul>
</li>
</ul>
<h3 id="TCP可靠通信的具体实现"><a href="#TCP可靠通信的具体实现" class="headerlink" title="TCP可靠通信的具体实现"></a>TCP可靠通信的具体实现</h3><ul>
<li><strong>TCP连接的每一端都必须设有一个发送窗口和一个接收窗口</strong></li>
<li>TCP的可靠传输机制用字节的序号进行控制，TCP所有的确认都是基于序号而不是基于报文</li>
<li>TCP两端的四个窗口经常处于<strong>动态变化</strong>之中</li>
<li>TCP连接的往返时间RTT也不是固定不变的，需要使用特定的算法估算较为合理的时间</li>
</ul>
<hr>
<h1 id="3-5-TCP报文段的首部格式"><a href="#3-5-TCP报文段的首部格式" class="headerlink" title="3.5 TCP报文段的首部格式"></a>3.5 TCP报文段的首部格式</h1><ul>
<li>TCP虽然是面向字节流的，但TCP传送的数据单元确是报文段</li>
<li>一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中各字段的作用</li>
<li>TCP报文段首部的前20个字节是固定的，后面有4n（n为自然数）字节是根据需要而增加的选项，因此**TCP首部的最小长度是20字节)<br><img src="../photos/ComputerNetworkCourse/3_7.png" title="TCP首部格式示意图"></li>
<li>源端口和目的端口字段各占2字节，端口是运输层和应用层的服务接口，运输层的复用和分用功能都要通过端口才能实现</li>
<li>序号字段占4字节，TCP连接传送的数据流中的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的编号</li>
<li>确认号字段占4字节，是期望收到对方的下一个报文段的数据的第一个字节的编号</li>
<li>数据偏移（即首部长度）占4位，它指出TCP报文段的<strong>数据起始处</strong>距离TCP报文段的起始处有多远，数据偏移的单位是32位字（以4字节为计算单位）</li>
<li>保留字段占6位，保留为今后使用，但目前应置为0</li>
<li>六个标志位占六位<ul>
<li>紧急URG：当URG=1时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送</li>
<li>确认ACK：当ACK=1时，确认号字段有效，0则无效</li>
<li>推送PSH：当PSH=1时，就尽快的交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</li>
<li>复位RST：当RST=1时，表明TCP连接中出现严重差错（如主机崩溃），必须释放连接，然后再重新建立运输连接</li>
<li>同步SYN：SYN=1表明这是一个连接请求或连接接受报文（确认连接）</li>
<li>终止FIN：用于释放连接，FIN=1表示此报文段的发送端的数据已发送完毕，并要求释放运输连接</li>
</ul>
</li>
<li>窗口字段占2字节，用来让对方设置发送窗口的依据 <em>（告诉对方自己的接收窗口的大小）</em>，单位为字节</li>
<li>校验和占2字节，检验和字段检验的范围包括首部和数据两部分，计算检验和具体见3.2.2</li>
<li>紧急指针字段占2字节，指出在本报文段中紧急数据有多少个字节 *（紧急数据放在本报文段数据的最前面）</li>
<li>选项字段：长度可变。TCP最初只规定了一种选项，即<strong>最大报文段长度MSS</strong>，MSS高速对方TCP己方缓存能接收的报文段的数据字段（TCP报文段长度减去TCP首部长度）的最大长度是多少字节，字节数存储在MSS中。其他选项如下：<ul>
<li>窗口扩大选项占3字节，其中有一个字节表示移位S，新的2窗口值等于TCP首部中的窗口位数增大到16+S，相当于把窗口值向左移动S位后获得的实际的窗口大小</li>
<li>时间戳选项占10字节，其中最主要的字段<strong>时间戳值字段</strong>占4字节，<strong>时间戳回送回答字段</strong>占4字节</li>
<li>选择确认选项，见3.6.3</li>
</ul>
</li>
<li>规定MSS的原因<ul>
<li>MSS与接收窗口值没有关系</li>
<li><strong>若选择较小的MSS长度，网络的利用率就降低</strong>，因为TCP报文段越少，首部占比就越大，传输效率就越低，开销就显得大</li>
<li><strong>若TCP报文段很长，会使得开销增大</strong>，在IP层传输时就有可能要分解成多个端数据报片，在终点要把收到的各个短数据报片装配成原来的TCP报文段，当传输出错时还要进行重传，进而增大开销</li>
<li>综上，<strong>MSS应尽可能大些，只要在IP层传输时不需要再分片就行</strong></li>
<li>由于IP数据报的路径是动态变化的，因此在这条路径上确定的不需要分片的MSS，如果改走另一条路径就可能需要进行分片</li>
<li>综上，<strong>最佳的MSS很难确定</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-6-TCP可靠传输的实现"><a href="#3-6-TCP可靠传输的实现" class="headerlink" title="3.6 TCP可靠传输的实现"></a>3.6 TCP可靠传输的实现</h1><h2 id="3-6-1-以字节为单位的滑动窗口"><a href="#3-6-1-以字节为单位的滑动窗口" class="headerlink" title="3.6.1 以字节为单位的滑动窗口"></a>3.6.1 以字节为单位的滑动窗口</h2><ul>
<li>TCP的滑动窗口是以字节为单位的</li>
<li>先假定A收到了B发来的确认报文段，其中窗口（接收能力）是20字节，而确认号（下一个报文段开头的序号）是31（表明序号30为止的数据已经收到了），根据窗口和确认号，A就构造出自己的发送窗口。<ul>
<li>发送窗口表示：<strong>在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去</strong></li>
<li>发送窗口里面的序号表示允许发送的序号</li>
<li>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率</li>
<li><strong>TCP标准强烈不赞成发送窗口前沿向后收缩</strong><br><img src="../photos/ComputerNetworkCourse/3_8.png" title="发送窗口示意图"></li>
</ul>
</li>
<li>发送时遇到字节未按序收到的解决方案<ul>
<li>当一部分字节未收到确认时，重新从未收到字节中序号最靠前的那个字节开始重新发送</li>
<li>若发送窗口内的序号都已用完但还没有收到确认，必须停止发送 <em>（不再发送后续字节）</em></li>
</ul>
</li>
<li>发送方的应用进程把字节流写入TCP的发送缓存，发送缓存一般都比发送窗口大<br><img src="../photos/ComputerNetworkCourse/3_9.png" title="发送缓存、发送窗口关系示意图"></li>
<li>接收方的应用进程从TCP的接收缓存中读取字节流，接收缓存一般都比接收窗口大<br><img src="../photos/ComputerNetworkCourse/3_10.png" title="接收缓存、接收窗口关系示意图"></li>
<li><strong>需要注意</strong><ul>
<li>A的发送窗口并不总是和B的接收窗口一样大（因为有一定的时间滞后）</li>
<li>TCP标准没有规定对不按序到达的数据如何处理，通常是先临时放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li>
<li>TCP要求接收方必须有累计确认的功能，这样可以减少传输开销<h3 id="接收方发送确认"><a href="#接收方发送确认" class="headerlink" title="接收方发送确认"></a>接收方发送确认</h3></li>
</ul>
</li>
<li>接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上</li>
<li><strong>需要注意</strong>：<ul>
<li>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，浪费了网络的资源</li>
<li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据<h2 id="3-6-2-超时重传时间的选择"><a href="#3-6-2-超时重传时间的选择" class="headerlink" title="3.6.2 超时重传时间的选择"></a>3.6.2 超时重传时间的选择</h2></li>
</ul>
</li>
<li>重传机制是TCP中最重要和最复杂的问题之一</li>
<li>TCP每发送一个报文段，就对这个报文段设置一次计时器</li>
<li>只要计时器设置的重传时间已到但还没有收到确认，就要重传这一报文段</li>
<li><strong>重传时间的选择是TCP最复杂的问题之一</strong><ul>
<li>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大</li>
<li>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率</li>
</ul>
</li>
<li><strong>TCP采用了一种自适应算法</strong>，它记录一个报文段发出的时间，以及收到相应的确认的时间，这两个时间之差就是报文段的往返时间RTT</li>
<li><strong>往返时延的方差很大</strong>:由于TCP的下层是一个互联网环境，IP数据报所选择的路由变化很大，因而运输层的往返时间的方差也很大<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间"></a>加权平均往返时间</h3></li>
<li>TCP保留了RTT的一个加权平均往返时间RTT<sub>S</sub>（这又称为<strong>平滑的往返时间</strong>）</li>
<li>第一次测量到RTT样本时，RTT<sub>S</sub>值就取为所测量到的RTT样本值，以后每测量到一个新的RTT样本，就按下式重新计算一次RTT<sub>S</sub><br><img src="../photos/ComputerNetworkCourse/3_11.png" title="RTT&lt;sub&gt;S&lt;/sub&gt;迭代计算公式"></li>
<li>其中，0≤α≤1，若α很接近于0，表示RTT值更新较慢，若α接近于1，则表示RTT更新较快</li>
<li>RFC2988推荐的α值为0.125<h3 id="超时重传时间"><a href="#超时重传时间" class="headerlink" title="超时重传时间"></a>超时重传时间</h3></li>
<li><strong>RTO应略大于上面得出的加权平均往返时间RTT<sub>S</sub></strong></li>
<li>RFC2988建议使用<strong>RTO=RTT<sub>S</sub>+4xRTT<sub>D</sub><strong>计算RTO，其中RTT<sub>D</sub>是</strong>RTT的偏差的加权平均值</strong></li>
<li>RFC2988计算RTT<sub>D</sub>的计算方法：第一次测量时，RTT<sub>D</sub>值取为测量到的RTT样本值的一半，在以后的测量中，使用下式计算加权平均的RTT<sub>D</sub><br><img src="../photos/ComputerNetworkCourse/3_12.png" title="RTT&lt;sub&gt;D&lt;/sub&gt;迭代计算公式"></li>
<li>其中β是一个小于1的系数，推荐值为0.25<h3 id="往返时间RTT的测量相当复杂"><a href="#往返时间RTT的测量相当复杂" class="headerlink" title="往返时间RTT的测量相当复杂"></a>往返时间RTT的测量相当复杂</h3></li>
<li>问题描述：TCP报文段1没有收到确认，重传后收到了确认报文段ACK，<strong>如何判定ACK是对第一次发出的报文段的确认还是对重传的报文段的确认？</strong></li>
<li>解决方案：Karn算法<ul>
<li>思想：<strong>在计算平均往返时间RTT时，只要报文段重传了就不采用其往返时间样本</strong></li>
<li>优点：得出的加权平均往返时间RTT<sub>S</sub>和超时重传时间RTO就比较准确</li>
<li>缺点：当报文段的时延突然增大很多时，在原来得出的重传时间内不会收到确认报文段，导致需要重传的报文段占比增加，但根据Karn算法，这些报文段的往返时间样本将不予考虑，因此导致<strong>超时重传时间无法更新</strong></li>
<li><strong>修正的Karn算法</strong><ul>
<li>报文段每重传一次，就把RTO增大一些：<strong>新RTO=γx旧的RTO</strong></li>
<li>其中γ的典型值是2</li>
<li>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延RTT和超时重传时间RTO的数值</li>
<li>实践证明，这种策略较为合理<h2 id="3-6-3-选择确认SACK"><a href="#3-6-3-选择确认SACK" class="headerlink" title="3.6.3 选择确认SACK"></a>3.6.3 选择确认SACK</h2></li>
</ul>
</li>
</ul>
</li>
<li>针对的问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么<strong>能否设法只传送缺少的数据而不重传已经准确到达接收方的数据？</strong></li>
<li>接收方收到和前面字节流不连续的两个字节块，如果这些字节的序号都在接收窗口内，那么接收方就先收下这些数据，但**要把这些信息准确地高速发送方，使发送方不要再重复发送这些已收到的数据<h3 id="RFC2018的规定"><a href="#RFC2018的规定" class="headerlink" title="RFC2018的规定"></a>RFC2018的规定</h3></li>
<li>如果要使用SACK，那么在建立TCP连接时，就要在TCP首部的选项中加上“允许SACK”的选项，而双方都必须事先商定好</li>
<li>如果使用SACK，那么原来首部中的确认号字段的用法仍然不变，只是以后在TCP报文段的首部中都增加了SACK选项，以便报告收到的不连续的字节块的边界</li>
<li>由于首部选项的长度最多只有40字节，而指明一个边界就要用到4字节，因此在选项中<strong>最多只能指明4个字节块的边界信息</strong> </li>
</ul>
<hr>
<h1 id="3-7-TCP的流量控制"><a href="#3-7-TCP的流量控制" class="headerlink" title="3.7 TCP的流量控制"></a>3.7 TCP的流量控制</h1><h2 id="3-7-1-利用滑动窗口实现流量控制"><a href="#3-7-1-利用滑动窗口实现流量控制" class="headerlink" title="3.7.1 利用滑动窗口实现流量控制"></a>3.7.1 利用滑动窗口实现流量控制</h2><h2 id="3-7-2-TCP的传输效率"><a href="#3-7-2-TCP的传输效率" class="headerlink" title="3.7.2 TCP的传输效率"></a>3.7.2 TCP的传输效率</h2><hr>
<h1 id="3-8-TCP的拥塞控制"><a href="#3-8-TCP的拥塞控制" class="headerlink" title="3.8 TCP的拥塞控制"></a>3.8 TCP的拥塞控制</h1><hr>
<h1 id="3-9-TCP的运输连接管理"><a href="#3-9-TCP的运输连接管理" class="headerlink" title="3.9 TCP的运输连接管理"></a>3.9 TCP的运输连接管理</h1><hr>
<h1 id="3-10-补充"><a href="#3-10-补充" class="headerlink" title="3.10 补充"></a>3.10 补充</h1><ul>
<li>使用TCP的网络应用：HTTP\FTP\TELNET\SMTP</li>
<li>使用UDP的网络应用：流媒体\视频会议\DNS\Internet电话</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-需求文档"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/06/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/"
    >需求文档(v4.1)</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/06/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/" class="article-date">
  <time datetime="2022-03-06T08:32:17.000Z" itemprop="datePublished">2022-03-06</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <p><strong>截止日期：4.21号</strong><br><strong>统一Unity版本:2020.3</strong></p>
<h1 id="效果预期"><a href="#效果预期" class="headerlink" title="效果预期"></a>效果预期</h1><h2 id="三个场景"><a href="#三个场景" class="headerlink" title="三个场景"></a><strong>三个场景</strong></h2><ul>
<li><strong>主页面（标题，选择场景，制作名单）</strong></li>
<li><strong>游戏场景1：石碑刻字</strong><ul>
<li>石碑的场景是一个碑林，可以搭一个园林</li>
<li>有不同的碑文供临摹</li>
<li>临摹的过程是玩家手拿凿子去刻</li>
<li>玩家可随时查看作品的效果</li>
<li>给玩家提供碑文的介绍查阅</li>
</ul>
</li>
<li><strong>游戏场景2：猜灯谜</strong><ul>
<li>猜灯谜的场景最好是一个古代夜市（限制玩家移动范围）或者是一个封闭的游戏室</li>
<li>有不同的灯谜</li>
<li>玩家拼灯谜里的字<ul>
<li>拼字思路：每个字有一个数组，数组元素从第一个到最后一个均为各自对应笔画的个数，这样谜底的每个字都有独立编号，你往填字页面扔笔画组件，对应的数组元素内容++</li>
<li>拼字UI思路：有一个页面，玩家<strong>一个一个地拼</strong>页面上显示上述数组的一个表格，让玩家看到自己在当前字放了哪些笔画，然后有确定键，重来键，<strong>确定键提交全部字，重来键清空当前字</strong>。</li>
</ul>
</li>
<li>有一个能旋转的跑马灯，每切换一次题目就转一下（从慢到快再从快到慢最后停下）</li>
</ul>
</li>
<li><strong>其他</strong><ul>
<li>所有场景都提供到另外两个场景的选项</li>
</ul>
</li>
</ul>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="模型、美术素材"><a href="#模型、美术素材" class="headerlink" title="模型、美术素材"></a>模型、美术素材</h2><ul>
<li><strong>主页面</strong><ul>
<li>标题：书刀梦</li>
<li>标题字体 <strong>（已解决）</strong></li>
<li>主页面演出效果：搭一个夜市场景 <strong>（已解决）</strong></li>
</ul>
</li>
<li><strong>游戏场景1</strong><ul>
<li>石碑模型 <strong>（已解决）</strong></li>
<li>树林模型 <strong>（已解决）</strong></li>
<li>凿子模型 <strong>（已解决）</strong></li>
<li>石碑的材质（类似雪地但需要多刻一会才能留痕迹，同时要控制笔画的最大深度）<strong>（已解决）</strong></li>
<li>几张碑帖的高清图 <strong>（已解决）</strong></li>
<li>换一个天空盒 <strong>（已解决）</strong></li>
</ul>
</li>
<li><strong>游戏场景2</strong><ul>
<li>古代夜市场景，建筑素材 <strong>（已解决）</strong></li>
<li>水面（正在解决）</li>
<li>由于是夜市，所以需要适合的光照（这个的调整可能需要一定时间，所以越早确定场景2的具体内容越好）<strong>（已解决）</strong></li>
<li>灯笼模型（最好是跑马灯的样子和功能，能在上面贴几张古画更好）<strong>（已撤销方案）</strong><ul>
<li>灯笼分件建模，</li>
<li>画贴图，灯笼架子一套贴图灯笼上透光的纸要做另一套贴图 </li>
<li>贴图交由美工自由发挥</li>
</ul>
</li>
<li>选笔画的时候出一个选字页面，有几个按钮，按钮的外观是各个笔画的sprite，按一个按钮，就在旁边的一个盘子或者地上生成相应笔画，然后让玩家捡起来放到指定位置。</li>
<li>字体（暂定华文隶书）</li>
<li>笔画（思路是二维的笔画进行y轴上的拉伸得到柱体），<strong>这个等灯谜确定后我把需要拆分成组件的字发到群里然后做</strong>。</li>
</ul>
</li>
</ul>
<h2 id="玩家的功能"><a href="#玩家的功能" class="headerlink" title="玩家的功能"></a>玩家的功能</h2><ul>
<li>移动</li>
<li>旋转视角</li>
<li>拾取</li>
<li>刻字</li>
<li>UI交互</li>
</ul>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li>主页面需要提供选关页面/按键，标题（UI界面布局在群里）</li>
<li>弹窗显示信息（游戏场景1的碑文介绍功能要用到）</li>
<li>游戏场景1内需要提供让玩家控制弹窗（开启或关闭）、音量调整、碑文图片显示（开启或关闭）的UI</li>
</ul>
<h1 id="目前需要解决（想到的）的问题"><a href="#目前需要解决（想到的）的问题" class="headerlink" title="目前需要解决（想到的）的问题"></a>目前需要解决（<del>想到的</del>）的问题</h1><ul>
<li>游戏标题 <strong>（已解决）</strong></li>
<li>刻字效果的实现 <strong>（已解决）</strong></li>
<li>UI交互还未完全实现</li>
<li>美术素材：灯笼、标题字体、笔画模型<strong>（解决中）</strong></li>
<li>场景的具体内容 <strong>（解决中）</strong></li>
</ul>
<h1 id="目前需要关注的"><a href="#目前需要关注的" class="headerlink" title="目前需要关注的"></a>目前需要关注的</h1><ul>
<li>报名</li>
<li>PPT</li>
<li>学学剪映</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VR/" rel="tag">VR</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E8%AE%BE/" rel="tag">计设</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-VR开发日记1"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/03/03/VR%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B01/"
    >UnityVR学习笔记1：准备工作</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/03/03/VR%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B01/" class="article-date">
  <time datetime="2022-03-03T09:59:39.000Z" itemprop="datePublished">2022-03-03</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/Unity/">Unity</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.youtube.com/c/ValemVR">原视频作者主页</a><br><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">搬运链接</a><br>本文仅供个人学习和知识点记录用。<br>使用设备：Oculus Rift S<br>Unity版本：2020.3.30f1c1</p>
<hr>
<h1 id="Unity内的准备工作"><a href="#Unity内的准备工作" class="headerlink" title="Unity内的准备工作"></a>Unity内的准备工作</h1><p><strong>需要安装的</strong></p>
<ul>
<li>Window-&gt;Package Manager-&gt;XR Interaction Tookit</li>
<li>Edit-&gt;Project Settings-&gt;XR Plugin Management</li>
</ul>
<p><strong>需要设置的</strong><br>Edit-&gt;Project Settings-&gt;XR Plugin Management<br><img src="../photos/Unity/VR/1_1.png"><br><img src="../photos/Unity/VR/1_2.png"></p>
<h2 id="玩家的设置"><a href="#玩家的设置" class="headerlink" title="玩家的设置"></a>玩家的设置</h2><p><strong>玩家内容</strong><br><img src="../photos/Unity/VR/1_3.png" title="玩家内容"><br><strong>玩家组件</strong><br><img src="../photos/Unity/VR/1_4.png" title="玩家组件"><br><strong>相机设置</strong><br><img src="../photos/Unity/VR/1_5.png" title="相机设置"><br><strong>左手柄组件内容</strong><br><img src="../photos/Unity/VR/1_6.png" title="左手柄组件内容"><br><strong>右手传输射线设置</strong><br>Axis To Press Threshold用于设置阈值，当按的深度/力度超过这个阈值即触发传送<br><img src="../photos/Unity/VR/1_7.png" title="右手传输射线设置"></p>
<h1 id="备忘录——一些随便写的注释"><a href="#备忘录——一些随便写的注释" class="headerlink" title="备忘录——一些随便写的注释"></a>备忘录——一些随便写的注释</h1><ul>
<li>teleportation area和teleportation anchor的区别：前者是能传送到平面上任意一点，后者是只能传送到它的组件”Anchor”（锚点）的位置。</li>
<li>如果要使得某些物体不能和射线交互，要在<strong>Teleport Ray</strong>下的<strong>XR Ray Interactor</strong>内的<strong>Interaction Layer Mask</strong>里勾掉这些物体的Layer，一般的做法是专门新建一个被设定不能与射线交互的Layer便于管理。</li>
<li>传送射线的设置在XR Ray Interactor里，更改交互事件在Audio Events和Haptic Events里，勾选后弹出，Duration为持续时间，Intensity是强度</li>
</ul>
 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Unity/" rel="tag">Unity</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/VR/" rel="tag">VR</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
    <article
  id="post-计网课程笔记2"
  class="article article-type-post"
  itemscope
  itemprop="blogPost"
  data-scroll-reveal
>
  <div class="article-inner">
    
    <header class="article-header">
       
<h2 itemprop="name">
  <a class="article-title" href="/2022/02/25/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02/"
    >计网课程笔记2</a> 
</h2>
 

      
    </header>
     
    <div class="article-meta">
      <a href="/2022/02/25/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02/" class="article-date">
  <time datetime="2022-02-25T11:20:26.000Z" itemprop="datePublished">2022-02-25</time>
</a> 
  <div class="article-category">
    <a class="article-category-link" href="/categories/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0-%E8%AE%A1%E7%BD%91/">课程笔记_计网</a>
  </div>
   
    </div>
      
    <div class="article-entry" itemprop="articleBody">
       
  <h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="依照学校教学安排，第二章为应用层（即网课第六章）"><a href="#依照学校教学安排，第二章为应用层（即网课第六章）" class="headerlink" title="依照学校教学安排，第二章为应用层（即网课第六章）"></a>依照学校教学安排，第二章为应用层（即网课第六章）</h1><h1 id="应用层协议的特点"><a href="#应用层协议的特点" class="headerlink" title="应用层协议的特点"></a>应用层协议的特点</h1><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决是通过位于不同主机中的多个应用之间的通信和协同工作来完成的，应用层的具体内容就是规定应用进程在通信时所遵循的协议。<br><strong>应用层的许多协议都是基于客户服务器方式</strong>，客户和服务器均为通信中所涉及的两个<strong>应用进程</strong>，客户服务器方式描述的是<strong>进程之间服务与被服务的关系</strong></p>
<h1 id="2-1-域名系统DNS"><a href="#2-1-域名系统DNS" class="headerlink" title="2.1 域名系统DNS"></a>2.1 域名系统DNS</h1><h2 id="2-1-1-什么是DNS"><a href="#2-1-1-什么是DNS" class="headerlink" title="2.1.1 什么是DNS"></a>2.1.1 什么是DNS</h2><ul>
<li><strong>域名系统</strong>：是互联网的一项服务，它是<strong>将域名和IP地址相互映射的一个分布式数据库</strong>，使人更容易地访问互联网、记忆网址</li>
<li>互联网采用层次结构的命名树作为主机的名字</li>
<li><strong>域名服务器</strong>：运行<strong>名字到IP地址的解析程序</strong>的机器，域名服务器程序在专设的结点上运行<h2 id="2-1-2-互联网的域名结构"><a href="#2-1-2-互联网的域名结构" class="headerlink" title="2.1.2 互联网的域名结构"></a>2.1.2 互联网的域名结构</h2></li>
<li>互联网采用层次树状结构的命名方法</li>
<li>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即<strong>域名</strong></li>
<li>域名的结构由标号序列组成，各标号之间用点隔开</li>
<li><strong>标号最长63个字符（不包含相隔的点），域名最长253个字符</strong></li>
</ul>
<p>例如：<a href="http://www.baidu.com，从左到右依次为：三级域名、二级域名、顶级域名，等级从低到高，有几段标号，www就是几级域名">www.baidu.com，从左到右依次为：三级域名、二级域名、顶级域名，等级从低到高，有几段标号，www就是几级域名</a></p>
<h3 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h3><ul>
<li>国家顶级域名nTLD:.cn/.us/.ru…</li>
<li>通用顶级域名gTLD:.gov（政府）/.edu（教育机构）/.org（非营利性组织）/.mil（军事部门）/.net（网络服务机构）/.int（国际组织）/.com或.biz（公司和企业）/.jobs（人力企业）/.coop（合作团体）/.aero（航空公司）/.pro（持有证书的专业人员）/.name（个人）/.museum（博物馆）…<strong>当.edu/.gov/.mil是顶级域名时，则域名均为美国专用，其他国家需要添加国家顶级域名</strong> <h2 id="2-1-3-域名服务器"><a href="#2-1-3-域名服务器" class="headerlink" title="2.1.3 域名服务器"></a>2.1.3 域名服务器</h2></li>
</ul>
<p><strong>既然域名系统是一个数据库，那么它放在哪里？</strong></p>
<ul>
<li><strong>区</strong>：一个服务器所负责管辖（或有权限的）范围</li>
<li>各单位根据具体情况来划分自己管辖范围的区，但在一个区内的所有节点必须是能够连通的</li>
<li>每一个区内所有主机的域名到IP地址的映射均存放在该区的<strong>权限域名服务器</strong>内</li>
<li>DNS服务器的管辖范围不以“域”为单位，而是以“区”为单位</li>
<li>找到域名对应的IP地址首先要找到<strong>根域名服务器</strong>，然后找其下的<strong>顶级域名服务器</strong>逐级往下直到找到域名</li>
<li><strong>根域名服务器共有13套装置，不是13个机器</strong>，这些装置对应的域名为从a.rootservers.net到m.rootservers.net，其中一套为<strong>主根服务器</strong>，其余12套为<strong>辅根服务器</strong>，截止到2016年2月，全世界已经在588个地点安装了根域名服务器 （有1000台以上的服务器）<em>（为了让世界上大部分DNS域名服务器都能就近找到一个域名服务器）</em>，所以<strong>根域名服务器不是13个机器，一套装置就是一个根服务器集群</strong>，访问根服务器的域名需要32个字节</li>
<li><strong>在IPV4下，为了在大多数的网络上进行传输，一个DNS数据包的大小规定小于等于512个字节</strong>，传输时在这个数据包的基础上还要加上8个字节大小的UDP头部，20个字节大小的IP，一定字节大小的数据链路层头部等等</li>
<li><strong>为什么根域名服务器只有13个</strong>:存放一个根域名服务器的域名需要32字节，而一个DNS数据包的大小规定小于等于512个字节，其中包含了13台根服务器的域名共416字节，为了省出足够空间存放其他参数，因此目前只有13台根服务器</li>
<li>根域名服务器不直接把域名转换成IP地址，在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的IP地址告诉本地域名服务器</li>
<li><strong>顶级域名服务器</strong>：负责管理在该顶级域名服务器注册的所有二级域名，当收到DNS查询请求时，就给出相应的回答 <em>（可能是最后的结果，也可能是下一步应当找的域名服务器的IP地址）</em></li>
<li><strong>分区域名服务器</strong>：负责一个区的域名服务器，当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户下一步应当找哪一个权限域名服务器</li>
<li><strong>本地域名服务器</strong>：当一个主机发出DNS查询请求时，这个查询请求报文就将发送给本地域名服务器，每一个互联网服务提供者ISP都可以拥有一个本地域名服务器，这种域名服务器也称为<strong>默认域名服务器</strong></li>
<li><strong>本地域名服务器采用迭代查询</strong>：当一个主机发出DNS查询请求时，这个请求将最先送到本地域名服务器，<strong>如果这个域名和对应的IP在服务器内没有存储或IP已经过期</strong>则本地域名服务器首先询问根域名服务器，获得顶级域名服务器IP，本地域名服务器再根据得到的IP询问顶级域名服务器，获得权限域名服务器IP，再根据得到的IP逐级向下询问次级权限域名服务器，直到获得完整的IP，本地域名服务器将域名和IP进行存储，最后将IP传给主机，完成查询。<strong>如果这个域名和对应的IP在服务器内存在或有效</strong>则本地域名服务器将存储的IP发送给主机，结束查询。</li>
<li><strong>本地域名服务器采用递归查询（少用）</strong>：<strong>如果这个域名和对应的IP在服务器内没有存储或IP已经过期</strong>，则本地域名服务器首先询问根域名服务器，根域名服务器再询问顶级域名服务器，顶级域名服务器再询问权限域名服务器，权限域名服务器逐级向下询问直到所有标号序列均查询完毕，询问顺序中最后一个权限域名服务器将完整的IP逐级返回到上一级域名服务器，根域名服务器将IP返回给本地域名服务器，本地域名服务器将域名和IP进行存储，最后将IP传给主机，完成查询。<strong>如果这个域名和对应的IP在服务器内存在或有效</strong>则本地域名服务器将存储的IP发送给主机，结束查询。由于根服务器是公共资源，我们希望根服务器的资源利用最大化，因此查询常常只发生在主机和本地域名服务器之间。</li>
<li>名字的高速缓存：<strong>每个域名服务器都维护一个高速缓存</strong>，存放最近用过的名字以及从何处获得名字映射信息的记录，这么做可以大大减轻根域名服务器的负荷，使互联网上的DNS查询请求和回答报文的数量大为减少。为了保持高速缓存中的内容正确，域名服务器应该为每项内容设置计时器，并处理超过合理时间的项。<strong>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值，增加此时间值可以减少网络开销，减少此时间值可以提高域名转换的准确性</strong></li>
</ul>
<hr>
<h1 id="2-2-文件传送协议"><a href="#2-2-文件传送协议" class="headerlink" title="2.2 文件传送协议"></a>2.2 文件传送协议</h1><h2 id="2-2-1-文件传送协议-File-Transfer-Protocol-FTP-概述"><a href="#2-2-1-文件传送协议-File-Transfer-Protocol-FTP-概述" class="headerlink" title="2.2.1 文件传送协议(File Transfer Protocol,FTP)概述"></a>2.2.1 文件传送协议(File Transfer Protocol,FTP)概述</h2><ul>
<li>FTP是互联网上使用最广泛的文件传送协议，有两种传输方式：<strong>ASCII传输</strong>和<strong>bit传输</strong></li>
<li>FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有存取权限</li>
<li>FTP屏蔽了各计算机系统的细节，因而适用于在异构网络中任意计算机之间传送文件</li>
<li>RFC959很早就成为了互联网的正式标准</li>
</ul>
<h2 id="2-2-2-FTP的基本工作原理"><a href="#2-2-2-FTP的基本工作原理" class="headerlink" title="2.2.2 FTP的基本工作原理"></a>2.2.2 FTP的基本工作原理</h2><ul>
<li>文件传送协议FTP只借助TCP可靠的运输服务提供文件传送的一些基本服务</li>
<li>FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性</li>
<li>FTP使用<strong>客户-服务器</strong>工作方式，一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由<strong>一个主进程和若干个从属进程两大部分</strong>组成，主进程负责接受新的请求，从属进程负责处理单个请求</li>
</ul>
<h3 id="主进程的工作步骤"><a href="#主进程的工作步骤" class="headerlink" title="主进程的工作步骤"></a>主进程的工作步骤</h3><ul>
<li>打开熟知端口（端口号为21），使客户进程能够连接上</li>
<li>等待客户进程发出连接请求</li>
<li>启动从属进程来处理客户进程发来的请求，从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其它一些子进程</li>
<li>回到等待状态，继续接受其他客户进程发来的请求，主进程与从属进程的处理是<strong>并发</strong>地进行</li>
</ul>
<h3 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h3><ul>
<li>控制连接在整个会话期间一直保持打开，FTP客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件</li>
<li>连接建立后，通过20号端口来进行数据连接（21号端口仍然打开），用于传输文件。服务器端的控制进程在接收到FTP客户发送来的文件传输请求后就创建<strong>数据传送进程</strong>和<strong>数据连接</strong>，用来连接客户端和服务器端的数据传送进程</li>
<li>数据传送进程实际完成文件的传送，在传送完毕后关闭数据传送连接并结束运行</li>
<li>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的<strong>熟知端口（21）</strong>，同时还要高速服务器进程自己的另一个端口号码用于数据传送连接，之后服务器用自己传送数据的<strong>熟知端口（20）</strong>与客户进程所提供的端口号码建立数据传送连接</li>
<li>使用两个不同端口号的好处<ul>
<li>使协议更加简单和更容易实现</li>
<li>在传输文件时还可以利用控制连接来控制传输文件进程。</li>
</ul>
</li>
</ul>
<h3 id="网络文件系统-Network-File-System，NFS-的思路"><a href="#网络文件系统-Network-File-System，NFS-的思路" class="headerlink" title="网络文件系统(Network File System，NFS)的思路"></a>网络文件系统(Network File System，NFS)的思路</h3><ul>
<li>NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据</li>
<li>NFS可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件，NFS软件把需要添加的数据和写数据请求一起发送到远地计算机的NFS服务器，NFS服务器更新文件后返回应答信息 <em>（比如git bash）</em></li>
<li><strong>NFS在网络上传送的只是少量的修改数据</strong></li>
</ul>
<h2 id="2-2-3-简单文件传送协议-Trival-File-Transfer-Protocal-TFTP"><a href="#2-2-3-简单文件传送协议-Trival-File-Transfer-Protocal-TFTP" class="headerlink" title="2.2.3 简单文件传送协议(Trival File Transfer Protocal,TFTP)"></a>2.2.3 简单文件传送协议(Trival File Transfer Protocal,TFTP)</h2><ul>
<li>TFTP是一个很小且易于实现的文件传送协议</li>
<li>TFTP使用客户服务器方式和使用UDP <em>（无连接运输）</em>数据报，因此TFTP需要有自己的差错改正措施</li>
<li>TFTP<strong>只支持文件传输</strong>而不支持交互</li>
<li>TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别</li>
</ul>
<hr>
<h1 id="2-3-远程终端协议TELNET（课程略）"><a href="#2-3-远程终端协议TELNET（课程略）" class="headerlink" title="2.3 远程终端协议TELNET（课程略）"></a>2.3 远程终端协议TELNET（课程略）</h1><hr>
<h1 id="2-4-万维网WWW"><a href="#2-4-万维网WWW" class="headerlink" title="2.4 万维网WWW"></a>2.4 万维网WWW</h1><hr>
<h1 id="2-5-电子邮件"><a href="#2-5-电子邮件" class="headerlink" title="2.5 电子邮件"></a>2.5 电子邮件</h1><h2 id="2-5-1电子邮件概述"><a href="#2-5-1电子邮件概述" class="headerlink" title="2.5.1电子邮件概述"></a>2.5.1电子邮件概述</h2><ul>
<li>电子邮件的传送方式是将邮件发送到收件人使用的邮件服务器并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取，是一种<strong>非即时</strong>的通信方式。</li>
<li>电子邮件具有<strong>方便、传递迅速、费用低廉的优点</strong></li>
<li>电子邮件的标准：<strong>发送邮件SMTP</strong>、<strong>读取邮件POP3和IMAP</strong>、<strong>同时传送多种类型数据MIME</strong></li>
<li>电子邮件的传送过程:发件人以SMTP标准借助TCP可靠的运输服务向发送方邮件服务器的25号端口传送邮件，发送方邮件服务器以SMTP标准借助TCP向接收方邮件服务器发送邮件，接收方邮件服务器以POP3/IMAP标准读取邮件，收件人以POP3/IMAP标准从接收方邮件服务器读取邮件 <strong>（POP3服务器和POP3客户之间的通信是由POP3客户发起的）</strong><br><img src="../photos/ComputerNetworkCourse/2_1.png" title="电子邮件发送-接收示意图"></li>
<li>用户代理(User Agent,UA)：用户与电子邮件系统的接口，是电子邮件客户端软件，功能是<strong>撰写、显示、处理和通信</strong>，邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况</li>
<li>TCP/IP体系的电子邮件系统规定电子邮件地址的格式：收件人邮箱名@邮箱所在主机的域名</li>
</ul>
<h2 id="2-5-2简单邮件传送协议SMTP"><a href="#2-5-2简单邮件传送协议SMTP" class="headerlink" title="2.5.2简单邮件传送协议SMTP"></a>2.5.2简单邮件传送协议SMTP</h2><ul>
<li>SMTP所规定的就是在两个相互通信的SMTP进程之间如何交换信息</li>
<li>由于SMTP使用<strong>客户-服务器</strong>工作方式，因此负责发送邮件的SMTP进程就是SMTP客户，而负责接收邮件的SMTP进程就是SMTP服务器</li>
<li><strong>SMTP通信的3个阶段</strong>：<strong>连接建立——邮件传送——连接释放</strong>（在发送主机的SMTP客户和负责接收的SMTP服务器之间建立连接，邮件发送完毕后，SMTP应释放TCP连接）<strong>SMTP不使用中间的邮件服务器</strong></li>
<li>缺陷：不能传送可执行文件或其他的二进制对象，仅限于传送7位的ASCII码，这意味着许多非英语国家的文字无法传送，SMTP服务器会拒收超过一定长度的邮件</li>
</ul>
<h2 id="2-5-3电子邮件的信息格式"><a href="#2-5-3电子邮件的信息格式" class="headerlink" title="2.5.3电子邮件的信息格式"></a>2.5.3电子邮件的信息格式</h2><ul>
<li>电子邮件的组成：<strong>信封和内容</strong></li>
<li>RFC822只规定了邮件内容中的首部格式，而对邮件的主体部分则让用户自由撰写，用户写好首部后，邮件系统将自动将信封所需的信息提取出来并写在信封上，无需用户填写，邮件内容首部包括一些关键字，后面加上冒号，最重要的关键字是<strong>To（后面填入收件人的电子邮件地址）、Subject（邮件的主题，便于用户查找）、Cc（表示应给某人发送一个邮件副本）、From和Date（分别表示发件人的电子邮件地址和发件日期）、Reply-To（对方回信所用的地址）</strong></li>
</ul>
<h2 id="2-5-4邮件读取协议POP3和IMAP4"><a href="#2-5-4邮件读取协议POP3和IMAP4" class="headerlink" title="2.5.4邮件读取协议POP3和IMAP4"></a>2.5.4邮件读取协议POP3和IMAP4</h2><ul>
<li>邮局协议POP是一个非常简单但功能有限的邮件读取协议，POP3是它的第三个版本，也是当前使用的版本。</li>
<li>POP也使用<strong>客户-服务器</strong>的工作方式，在接收邮件的用户PC机中必须运行POP客户程序，而在用户所连接的互联网服务提供商(Internet Service Provider,ISP)的邮件服务器中运行POP服务器程序</li>
<li>交互邮件访问协议IMAP也使用<strong>客户-服务器</strong>的工作方式，IMAP4是它的第四个版本，也是当前使用的版本。</li>
<li>用户在自己的PC机上就可以操纵ISP的邮件服务器的邮箱，就像在本地操纵一样</li>
<li><strong>IMAP是一个联机协议</strong>，当用户PC机上的IMAP客户程序打开IMAP服务器的邮箱时，用户就可看到邮件的首部，若用户需要打开某个邮件，则邮件才传到用户的PC机上</li>
<li>IMAP的优势<ul>
<li>用户可以在不同的地方使用不同的计算机随时上网阅读和处理的自己的邮件</li>
<li>IMAP允许收件人只读取邮件中的某一个部分</li>
</ul>
</li>
<li>IMAP的缺点：如果用户没有将邮件复制到自己的PC上，则邮件一直是存放在IMAP服务器上，因此用户需要经常与IMAP服务器建立连接</li>
</ul>
<h2 id="2-5-5基于万维网的电子邮件"><a href="#2-5-5基于万维网的电子邮件" class="headerlink" title="2.5.5基于万维网的电子邮件"></a>2.5.5基于万维网的电子邮件</h2><ul>
<li>发件方使用<strong>HTTP协议</strong>将邮件发送到邮件服务器，两个服务器之间的传送使用SMTP协议，邮件从服务器传到收件方是使用HTTP协议</li>
<li>万维网电子邮件的优势：只要能够找到可以上网的PC机，打开任何一种浏览器都可以方便地<strong>收发</strong>电子邮件，是一种“B-S”的方式（浏览器-服务器），而上述所提到的SMTP\POP3\IMAP都是“C-S”的方式（客户-服务器）</li>
</ul>
<h2 id="2-5-6通用互联网邮件扩充MIME"><a href="#2-5-6通用互联网邮件扩充MIME" class="headerlink" title="2.5.6通用互联网邮件扩充MIME"></a>2.5.6通用互联网邮件扩充MIME</h2><ul>
<li>由于SMTP能够传送的文件格式有限，因此MIME继续使用RFC822格式的同时增加了<strong>邮件主体的结构</strong>，定义了<strong>传送非ASCII码的编码规则</strong>，但<strong>MIME并没有改动SMTP或取代它</strong></li>
<li>MIME和SMTP的关系：邮件（非ASCII码）先通过MIME转换成7位ASCII码，再使用SMTP传输，然后通过MIME转回非ASCII码交给用户<br><img src="../photos/ComputerNetworkCourse/2_2.png" title="MIME和SMTP关系示意图"></li>
<li>MIME的三个主要部分<ul>
<li>首部字段：添加了5个新的首部字段，它们可包含在RFC822首部中，这些字段提供了有关邮件主体的信息</li>
<li>格式：定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li>
<li>传送编码：定义了新的传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-6-动态主机配置协议DHCP（课程略）"><a href="#2-6-动态主机配置协议DHCP（课程略）" class="headerlink" title="2.6 动态主机配置协议DHCP（课程略）"></a>2.6 动态主机配置协议DHCP（课程略）</h1><h1 id="2-7-简单网络管理协议SNMP（课程略）"><a href="#2-7-简单网络管理协议SNMP（课程略）" class="headerlink" title="2.7 简单网络管理协议SNMP（课程略）"></a>2.7 简单网络管理协议SNMP（课程略）</h1><hr>
<h1 id="2-8-应用进程跨越网络的通信"><a href="#2-8-应用进程跨越网络的通信" class="headerlink" title="2.8 应用进程跨越网络的通信"></a>2.8 应用进程跨越网络的通信</h1><h2 id="2-8-1系统调用和应用编程接口"><a href="#2-8-1系统调用和应用编程接口" class="headerlink" title="2.8.1系统调用和应用编程接口"></a>2.8.1系统调用和应用编程接口</h2><ul>
<li>大多数操作系统使用系统调用的机制在应用程序和操作系统间传递控制权</li>
<li>系统调用和程序中的函数调用较为相似，只是系统调用是将控制权传递给操作系统，而函数调用的控制权是在调用函数的那部分代码 </li>
</ul>
<h2 id="2-8-2几种常用的系统调用"><a href="#2-8-2几种常用的系统调用" class="headerlink" title="2.8.2几种常用的系统调用"></a>2.8.2几种常用的系统调用</h2><ul>
<li>应用编程接口API——应用进程和操作系统控制权进行转换的接口：当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口，此接口再将控制权传递给计算机的操作系统，操作系统将此调用转给某个内部进程，并执行所请求的操作，内部过程一旦执行完毕，控制权又通过系统调用接口返回给应用进程<ul>
<li>套接字接口</li>
<li>Windows Socket：采用套接字接口但稍有不同</li>
<li>TLI，为UNIX系统定义的一种API</li>
</ul>
</li>
<li><strong>套接字 <em>（IP地址+端口）</em>的作用**：当应用进程需要使用网络进行通信的时候就发出系统调用，请求操作系统为其创建套接字，以便把网络通信所需要的系统资源分配给该应用进程，操作系统为这些资源的综合用一个叫做</strong>套接字描述符**的号码来表示，并把此号码返回给应用进程，应用进程所进行的网络操作都必须使用这个号码。通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该号码相关的所有资源</li>
</ul>
<hr>
<h1 id="2-9-P2P应用"><a href="#2-9-P2P应用" class="headerlink" title="2.9 P2P应用"></a>2.9 P2P应用</h1><h2 id="2-9-0P2P工作方式概述"><a href="#2-9-0P2P工作方式概述" class="headerlink" title="2.9.0P2P工作方式概述"></a>2.9.0P2P工作方式概述</h2><ul>
<li>P2P出现的背景：自从互联网能够提供音频、视频服务后，宽带上网用户数量急剧增长，很多用户使用宽带接入的目的就是更快地下载音频视频文件</li>
<li>P2P工作方式：所有的音频、视频文件都是在普通的互联网用户之间传输，<strong>每个客户也可以是服务器</strong>，在P2P工作方式下，相当于有很多分散在各地的媒体服务器提供下载服务</li>
<li>在互联网流量中，P2P工作方式下的文件分发已占据最大的份额，比万维网应用所占的比例要大得多</li>
<li>优点：用户不必访问集中式服务器，缓解了集中式媒体服务器可能出现的瓶颈问题，多个用户拥有相同资源使得可以获得的资源来源更多，获取资源更为方便、快捷<h2 id="2-9-1具有集中目录服务器的P2P工作方式"><a href="#2-9-1具有集中目录服务器的P2P工作方式" class="headerlink" title="2.9.1具有集中目录服务器的P2P工作方式"></a>2.9.1具有集中目录服务器的P2P工作方式</h2></li>
<li>Napster<ul>
<li>是最早出现的P2P技术，用于提供MP3音乐的免费下载</li>
<li>Napster能够搜索音乐文件，所有的音乐<strong>文件地址</strong>击中存放在一个Napster目录服务器中，便于用户下载</li>
<li>用户要及时向Napster的目录服务器报告自己存有的音乐文件，当用户需要下载时，就向服务器发出询问，服务器根据检索结果返回地址，Napster<strong>文件传输是分散的，但文件的定位是集中的</strong></li>
<li>缺点：可靠性差（需要目录服务器）、侵犯版权</li>
</ul>
</li>
</ul>
<h2 id="2-9-2具有全分布式结构的P2P文件共享程序"><a href="#2-9-2具有全分布式结构的P2P文件共享程序" class="headerlink" title="2.9.2具有全分布式结构的P2P文件共享程序"></a>2.9.2具有全分布式结构的P2P文件共享程序</h2><ul>
<li>电驴eMule<ul>
<li>电驴使用<strong>分散定位和分散传输技术</strong>，把每一个文件划分为许多小文件块，使用<strong>多源文件传输协议MFTP</strong>进行传送。因此用户可以同时从很多地方<strong>并行下载一个文件中的不同文件块</strong>，这么做使得下载可以较快完成</li>
<li>电驴用户在下载文件的同时也在上传文件</li>
</ul>
</li>
<li>比特洪流BT**<del>种子！</del><strong>：BitTorrent所有对等方集合称为一个</strong>洪流<strong>，下载文件的数据单元为</strong>长度固定的文件块<strong>，基础设施节点则叫做</strong>追踪器**，用于获得对等方列表</li>
</ul>
<h2 id="2-9-3P2P文件分发的分析"><a href="#2-9-3P2P文件分发的分析" class="headerlink" title="2.9.3P2P文件分发的分析"></a>2.9.3P2P文件分发的分析</h2><ul>
<li>使用P2P方式下载文件会<strong>同时占用下载和上传带宽</strong></li>
<li>C/S方式下分发的最短时间<ul>
<li>从服务器端考虑，有N台主机从服务器下载一个大文件，所有主机分发完毕的最短时间T不可能小于NF/u（？为啥），其中F为文件大小，单位为bit；上传速率和下载速率分别为u和d，单位为bit/s</li>
<li>若下载速率最慢的主机的下载速率为dmin，则T不可能小于F/dmin</li>
<li>综上可知所有主机都下载完文件F的最少时间为T=max（NF/u，F/dmin）</li>
</ul>
</li>
</ul>
<h2 id="2-9-4在P2P对等方式中搜索对象"><a href="#2-9-4在P2P对等方式中搜索对象" class="headerlink" title="2.9.4在P2P对等方式中搜索对象"></a>2.9.4在P2P对等方式中搜索对象</h2><ul>
<li>现在广泛使用的索引和查找技术叫做<strong>分布式散列表DHT</strong>，也可译为<strong>分布式哈希表</strong>，它是由大量对等方共同维护的散列表</li>
<li>分布式散列表DHT利用散列函数，把资源名K及其存放的结点IP地址N都分别映射为资源名标识符KID和节点标识符NID</li>
<li>chord算法把结点按标识符数值从小到大沿顺时针排列成一个环形覆盖网络</li>
</ul>
<hr>
<h2 id="2-10补充"><a href="#2-10补充" class="headerlink" title="2.10补充"></a>2.10补充</h2> 
      <!-- reward -->
      
    </div>
    

    <!-- copyright -->
    
    <footer class="article-footer">
       
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="tag">计算机网络</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B0/" rel="tag">课程笔记</a></li></ul>

    </footer>
  </div>

    
 
    
</article>

    
  </article>
  

  
  <nav class="page-nav">
    
    <a class="extend prev" rel="prev" href="/">上一页</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/">下一页</a>
  </nav>
  
</section>
</div>

      <footer class="footer">
  <div class="outer">
    <ul>
      <li>
        Copyrights &copy;
        2022
        <i class="ri-heart-fill heart_icon"></i> Daniel Qi
      </li>
    </ul>
    <ul>
      <li>
        
      </li>
    </ul>
    <ul>
      <li>
        
        
        <span>
  <span><i class="ri-user-3-fill"></i>Visitors:<span id="busuanzi_value_site_uv"></span></span>
  <span class="division">|</span>
  <span><i class="ri-eye-fill"></i>Views:<span id="busuanzi_value_page_pv"></span></span>
</span>
        
      </li>
    </ul>
    <ul>
      
    </ul>
    <ul>
      
    </ul>
    <ul>
      <li>
        <!-- cnzz统计 -->
        
        <script type="text/javascript" src='https://s9.cnzz.com/z_stat.php?id=1278069914&amp;web_id=1278069914'></script>
        
      </li>
    </ul>
  </div>
</footer>    
    </main>
    <div class="float_btns">
      <div class="totop" id="totop">
  <i class="ri-arrow-up-line"></i>
</div>

<div class="todark" id="todark">
  <i class="ri-moon-line"></i>
</div>

    </div>
    <aside class="sidebar on">
      <button class="navbar-toggle"></button>
<nav class="navbar">
  
  <div class="logo">
    <a href="/"><img src="/images/ayer.svg" alt="Welcome to DanielQi&#39;s Blog"></a>
  </div>
  
  <ul class="nav nav-main">
    
    <li class="nav-item">
      <a class="nav-item-link" href="/">主页</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/archives">归档</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/categories">分类</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags">标签</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/%E6%97%85%E8%A1%8C/">旅行</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/tags/photos/">相册</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/friends">友链</a>
    </li>
    
    <li class="nav-item">
      <a class="nav-item-link" href="/2022/about">关于我</a>
    </li>
    
  </ul>
</nav>
<nav class="navbar navbar-bottom">
  <ul class="nav">
    <li class="nav-item">
      
      <a class="nav-item-link nav-item-search"  title="Search">
        <i class="ri-search-line"></i>
      </a>
      
      
      <a class="nav-item-link" target="_blank" href="/atom.xml" title="RSS Feed">
        <i class="ri-rss-line"></i>
      </a>
      
    </li>
  </ul>
</nav>
<div class="search-form-wrap">
  <div class="local-search local-search-plugin">
  <input type="search" id="local-search-input" class="local-search-input" placeholder="Search...">
  <div id="local-search-result" class="local-search-result"></div>
</div>
</div>
    </aside>
    <div id="mask"></div>

<!-- #reward -->
<div id="reward">
  <span class="close"><i class="ri-close-line"></i></span>
  <p class="reward-p"><i class="ri-cup-line"></i>请我喝杯咖啡吧~</p>
  <div class="reward-box">
    
    <div class="reward-item">
      <img class="reward-img" src="/images/1.jpg">
      <span class="reward-type">支付宝</span>
    </div>
    
    
    <div class="reward-item">
      <img class="reward-img" src="/images/2.png">
      <span class="reward-type">微信</span>
    </div>
    
  </div>
</div>
    
<script src="/js/jquery-3.6.0.min.js"></script>
 
<script src="/js/lazyload.min.js"></script>

<!-- Tocbot -->

<script src="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.js"></script>
<link
  rel="stylesheet"
  href="https://cdn.jsdelivr.net/npm/jquery-modal@0.9.2/jquery.modal.min.css"
/>
<script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js"></script>

<script src="/dist/main.js"></script>

<!-- ImageViewer -->
 <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                        <div class="pswp__preloader__cut">
                            <div class="pswp__preloader__donut"></div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div>
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/default-skin/default-skin.min.css">
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/photoswipe@4.1.3/dist/photoswipe-ui-default.min.js"></script>

<script>
    function viewer_init() {
        let pswpElement = document.querySelectorAll('.pswp')[0];
        let $imgArr = document.querySelectorAll(('.article-entry img:not(.reward-img)'))

        $imgArr.forEach(($em, i) => {
            $em.onclick = () => {
                // slider展开状态
                // todo: 这样不好，后面改成状态
                if (document.querySelector('.left-col.show')) return
                let items = []
                $imgArr.forEach(($em2, i2) => {
                    let img = $em2.getAttribute('data-idx', i2)
                    let src = $em2.getAttribute('data-target') || $em2.getAttribute('src')
                    let title = $em2.getAttribute('alt')
                    // 获得原图尺寸
                    const image = new Image()
                    image.src = src
                    items.push({
                        src: src,
                        w: image.width || $em2.width,
                        h: image.height || $em2.height,
                        title: title
                    })
                })
                var gallery = new PhotoSwipe(pswpElement, PhotoSwipeUI_Default, items, {
                    index: parseInt(i)
                });
                gallery.init()
            }
        })
    }
    viewer_init()
</script> 
<!-- MathJax -->

<!-- Katex -->

<!-- busuanzi  -->
 
<script src="/js/busuanzi-2.3.pure.min.js"></script>
 
<!-- ClickLove -->

<!-- ClickBoom1 -->

<!-- ClickBoom2 -->

<!-- CodeCopy -->
 
<link rel="stylesheet" href="/css/clipboard.css">
 <script src="https://cdn.jsdelivr.net/npm/clipboard@2/dist/clipboard.min.js"></script>
<script>
  function wait(callback, seconds) {
    var timelag = null;
    timelag = window.setTimeout(callback, seconds);
  }
  !function (e, t, a) {
    var initCopyCode = function(){
      var copyHtml = '';
      copyHtml += '<button class="btn-copy" data-clipboard-snippet="">';
      copyHtml += '<i class="ri-file-copy-2-line"></i><span>COPY</span>';
      copyHtml += '</button>';
      $(".highlight .code pre").before(copyHtml);
      $(".article pre code").before(copyHtml);
      var clipboard = new ClipboardJS('.btn-copy', {
        target: function(trigger) {
          return trigger.nextElementSibling;
        }
      });
      clipboard.on('success', function(e) {
        let $btn = $(e.trigger);
        $btn.addClass('copied');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-checkbox-circle-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPIED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-checkbox-circle-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
      clipboard.on('error', function(e) {
        e.clearSelection();
        let $btn = $(e.trigger);
        $btn.addClass('copy-failed');
        let $icon = $($btn.find('i'));
        $icon.removeClass('ri-file-copy-2-line');
        $icon.addClass('ri-time-line');
        let $span = $($btn.find('span'));
        $span[0].innerText = 'COPY FAILED';
        
        wait(function () { // 等待两秒钟后恢复
          $icon.removeClass('ri-time-line');
          $icon.addClass('ri-file-copy-2-line');
          $span[0].innerText = 'COPY';
        }, 2000);
      });
    }
    initCopyCode();
  }(window, document);
</script>
 
<!-- CanvasBackground -->

<script>
  if (window.mermaid) {
    mermaid.initialize({ theme: "forest" });
  }
</script>


    
    <div id="music">
    
    
    
    <iframe frameborder="no" border="1" marginwidth="0" marginheight="0" width="200" height="86"
        src="//music.163.com/outchain/player?type=2&id=139774&auto=0&height=66"></iframe>
</div>

<style>
    #music {
        position: fixed;
        right: 15px;
        bottom: 0;
        z-index: 998;
    }
</style>
    
    

  </div>
</body>

</html>
<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>FPS项目文档v1.1</title>
    <url>/2022/06/30/FPS%E9%A1%B9%E7%9B%AE%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="0-前言（套盾）"><a href="#0-前言（套盾）" class="headerlink" title="0.前言（套盾）"></a>0.前言（<del>套盾</del>）</h1><p><strong>本文档仅供项目组内部参考使用</strong><br><strong>本文档内链接均用于学习</strong><br><strong>本文档所属项目仅为学习用demo，非商业化作品</strong><br><strong>本文档中包含游戏机制、游戏道具、各类属性的说明与策划给出的部分实现思路</strong></p>
<hr>
<h1 id="1-项目目标"><a href="#1-项目目标" class="headerlink" title="1.项目目标"></a>1.项目目标</h1><ul>
<li><p>实现多人联机功能：</p>
<ul>
<li>房间的创建、删除</li>
<li>地图加载</li>
<li>房间的进入、退出</li>
<li>同步</li>
</ul>
</li>
<li><p>实现FPS的基本内容：</p>
<ul>
<li>战斗<ul>
<li>武器</li>
<li>道具</li>
<li>技能</li>
<li>动作</li>
</ul>
</li>
<li>角色<ul>
<li>角色定位</li>
<li>外观</li>
<li>数值</li>
<li>技能（是在地图里获取技能还是角色自带技能）</li>
</ul>
</li>
<li>交互<ul>
<li>UI</li>
<li>键位</li>
<li>与场景交互</li>
</ul>
</li>
<li>地图/场景<ul>
<li>地图加载/销毁</li>
<li>地图内设施</li>
<li>道具刷新点</li>
</ul>
</li>
<li></li>
</ul>
</li>
<li><p>实现游戏核心机制：</p>
<ul>
<li>角色<ul>
<li>角色选择</li>
<li>角色创建与初始化<ul>
<li>角色数值初始化</li>
<li>出生点选择</li>
</ul>
</li>
<li>角色状态与转换<ul>
<li>健康</li>
<li>负伤</li>
<li>死亡（<del>盒子</del>）</li>
<li>转换</li>
</ul>
</li>
<li>角色掉落<ul>
<li>部分掉落</li>
<li>完全掉落</li>
</ul>
</li>
<li>角色属性与变化机制</li>
<li>角色销毁<ul>
<li>撤离点</li>
<li>被击杀</li>
<li>迷失</li>
</ul>
</li>
</ul>
</li>
<li>限时撤离</li>
<li>胜利目标</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-项目设定"><a href="#2-项目设定" class="headerlink" title="2.项目设定"></a>2.项目设定</h1><h2 id="2-1分工（这个清清来吧，还是需要一个书面的东西来详细划定的）"><a href="#2-1分工（这个清清来吧，还是需要一个书面的东西来详细划定的）" class="headerlink" title="2.1分工（这个清清来吧，还是需要一个书面的东西来详细划定的）"></a>2.1分工（这个清清来吧，还是需要一个书面的东西来详细划定的）</h2><h2 id="2-2项目参考-（更新中）"><a href="#2-2项目参考-（更新中）" class="headerlink" title="2.2项目参考 （更新中）"></a>2.2项目参考 <em>（更新中）</em></h2><p><a href="https://www.youtube.com/watch?v=zPZK7C5_BQo">利用Photon实现服务器</a><br><a href="https://www.bilibili.com/video/BV1kC4y1s73">搭建服务器框架和实现联机大厅</a><br><a href="https://www.youtube.com/watch?v=uh8XaC0Y5MA">Unity C#服务器</a><br><a href="https://www.youtube.com/watch?v=aTnBAzin9vE">UnityFPS官方示例</a><br><a href="https://www.bilibili.com/video/BV1ms411E7XE">枪械后坐力参考</a><br><a href="https://www.bilibili.com/video/BV1V3411j7NN">逃离塔科夫枪械后坐参数说明</a></p>
<hr>
<h1 id="3-具体设计说明"><a href="#3-具体设计说明" class="headerlink" title="3.具体设计说明"></a>3.具体设计说明</h1><h2 id="3-0-游戏总体设计"><a href="#3-0-游戏总体设计" class="headerlink" title="3.0 游戏总体设计"></a>3.0 游戏总体设计</h2><p>玩家在初始界面设定联机ID创建角色，连接进入游戏大厅，选择房间或创建房间。开始游戏后，玩家先有若干秒选择角色，同时地图上随机刷新资源，倒计时结束后出生在随机出生点。玩家可在地图上搜集资源。击杀其他玩家时，可以获取其携带物资和标识，并获得少量分数，当地图上仅剩一名玩家时，游戏界面倒计时撤离时间，若最后一名玩家未在规定时间内撤出，则会被强制击杀。被击杀或撤离时弹出结算界面和分数，物资可兑换少量分数，击杀玩家可兑换大量分数。游戏结束后，分数汇总生成表格推送给玩家。</p>
<h2 id="3-1-武器与战斗（策划与动画、美术、叶宝对接）"><a href="#3-1-武器与战斗（策划与动画、美术、叶宝对接）" class="headerlink" title="3.1 武器与战斗（策划与动画、美术、叶宝对接）"></a>3.1 武器与战斗（策划与动画、美术、叶宝对接）</h2><h3 id="3-1-0-战斗的大致介绍"><a href="#3-1-0-战斗的大致介绍" class="headerlink" title="3.1.0 战斗的大致介绍"></a>3.1.0 战斗的大致介绍</h3><p>主要以中近程战斗为主，玩家使用武器与自身技能击杀敌人，使用道具回复血量与护甲，击杀敌人后获取1击杀数，并根据被击杀玩家的击杀数获取奖励分数，敌人变成道具箱（道具箱UI同角色背包）；被击杀则在倒地后画面逐渐变黑，显示被击杀页面</p>
<h3 id="3-1-1-武器"><a href="#3-1-1-武器" class="headerlink" title="3.1.1 武器"></a>3.1.1 武器</h3><h4 id="武器的基本设定"><a href="#武器的基本设定" class="headerlink" title="武器的基本设定"></a>武器的基本设定</h4><ul>
<li>外观</li>
<li>射击条件（枪械配件槽内有弹匣、弹匣内有子弹方可射击，只有这个配件决定枪械是否开火）</li>
<li>枪声（枪声的更改发生在消音器被安装/取下的时候）</li>
<li>射速（理解为枪口生成子弹的速度）</li>
<li>后坐力（分为水平和垂直，水平后坐力导致枪身左右晃动，垂直导致枪身上下晃动）</li>
<li>枪口回落速度（射击停止后枪口朝向回到原方向的时间，也可以设置为速度）</li>
<li>子弹散布（我的思路是后坐力方向变化范围，参考2.2给出的塔科夫枪械后座参数说明）</li>
<li>可用弹种</li>
<li>可使用配件（配件将可能对枪械的基本属性进行更改）</li>
<li>枪械本身分值（枪械本身不含配件的分数）</li>
</ul>
<h4 id="武器种类与数值"><a href="#武器种类与数值" class="headerlink" title="武器种类与数值"></a>武器种类与数值</h4><p>较为具体的设计我在表格内已经给出了，这里要补充的一点是半自动步枪的定位。半自动步枪的定位是精准，因此初始散布应当是最小的，且具有最快的枪口回落速度。</p>
<h3 id="3-1-2-战斗"><a href="#3-1-2-战斗" class="headerlink" title="3.1.2 战斗"></a>3.1.2 战斗</h3><ul>
<li>射击（鼠标左键）：使用不同瞄具的瞄准和腰射<ul>
<li>需要考虑的要素：当前使用的瞄具，当前使用的握把，后坐力的大小，目前站姿势（站立、蹲、趴）</li>
<li>注意：跳跃不可射击</li>
<li>弹匣内无弹药且背包内无可用弹药时再按鼠标左键切换武器</li>
</ul>
</li>
<li>换弹匣（R）<ul>
<li>需要考虑的要素：弹匣的种类，技能是否开启（对换弹时间的改变）</li>
</ul>
</li>
<li>切换枪械（1和2）：一支在手里一支在背上（背上可以放置武器的地方在背两侧），当切换枪械时，先将手里的换到背上空出的地方，再将另一把从背上换到手里，播放完动画才可进行其他对武器的操作<ul>
<li>需要考虑的要素：枪械大小，枪械移位与角色部位活动的绑定</li>
</ul>
</li>
<li>改装武器（动作可以先不做，但改装武器必须花费时间）每更换一次配件，整个枪的状态就要更新一次，更换配件的方法是将背包内的配件拖到配件槽上，更换时间结束后两个配件的图标交换，更换时间=原配件的更换时间（见表格）+新配件的更换时间（见表格），若枪械配件槽为空，则只计算新配件的更换时间</li>
<li>一个准则：对武器的操作之间是互斥进行的（瞄准包含在射击内）<h2 id="3-2-道具（策划与叶宝对接）"><a href="#3-2-道具（策划与叶宝对接）" class="headerlink" title="3.2 道具（策划与叶宝对接）"></a>3.2 道具（策划与叶宝对接）</h2><h3 id="3-2-1-道具分类"><a href="#3-2-1-道具分类" class="headerlink" title="3.2.1 道具分类"></a>3.2.1 道具分类</h3></li>
<li>弹药<ul>
<li>手枪弹药：低伤害低分数带的多</li>
<li>步枪弹药：高伤害高分数带的少</li>
<li>弹药击中玩家屏幕中央给出击中X形图标反馈，由枪械生成。暂时不做弹道下坠，弹药击中场景内物体（除弹药箱、玩家死后变成的盒子、玩家外）生成贴图</li>
</ul>
</li>
<li>回复道具（护甲回复与血量回复）<ul>
<li>维修套装（一次性）：中刷新中分值</li>
<li>血量回复<ul>
<li>急救包（一次性回血）：高刷新低分值</li>
<li>回血针（持续回血）：低刷新高分值</li>
</ul>
</li>
</ul>
</li>
<li>配件<ul>
<li>带倍率瞄具：试着做镜内放大吧</li>
<li>机瞄和红点：实际上是两种类型的机瞄</li>
<li>握把和后托，握把实现垂直后坐力的削弱和枪口散布范围的缩小，后托实现水平后坐力的削弱</li>
</ul>
</li>
<li>稀有道具（高分极低刷）<ul>
<li>金/银/铜球</li>
</ul>
</li>
</ul>
<h3 id="3-2-2-道具刷新"><a href="#3-2-2-道具刷新" class="headerlink" title="3.2.2 道具刷新"></a>3.2.2 道具刷新</h3><p>道具的刷新点、爆率、特性已经在表格内给出。</p>
<h2 id="3-3-角色（策划与动画、叶宝对接）"><a href="#3-3-角色（策划与动画、叶宝对接）" class="headerlink" title="3.3 角色（策划与动画、叶宝对接）"></a>3.3 角色（策划与动画、叶宝对接）</h2><h3 id="3-3-1-角色的属性"><a href="#3-3-1-角色的属性" class="headerlink" title="3.3.1 角色的属性"></a>3.3.1 角色的属性</h3><ul>
<li>血量（见表格）</li>
<li>护甲值（见表格）</li>
<li>技能点（见表格）</li>
<li>技能回复速度：固定为2点/s（数值见表格）</li>
<li>移速（具有三档速度，数值举例见表格，按x进入/退出静步，静步将不再发出声音，按shift进入快跑，<strong>快跑持续时间和回复速度待定</strong>）</li>
<li>耐力（见表格，决定了玩家能连续跑多久）</li>
<li>耐力消耗速度/回复速度（见表格）</li>
<li>击杀数（见表格）</li>
<li>得分（玩家按两下3即可在画面右上角显示，显示时间为3s，3s内再发出查询命令则重置计时器）</li>
</ul>
<h3 id="3-3-2-角色状态、数值的转化机制"><a href="#3-3-2-角色状态、数值的转化机制" class="headerlink" title="3.3.2 角色状态、数值的转化机制"></a>3.3.2 角色状态、数值的转化机制</h3><ul>
<li>玩家被击中时若有护甲，则被击中产生的伤害80%由护甲承担，剩余20%为真伤，<strong>该伤害判定在击中时发生，若剩余护甲小于子弹伤害的80%，则护甲置0，剩余伤害均为真伤。</strong></li>
<li>玩家可通过回复道具回复血量，<strong>产生的溢出不会被计算</strong>。</li>
<li>若判定玩家承受该子弹伤害后血量&lt;=0，则触发死亡退出机制，使用布娃娃系统实现脱力倒地成为尸体，可以搜刮。</li>
</ul>
<h3 id="3-3-3-角色的动作"><a href="#3-3-3-角色的动作" class="headerlink" title="3.3.3 角色的动作"></a>3.3.3 角色的动作</h3><ul>
<li>移动：匍匐（z）、蹲走（ctrl）、静步（x）、快走、跑步、跳跃</li>
<li>战斗：举枪、瞄准、射击、换弹、切换武器、死亡</li>
<li><em>拿取物品（暂定为静止不动）</em></li>
<li>恢复：包扎（急救包）、扎针（回血针）、修补护甲（参照apex）</li>
<li>技能</li>
<li>在原有动作上进行更改（比如增速技能就提高跑步动画的播放速度）</li>
<li>死亡（先倒地再黑屏后结算）</li>
<li>迷失：超过每局最大时长仍未撤离（先黑屏后结算）</li>
</ul>
<h3 id="3-3-4-角色的背包"><a href="#3-3-4-角色的背包" class="headerlink" title="3.3.4 角色的背包"></a>3.3.4 角色的背包</h3><p>每个角色的背包是和角色绑定的，不会变化。玩家进入游戏并选好角色后按照表格内给出的刷新概率刷新物品，并更新玩家的得分。玩家被击杀时，计算背包内物品的总分数，玩家对背包内物品的每次调整都将刷新分数，玩家随时可以查询。角色的背包由通用武器槽、子弹槽、回复道具槽和任意物品槽四类槽位构成，各个槽位能放置的物品及其数量上限见表格，不能放在槽内的物品被拖拽时将不会被换入槽内，结束拖拽，图标将自行归位。</p>
<h4 id="子弹的消耗机制（涉及到背包）"><a href="#子弹的消耗机制（涉及到背包）" class="headerlink" title="子弹的消耗机制（涉及到背包）"></a>子弹的消耗机制（涉及到背包）</h4><p><strong>每个槽内只能放一种子弹</strong>，当玩家换弹时自动查询弹药槽，<strong>只会消耗放在弹药槽内的弹药</strong>若有该类弹匣对应的子弹则自动填充，若没有则按3.1.2对换弹的说明进行切换武器，如果弹药在任意物品槽内则不会被自动消耗，需玩家自行拖拽至弹药槽内。</p>
<h4 id="你可以把不要的东西丢出去！"><a href="#你可以把不要的东西丢出去！" class="headerlink" title="你可以把不要的东西丢出去！"></a>你可以把不要的东西丢出去！</h4><p>如果你想丢掉一些东西，选中它（鼠标移上去就会高亮）左键点击选择抛出数量，右键点击则全部抛弃，然后这个物体的模型将从身体周围生成并掉到地上。</p>
<h4 id="我后悔了怎么办"><a href="#我后悔了怎么办" class="headerlink" title="我后悔了怎么办"></a>我后悔了怎么办</h4><p><strong>对于半径1m以内的物体</strong>看向它（轮廓会高亮）<a href="https://www.bilibili.com/video/BV1R3411W73E">高亮教程</a>，然后按左键，将对背包进行查询，如果有位置就能放入。</p>
<h2 id="3-4-地图（策划与美术、叶宝对接）"><a href="#3-4-地图（策划与美术、叶宝对接）" class="headerlink" title="3.4 地图（策划与美术、叶宝对接）"></a>3.4 地图（策划与美术、叶宝对接）</h2><h3 id="3-4-0-地图设定"><a href="#3-4-0-地图设定" class="headerlink" title="3.4.0 地图设定"></a>3.4.0 地图设定</h3><p>目前的方案是训练基地（主要是可以大量复用素材）的一个区域，多楼层，多房间，多过道，中央是一个天井供中距离战斗，包含多个出生点且均有随机性，撤离点有通用撤离点、限时撤离点、随机撤离点、触发撤离点四种，房间最大人数10，具体每层的设计后续会和美术磋商。</p>
<h3 id="3-4-1-出生点"><a href="#3-4-1-出生点" class="headerlink" title="3.4.1 出生点"></a>3.4.1 出生点</h3><p>出生点是玩家刷新的地方，角色初始满甲满血，按表格内给出的爆率在背包内刷新物品。出生点的数量和房间内最大玩家容量一致且均匀分布在地图角落，玩家在哪个出生点进入游戏是随机的。玩家在各个刷新点的刷新概率应均等（这个好做，比如在玩家池中随机选出一个玩家，然后随机安排出生点，再从剩余玩家里接着选一个并安排，以此类推），每个玩家的出生点都被设置好，所有资源均加载完毕后进入游戏。</p>
<h3 id="3-4-2-撤离点"><a href="#3-4-2-撤离点" class="headerlink" title="3.4.2 撤离点"></a>3.4.2 撤离点</h3><p>撤离点是玩家触发退出机制的地方，若撤离点可用，则玩家进入判定区域将弹出倒计时页面，待一段时间就可撤离并进入结算页面，不会留下任何东西。</p>
<h4 id="通用撤离点"><a href="#通用撤离点" class="headerlink" title="通用撤离点"></a>通用撤离点</h4><p><strong>玩家进入游戏后随时都可撤离</strong>，将会被放在武器库的门口、通风管道这样的地方，<strong>难以找到或比较偏僻</strong>。</p>
<h4 id="限时撤离点"><a href="#限时撤离点" class="headerlink" title="限时撤离点"></a>限时撤离点</h4><p><strong>会在特定的时间点开启，并有限定时间</strong>，比如临时开启的大门</p>
<h4 id="随机撤离点-（搁置）"><a href="#随机撤离点-（搁置）" class="headerlink" title="随机撤离点 （搁置）"></a>随机撤离点 <em>（搁置）</em></h4><p>会在<strong>每局开始时就决定是否开启，若开启则会有外观的变化（比如某处墙壁是否有裂口）</strong>。</p>
<h4 id="触发撤离点"><a href="#触发撤离点" class="headerlink" title="触发撤离点"></a>触发撤离点</h4><p><strong>满足某种条件才可激活（比如拉电闸），需在一定时间内赶到撤离点撤离，否则需重新触发</strong>，比如电梯。</p>
<h3 id="3-4-3-物品箱"><a href="#3-4-3-物品箱" class="headerlink" title="3.4.3 物品箱"></a>3.4.3 物品箱</h3><p>物品箱的种类和道具爆率等设定均已在表格内给出。</p>
<h2 id="3-5-游戏机制"><a href="#3-5-游戏机制" class="headerlink" title="3.5 游戏机制"></a>3.5 游戏机制</h2><h3 id="3-5-1-房间（策划与lzy对接）"><a href="#3-5-1-房间（策划与lzy对接）" class="headerlink" title="3.5.1 房间（策划与lzy对接）"></a>3.5.1 房间（策划与lzy对接）</h3><p>进入游戏，设定用户名，分配玩家ID，连接到游戏大厅，玩家点击开始游戏，若当前没有可加入的房间则生成一个房间，客户端显示一定时长的倒计时，若在时间内房间满员则开始游戏，进入角色选择页面（给30s准备时间）并加载地图内资源，30s倒计时结束且地图资源加载完毕即可进入游戏；如果倒计时结束没有足够玩家（2人）则退回主页面。游戏结束（所有玩家都已完成游戏或每局时间上线已到）后对玩家分数进行排名，生成分数记录榜并通过邮件系统推送给玩家（实现服务器的用户连接、创建房间、加入房间、玩家信息记录、玩家同步、排行榜的创建）</p>
<h3 id="3-5-2-游戏内机制补充（策划与ycy对接）"><a href="#3-5-2-游戏内机制补充（策划与ycy对接）" class="headerlink" title="3.5.2 游戏内机制补充（策划与ycy对接）"></a>3.5.2 游戏内机制补充（策划与ycy对接）</h3><h4 id="撤离点和出生点（见3-4-1与3-4-2）"><a href="#撤离点和出生点（见3-4-1与3-4-2）" class="headerlink" title="撤离点和出生点（见3.4.1与3.4.2）"></a>撤离点和出生点（见3.4.1与3.4.2）</h4><h4 id="玩家分数的计算规则"><a href="#玩家分数的计算规则" class="headerlink" title="玩家分数的计算规则"></a>玩家分数的计算规则</h4><p><strong>如果你死亡</strong>玩家得分=玩家击杀分（规则见表格）+ 道具得分 + 剩余血量x10 + 剩余护甲x2.5<br><strong>如果你在最后10分钟内撤离</strong>玩家得分=玩家击杀分（规则见表格）+ 道具得分 + 剩余血量x10 + 剩余护甲x2.5 <strong>+1000</strong><br><strong>如果你在最初5分钟撤离</strong>玩家得分=玩家击杀分（规则见表格）+ 道具得分 + 剩余血量x10 + 剩余护甲x2.5 <strong>-1000</strong><br><strong>如果你迷失</strong>玩家得分=玩家击杀分（规则见表格）+ 道具得分 + 剩余血量x10 + 剩余护甲x2.5 <strong>-1500</strong></p>
<h4 id="游戏结束的触发条件"><a href="#游戏结束的触发条件" class="headerlink" title="游戏结束的触发条件"></a>游戏结束的触发条件</h4><p><strong>场上玩家均死亡/迷失/撤离</strong></p>
<hr>
<h1 id="4-美术需求（动画、美术、策划对接）"><a href="#4-美术需求（动画、美术、策划对接）" class="headerlink" title="4.美术需求（动画、美术、策划对接）"></a>4.美术需求（动画、美术、策划对接）</h1><h2 id="4-1-模型-目前暂时以现有素材替代，借助现有素材完成动画制作后再套新模型"><a href="#4-1-模型-目前暂时以现有素材替代，借助现有素材完成动画制作后再套新模型" class="headerlink" title="4.1 模型 目前暂时以现有素材替代，借助现有素材完成动画制作后再套新模型"></a>4.1 模型 <em>目前暂时以现有素材替代，借助现有素材完成动画制作后再套新模型</em></h2><ul>
<li>人物的模型</li>
<li>各类武器、道具、配件的模型（种类表格内已给出）</li>
<li>场景需要的模型<ul>
<li>建筑物（地图本身）</li>
<li>各类摆设</li>
<li>各类道具箱</li>
<li>撤离点</li>
</ul>
</li>
</ul>
<h2 id="4-2-UI"><a href="#4-2-UI" class="headerlink" title="4.2 UI"></a>4.2 UI</h2><h3 id="4-2-1-图标-目前需要的Sprite暂以现有素材替代"><a href="#4-2-1-图标-目前需要的Sprite暂以现有素材替代" class="headerlink" title="4.2.1 图标 目前需要的Sprite暂以现有素材替代"></a>4.2.1 图标 <em>目前需要的Sprite暂以现有素材替代</em></h3><h4 id="图标"><a href="#图标" class="headerlink" title="图标"></a>图标</h4><ul>
<li>武器、配件、道具的图标均为模型的截图</li>
<li>此外还需要：HUD（弹匣内弹药数/总弹药数，血条、技能条、护甲条、耐力条、击杀反馈图标、受伤反馈），背包内图标（配件槽的图标（配件槽可使用/配件槽不可使用）、各类道具槽的图标），道具箱内图标（武器槽、弹药槽、配件槽、药品槽、随机槽）</li>
</ul>
<h4 id="互动方案"><a href="#互动方案" class="headerlink" title="互动方案"></a>互动方案</h4><p>光标移到图标上自动弹出文字介绍</p>
<h3 id="4-2-2-面板-目前需要的Sprite暂以现有素材替代"><a href="#4-2-2-面板-目前需要的Sprite暂以现有素材替代" class="headerlink" title="4.2.2 面板 目前需要的Sprite暂以现有素材替代"></a>4.2.2 面板 <em>目前需要的Sprite暂以现有素材替代</em></h3><ul>
<li>HUD</li>
<li>背包的面板</li>
<li>各类道具箱的面板</li>
<li>服务器选房间的面板</li>
<li>选择角色页面的面板：<a href="https://www.bilibili.com/video/BV1jF41137n4">选择角色的页面我想做成滑动的</a></li>
<li>被击杀页面的面板：显示存活时间、最终分数、击杀数和击杀者（每颗子弹带有击杀者信息，角色需记录并更新最后一颗射向自己的子弹是谁，初始为NULL，死亡时调用这个属性）</li>
</ul>
<h3 id="4-2-3-字体（实在没空就先默认字体吧，有空再做）"><a href="#4-2-3-字体（实在没空就先默认字体吧，有空再做）" class="headerlink" title="4.2.3 字体（实在没空就先默认字体吧，有空再做）"></a>4.2.3 字体（实在没空就先默认字体吧，有空再做）</h3><h2 id="4-3-动画与特效"><a href="#4-3-动画与特效" class="headerlink" title="4.3 动画与特效"></a>4.3 动画与特效</h2><h3 id="角色"><a href="#角色" class="headerlink" title="角色"></a>角色</h3><p>动作分类我已在3.1.2和3.3.3给出，不过技能和护甲受击是否需要做特效呢？</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>撤离点状态的切换（比如仓库大门的打开和关闭）<br>道具箱状态的切换（打开和关闭）</p>
<hr>
<h1 id="5-音乐与音效需求"><a href="#5-音乐与音效需求" class="headerlink" title="5.音乐与音效需求"></a>5.音乐与音效需求</h1><h2 id="5-1-背景音乐-（有空再找）"><a href="#5-1-背景音乐-（有空再找）" class="headerlink" title="5.1 背景音乐  （有空再找）"></a>5.1 背景音乐  <em>（有空再找）</em></h2><p>主场景、选择角色、结算</p>
<h2 id="5-2-音效"><a href="#5-2-音效" class="headerlink" title="5.2 音效"></a>5.2 音效</h2><ul>
<li>玩家移动的各类音效</li>
<li>枪械切换、射击、换弹的各类音效</li>
<li>技能开启的音效</li>
<li>与场景互动的音效</li>
<li>护甲被击中的音效</li>
<li>受伤、濒死的声音反馈</li>
<li>回复道具使用的音效</li>
</ul>
]]></content>
      <tags>
        <tag>Unity</tag>
        <tag>FPS</tag>
        <tag>联机</tag>
      </tags>
  </entry>
  <entry>
    <title>FinalIK和Ragdoll(1)：准备工作</title>
    <url>/2022/03/22/FinalIK%E5%92%8CRagdoll(1)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.bilibili.com/video/BV1CW411N7ri?spm_id_from=333.999.0.0">教程视频</a><br>本文仅供个人学习和知识点记录用。<br>Unity版本：2021.2.15f1c1<br>Final IK版本：2.1<del>（工作室群文件里有）</del><br>Low Poly模型素材包：Heist<br>状态机来源：Unity Standard Assets</p>
<hr>
<h1 id="1-1-一些问题的解决方案"><a href="#1-1-一些问题的解决方案" class="headerlink" title="1.1 一些问题的解决方案"></a>1.1 一些问题的解决方案</h1><h2 id="1-1-1-导入Final-IK如果报错："><a href="#1-1-1-导入Final-IK如果报错：" class="headerlink" title="1.1.1 导入Final IK如果报错："></a>1.1.1 导入Final IK如果报错：</h2><p><img src="../photos/Unity/FinalIK/1_1.png" title="error"><br><strong>解决方案</strong>：双击error进入问题所在脚本，在最上面写“using UnityEngine，UI”,然后把“GUIText”改为“Text”</p>
<h2 id="1-1-2-挂了ThirdPersonAnimatorController但按WASD角色没反应"><a href="#1-1-2-挂了ThirdPersonAnimatorController但按WASD角色没反应" class="headerlink" title="1.1.2 挂了ThirdPersonAnimatorController但按WASD角色没反应"></a>1.1.2 挂了ThirdPersonAnimatorController但按WASD角色没反应</h2><p><strong>解决方案</strong>：<strong>Project Settings-&gt;Player-&gt;Other Settings-&gt;Configuration-&gt;Active Input Handing-&gt;Both</strong></p>
<h1 id="1-2-简要了解Final-IK"><a href="#1-2-简要了解Final-IK" class="headerlink" title="1.2 简要了解Final IK"></a>1.2 简要了解Final IK</h1><h2 id="1-2-1-什么是IK"><a href="#1-2-1-什么是IK" class="headerlink" title="1.2.1 什么是IK"></a>1.2.1 什么是IK</h2><ul>
<li>正向动力学（Forward Kinematics）：每一个子关节的位置、方向由父关节支配（父关节动，子关节跟着动，子关节动，父关节未必动）的动力学模型，比如走路。使用FK做这类动作比较简单（你自己走几下就知道如何设计游戏人物的走路动作）<strong>计算速度快</strong>，但<strong>工作效率低</strong>（因为<strong>几乎所有的父关节都要人工调整</strong>）。</li>
<li>反向动力学（Inverse Kinematics）：依据某些子关节的最终位置、角度反求出整个骨架形态的动力学模型，比如在战斗中挥剑抵挡攻击，让剑去抵挡，也就是依据剑或者持剑的手的状态来调整手的父节点（手腕、肘部、上臂、肩膀和脊柱等）的位置的时候，使用IK能够让格挡动作易于实现，<strong>不必人工调整父节点，交由计算机计算</strong>减少了工作量，但是这么做会<strong>占用计算机资源</strong>，使用IK的关节越多，这种负面效果越明显。</li>
<li>一般的做法：<ul>
<li>FPS游戏（骨骼动画+IK）：在跑动、走路、跳跃、匍匐这类姿势比较单一的动作中使用骨骼动画，而在角色和环境互动的部分（主要是手、脚）使用IK，使得人在上坡时脚面贴着斜坡，可以跨过不同高度的障碍物，拿取不同高度的物品等，充分利用<strong>IK的灵活性</strong>和<strong>IK受物理环境影响</strong>的特性。</li>
<li>需要夸大肢体动作，夸大物理效果的动作类游戏（比如人类一败涂地）：借助IK<strong>依据子关节调整父关节</strong>的特性，做出一些搞笑的效果。</li>
<li>VR：由于VR世界中可以供玩家输入的设备只有头戴显示器和手柄，对应虚拟世界中的头和手，如果我们需要通过手柄和头的动作让虚拟形象其他部位的动作贴近真实，我们可以借助IK技术。</li>
</ul>
</li>
</ul>
<h2 id="1-2-2-为什么是Final-IK"><a href="#1-2-2-为什么是Final-IK" class="headerlink" title="1.2.2 为什么是Final IK"></a>1.2.2 为什么是Final IK</h2><ul>
<li>易于上手，便于学习（在Inspector内就可以做出大部分调整，不用一遍遍回到脚本里改）</li>
<li>可视界面，较为友好（早期甚至不用接触代码）</li>
<li>可以调整的部位比Unity IK多</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Final IK</tag>
        <tag>Ragdoll</tag>
      </tags>
  </entry>
  <entry>
    <title>FinalIK和Ragdoll(2)：FullyBodyBipedIK</title>
    <url>/2022/03/22/FinalIK%E5%92%8CRagdoll(2)/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.bilibili.com/video/BV1CW411N7ri?spm_id_from=333.999.0.0">教程视频</a><br>本文仅供个人学习和知识点记录用。<br>Unity版本：2021.2.15f1c1<br>Final IK版本：2.1<del>（工作室群文件里有）</del><br>Low Poly模型素材包：Heist<br>状态机来源：Unity Standard Assets</p>
<hr>
<h1 id="2-1-FullyBodyBipedIK介绍"><a href="#2-1-FullyBodyBipedIK介绍" class="headerlink" title="2.1 FullyBodyBipedIK介绍"></a>2.1 FullyBodyBipedIK介绍</h1><h2 id="FullyBodyBipedIK还是BipedIK？"><a href="#FullyBodyBipedIK还是BipedIK？" class="headerlink" title="FullyBodyBipedIK还是BipedIK？"></a>FullyBodyBipedIK还是BipedIK？</h2><p><a href="https://www.jianshu.com/p/ddcd668345b5">分析链接</a></p>
<h2 id="FullyBodyBipedIK提供了哪些功能？"><a href="#FullyBodyBipedIK提供了哪些功能？" class="headerlink" title="FullyBodyBipedIK提供了哪些功能？"></a>FullyBodyBipedIK提供了哪些功能？</h2><p>FullyBodyBipedIK自动将模型的骨骼点添加入Reference内，可以通过FullyBodyBipedIK调整骨骼各个结点位置、旋转角度、扭曲程度受IK影响的权重和计算中结点的位置，由于你可以更改这些结点的位置（比如用一个别的什么物体的位置来替代它们），因此可以做出各种效果，比如躯体的扭曲。你也可以通过更改这些替代者的位置来改变模型的姿态。</p>
<h2 id="2-1-1-来看看FullyBodyBipedIK里面有些啥"><a href="#2-1-1-来看看FullyBodyBipedIK里面有些啥" class="headerlink" title="2.1.1 来看看FullyBodyBipedIK里面有些啥"></a>2.1.1 来看看FullyBodyBipedIK里面有些啥</h2><p><img src="../photos/Unity/FinalIK/2_1.png" title="FullyBodyBipedIK"></p>
<ul>
<li>Fix Transforms：勾选则每一帧刷新一次结点状态（对算力消耗大）。</li>
<li>References：IK计算时需要的各个结点位置。<ul>
<li>Root Node：</li>
<li>Weight：一切Weight的权重基数，1为完全受IK影响，0为完全受状态机影响（本处及下文所提到的所有Weight都具有该共性，故仅提一次），它和后面各个结点的Weight是相乘关系（若某结点的Weight是0而References的Weight是1则该结点不受IK影响，若References的Weight是0则无论如何所有结点都不受IK影响。</li>
<li>Iterations：</li>
</ul>
</li>
<li>Target：</li>
<li>Position Weight：结点位置受IK影响的权重。</li>
<li>Rotation Weight：结点旋转受IK影响的权重。</li>
<li>Use Thighs：</li>
<li>Spine Stiffness：</li>
<li>Pull Body Vertical：</li>
<li>Pull Body Horizontal：</li>
<li>Spine Iterations：</li>
<li>Spine Twist Weight：结点扭曲受IK影响的权重。</li>
<li>Maintain Head Rot：</li>
<li>Maintain Relative Position：</li>
<li>Pull：</li>
<li>Push：</li>
<li>Push Parent：</li>
<li>Reach：</li>
<li>Bend Goal：</li>
<li>Bend Goal Weight：</li>
<li>Mapping Weight：</li>
</ul>
<h1 id="2-1-x-问题解决方案"><a href="#2-1-x-问题解决方案" class="headerlink" title="2.1.x 问题解决方案"></a>2.1.x 问题解决方案</h1><ul>
<li>如果有红色/黄色的骨骼点，首先锁住模型的Inspector（在Inspector的右上角）以方便在你调整出错位置时骨骼点仍然显示,对问题骨骼点进行调整直至为蓝点。</li>
<li>如果运动时发现模型的某个部位没有随着模型一起运动（越远离根结点模型的该部位越朝起点倾斜），则要检查FullyBodyBipedIK内的该部位的<strong>Body Effector的Target</strong>是否绑定了该结点。</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>Final IK</tag>
        <tag>Ragdoll</tag>
      </tags>
  </entry>
  <entry>
    <title>UnityVR学习笔记1：准备工作</title>
    <url>/2022/03/03/VR%E5%BC%80%E5%8F%91%E6%97%A5%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.youtube.com/c/ValemVR">原视频作者主页</a><br><a href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">搬运链接</a><br>本文仅供个人学习和知识点记录用。<br>使用设备：Oculus Rift S<br>Unity版本：2020.3.30f1c1</p>
<hr>
<h1 id="Unity内的准备工作"><a href="#Unity内的准备工作" class="headerlink" title="Unity内的准备工作"></a>Unity内的准备工作</h1><p><strong>需要安装的</strong></p>
<ul>
<li>Window-&gt;Package Manager-&gt;XR Interaction Tookit</li>
<li>Edit-&gt;Project Settings-&gt;XR Plugin Management</li>
</ul>
<p><strong>需要设置的</strong><br>Edit-&gt;Project Settings-&gt;XR Plugin Management<br><img src="../photos/Unity/VR/1_1.png"><br><img src="../photos/Unity/VR/1_2.png"></p>
<h2 id="玩家的设置"><a href="#玩家的设置" class="headerlink" title="玩家的设置"></a>玩家的设置</h2><p><strong>玩家内容</strong><br><img src="../photos/Unity/VR/1_3.png" title="玩家内容"><br><strong>玩家组件</strong><br><img src="../photos/Unity/VR/1_4.png" title="玩家组件"><br><strong>相机设置</strong><br><img src="../photos/Unity/VR/1_5.png" title="相机设置"><br><strong>左手柄组件内容</strong><br><img src="../photos/Unity/VR/1_6.png" title="左手柄组件内容"><br><strong>右手传输射线设置</strong><br>Axis To Press Threshold用于设置阈值，当按的深度/力度超过这个阈值即触发传送<br><img src="../photos/Unity/VR/1_7.png" title="右手传输射线设置"></p>
<h1 id="备忘录——一些随便写的注释"><a href="#备忘录——一些随便写的注释" class="headerlink" title="备忘录——一些随便写的注释"></a>备忘录——一些随便写的注释</h1><ul>
<li>teleportation area和teleportation anchor的区别：前者是能传送到平面上任意一点，后者是只能传送到它的组件”Anchor”（锚点）的位置。</li>
<li>如果要使得某些物体不能和射线交互，要在<strong>Teleport Ray</strong>下的<strong>XR Ray Interactor</strong>内的<strong>Interaction Layer Mask</strong>里勾掉这些物体的Layer，一般的做法是专门新建一个被设定不能与射线交互的Layer便于管理。</li>
<li>传送射线的设置在XR Ray Interactor里，更改交互事件在Audio Events和Haptic Events里，勾选后弹出，Duration为持续时间，Intensity是强度</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>VR</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/12/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>使用git bash更新博客遇到的问题与解决方案</title>
    <url>/2022/02/25/%E4%BD%BF%E7%94%A8git%E6%9B%B4%E6%96%B0%E5%8D%9A%E5%AE%A2%E9%81%87%E5%88%B0%E7%9A%84%E9%97%AE%E9%A2%98%E4%B8%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p><strong>此帖仅供参考，不一定适合你的情况，请谨慎采纳，造成的一切后果作者不承担责任。</strong></p>
<h1 id="需要确认的"><a href="#需要确认的" class="headerlink" title="需要确认的"></a>需要确认的</h1><h2 id="sshkey是否生成并添加到github"><a href="#sshkey是否生成并添加到github" class="headerlink" title="sshkey是否生成并添加到github"></a>sshkey是否生成并添加到github</h2><p><strong>如果没有</strong><br><a href="https://blog.csdn.net/u014103733/article/details/79190004">解决方案</a></p>
<h1 id="问题描述与解决方案"><a href="#问题描述与解决方案" class="headerlink" title="问题描述与解决方案"></a>问题描述与解决方案</h1><p> <em>（框架为hexo6.0.0，git bash版本v2.34.1.windows.1主题是ayer）</em>作者在使用git bash部署博客到github时遇到的问题如下：</p>
<ul>
<li>error：10053<ul>
<li>解决方案1（上传较大文件时出现）：在git中输入<strong>git config –global http.postBuffer 524288000</strong></li>
<li>解决方案2(修改postBuffer后还是不行）：网络问题（github的服务器在国外所以连接不稳定），<strong>多hexo g &amp;&amp; hexo d几次就行</strong></li>
</ul>
</li>
<li><strong>添加了sshkey但还是出现了</strong>OpenSSL SSL_connect: Connection was aborted in connection to github.com:443<ul>
<li>解决方案1：挂梯子</li>
<li><strong>挂了梯子还是出现</strong>：看下面情况的解决方案1</li>
</ul>
</li>
<li>fatal: unable to access <a href="https://github.com/">https://github.com/</a> xxxx: Failed to connect to 127.0.0.1 port xxxx:<ul>
<li>解决方案1（修改代理）：<a href="https://blog.csdn.net/qq_42995270/article/details/114903306">解决方案</a>/<a href="https://blog.csdn.net/qq_41102371/article/details/122213285?utm_medium=distribute.pc_aggpage_search_result.none-task-blog-2~aggregatepage~first_rank_ecpm_v1~rank_v31_ecpm-1-122213285.pc_agg_new_rank&utm_term=github%E5%8F%AF%E4%BB%A5%E8%AE%BF%E9%97%AE%E4%BD%86%E6%97%A0%E6%B3%95git&spm=1000.2123.3001.4430">查看id和端口post</a></li>
<li>解决方案2：挂梯子</li>
</ul>
</li>
<li>补充：修改代理可以直接在C盘用户文件夹内搜gitconfig文件，直接进行修改，修改完建议重启git bash以检验。</li>
</ul>
<p><strong>梯子推荐：</strong><a href="https://mojie.me/#/login">魔戒(需付费)</a></p>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>test</tag>
        <tag>git bash</tag>
        <tag>git_error 443</tag>
        <tag>git_error 10053</tag>
        <tag>connection was aborted</tag>
      </tags>
  </entry>
  <entry>
    <title>方法重写与多态</title>
    <url>/2022/02/09/%E5%A4%9A%E6%80%81/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"><a href="#本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。" class="headerlink" title="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"></a>本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。</h2><h1 id="方法重写"><a href="#方法重写" class="headerlink" title="方法重写"></a>方法重写</h1><h2 id="我们为什么需要方法重写？"><a href="#我们为什么需要方法重写？" class="headerlink" title="我们为什么需要方法重写？"></a>我们为什么需要方法重写？</h2><p>有一个父类/超类叫pet，它有两个子类dog和cat，dog和cat有共同的属性名字和性别，有共同的输入和输出信息方法setInfo()和showInfo(),将这些属性和方法都写在父类里。现在有新的要求，dog增加了一个属性是品种，cat增加了一个属性是体重，这时候发现方法原来的写法不能同时满足两个子类不同属性的输出，此时我们提出三种解决方案：</p>
<ol>
<li>删除父类的方法，在子类内分别写方法并调用：这种方法简单粗暴，但是一旦像这样的同时具有相同和不同属性与方法的子类增多，会使得代码有很多重复的部分，增大了工作量。</li>
<li>保留父类的方法，同时将不同的部分分别写入子类专属的方法内：这种方法较上一种的工作量减少了，但是在调用的时候会变得麻烦，既然都是输入输出信息的功能，为什么不让它们名称相同呢？</li>
<li>子类<strong>重写</strong>父类方法：<ul>
<li>子类根据需求对从父类继承的方法进行重新编写</li>
<li>重写时，可以用super.方法的方式保留父类的方法</li>
<li><strong>构造方法不能被重写</strong></li>
</ul>
</li>
</ol>
<h2 id="方法重写的规则"><a href="#方法重写的规则" class="headerlink" title="方法重写的规则"></a>方法重写的规则</h2><ul>
<li><strong>方法名相同</strong></li>
<li><strong>参数列表相同</strong></li>
<li><strong>返回值类型相同或是其子类</strong></li>
<li><strong>访问权限不能严于父类</strong></li>
<li><strong>父类的私有方法不能被子类覆盖</strong></li>
<li><strong>子类方法不能抛出比父类方法更多的异常</strong></li>
<li><strong>父类的静态方法不能被子类覆盖为非静态方法，父类的非静态方法也不能被子类覆盖为静态方法</strong></li>
<li>由于super不能在静态方法中使用，因此子类可以定义与父类同名的静态方法，以便在子类中隐藏父类的静态方法</li>
</ul>
<h2 id="代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）"><a href="#代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）" class="headerlink" title="代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（说什么我都开摆！）"></a>代码示例（因仅供个人学习用，因此略写了测试类，且由于两个子类大同小异，故只给出cat类（<del>说什么我都开摆！</del>）</h2><h3 id="父类写法"><a href="#父类写法" class="headerlink" title="父类写法"></a>父类写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Pet &#123;//父类</span><br><span class="line">    //按照方法1的写法，这里可以啥都没有x</span><br><span class="line">    public String name;//方法2中这里要保留</span><br><span class="line">    public String sex;</span><br><span class="line">    //方法3写法（方法2中父类的写法和方法3一致，故略）</span><br><span class="line">    public void setInfo(String name, String sex)&#123;</span><br><span class="line">    	this.name=name;</span><br><span class="line">    	this.sex=sex;</span><br><span class="line">    &#125;</span><br><span class="line">    public void showInfo()&#123;</span><br><span class="line">    	System.out.println(&quot;宠物的名字是：&quot;+name+&quot;，宠物的性别是：&quot;+sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="子类写法"><a href="#子类写法" class="headerlink" title="子类写法"></a>子类写法</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Cat extends Pet&#123;//子类</span><br><span class="line">    private float weight;//体重</span><br><span class="line">    private String name;//名字</span><br><span class="line">    private String sex;//性别</span><br><span class="line">    /*方法1写法</span><br><span class="line">     public void setInfo(String name,String sex, float weight)&#123;</span><br><span class="line">    	 this.name = name;//这里实际上略写了name和sex的声明，这两个属性的声明可以在父类中以public关键字做保留，也可以在子类中写</span><br><span class="line">    	 this.sex = sex;</span><br><span class="line">    	 this.weight = weight;</span><br><span class="line">     &#125;</span><br><span class="line">     public void showInfo()&#123;</span><br><span class="line">    	 System.out.println(&quot;宠物的名字是：&quot;+name+&quot;，宠物的性别是：&quot;+sex+&quot;，猫的体重是&quot;+weight);</span><br><span class="line">     &#125;</span><br><span class="line">     */</span><br><span class="line">    /*方法2写法</span><br><span class="line">     public void setInfo(String name,String sex, float weight)&#123;</span><br><span class="line">    	 this.name = name;</span><br><span class="line">    	 this.sex = sex;</span><br><span class="line">    	 this.weight = weight;</span><br><span class="line">     &#125;</span><br><span class="line">     public void showCatInfo()&#123;//注意此处的改名</span><br><span class="line">         showInfo();</span><br><span class="line">    	 System.out.println(&quot;猫的体重是&quot;+weight);</span><br><span class="line">     &#125;</span><br><span class="line">     */</span><br><span class="line">    //方法3写法</span><br><span class="line"></span><br><span class="line">    public void showInfo()&#123;</span><br><span class="line">    	super.showInfo();</span><br><span class="line">        System.out.println(&quot;猫的体重是&quot;+weight+&quot;kg&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Super"><a href="#Super" class="headerlink" title="Super"></a>Super</h2><ul>
<li>super可以用来访问父类的<strong>非私有（private）成员</strong></li>
<li><strong>静态方法中不能出现super</strong></li>
<li>当子类中定义了和父类同名的成员时，super可以使被屏蔽的成员可见</li>
<li>super只能出现在<strong>子类的方法和构造方法中</strong></li>
<li>super调用父类构造方法时，只能是super所在方法的第一句</li>
<li>super可以用于调用<strong>继承关系中最近</strong>的父类/间接父类的成员<ul>
<li>当子类、父类、间接父类中都有同名的成员时（子类重写/覆盖父类，父类重写/覆盖间接父类）时，子类中使用super只能访问父类的成员。</li>
<li>当子类和间接父类中有同名成员时，子类中使用super可以访问<strong>继承关系中最近</strong>的间接父类成员。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//访问父类方法</span><br><span class="line">super.print();</span><br><span class="line">//访问父类属性</span><br><span class="line">super.name;</span><br><span class="line">//访问父类构造方法</span><br><span class="line">super();</span><br><span class="line">super(name)</span><br></pre></td></tr></table></figure>
<h3 id="super和this比较"><a href="#super和this比较" class="headerlink" title="super和this比较"></a>super和this比较</h3><table>
<thead>
<tr>
<th>区别</th>
<th align="center">this</th>
<th align="right">super</th>
</tr>
</thead>
<tbody><tr>
<td>访问属性</td>
<td align="center">访问<strong>本类</strong>属性，如果没有则从父类找</td>
<td align="right">访问<strong>父类</strong>属性</td>
</tr>
<tr>
<td>访问普通方法</td>
<td align="center">访问<strong>本类</strong>普通方法，如果没有则从父类找</td>
<td align="right">访问<strong>父类</strong>普通方法</td>
</tr>
<tr>
<td>访问构造方法</td>
<td align="center">调用<strong>本类</strong>构造，放在构造方法首行</td>
<td align="right">调用<strong>父类</strong>构造，放在子类构造方法首行</td>
</tr>
</tbody></table>
<h3 id="继承条件下的构造方法"><a href="#继承条件下的构造方法" class="headerlink" title="继承条件下的构造方法"></a>继承条件下的构造方法</h3><ul>
<li>当子类构造方法没有通过super显式调用父类的<strong>带参</strong>构造方法，也没有通过this显式调用自身其他构造方法时，系统默认调用父类的<strong>无参构造方法</strong></li>
<li>相对的，当子类构造方法通过super显式调用父类的<strong>带参构造方法</strong>时，系统执行父类的带参构造方法而不执行父类的<strong>无参构造方法</strong></li>
<li>子类构造方法通过this显式调用自身的其他构造方法，在相应构造方法中应用上述两条规则</li>
<li><strong>注意，子类的构造方法在执行时，无论是否有显式给出，父类的构造方法在逻辑顺序上永远是第一个执行的</strong></li>
</ul>
<h1 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h1><h2 id="Object类是什么？"><a href="#Object类是什么？" class="headerlink" title="Object类是什么？"></a>Object类是什么？</h2><ul>
<li><strong>Object类是所有类的直接或间接父类</strong>，而且是继承关系<strong>最远</strong>的那个直接或间接父类<h2 id="Object类有什么？"><a href="#Object类有什么？" class="headerlink" title="Object类有什么？"></a>Object类有什么？</h2></li>
<li><strong>自己找个IDE（比如myeclipse），新建类然后写个this，Object类里的东西就在提示弹窗里显示出来了</strong></li>
<li>Object类被子类经常重写的方法<ul>
<li><strong>toString()</strong>: 返回当前对象本身的有关信息，按字符串对象返回</li>
<li><strong>equals()</strong>: 比较两个对象是否是同一个对象，是则返回true</li>
<li><strong>hashCode()</strong>: 返回该对象的哈希值</li>
<li><strong>getClass()</strong>: 获取当前对象所属的类信息，返回Class对象</li>
</ul>
</li>
</ul>
<p><strong>此处的小补充</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//equals函数判断是否是一个对象的依据是看两个对象是否占用同一处内存</span><br><span class="line">//这里假设有一个Student类</span><br><span class="line">Student s1 = new Student();</span><br><span class="line">Student s2 = new Student();</span><br><span class="line">Student s3 = s1;</span><br><span class="line">System.out.println(s1.equals(s3));//结果为true</span><br><span class="line">System.out.println(s1.equals(s2));//结果为false，因为二者成员虽然一样，但在不占用同一处内存。</span><br></pre></td></tr></table></figure>
<h2 id="重写Object类的方法（此处以重写equals方法为例）"><a href="#重写Object类的方法（此处以重写equals方法为例）" class="headerlink" title="重写Object类的方法（此处以重写equals方法为例）"></a>重写Object类的方法（此处以重写equals方法为例）</h2><p>我们接着上面的问题来，如果两个学生类的所有属性都一样，按理说它们指的就是一个人，但按照equals()的原理却不能认为两个对象相同，即当<strong>认为属性相同就是同一对象</strong>时，就有了重写equals()的需要。<br>代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//如果两个学生的属性（此处为姓名name和学号sid）相同，就认为是同一个学生对象。</span><br><span class="line">public boolean equals(Object obj)&#123;//注意，此处是Student的equals方法。</span><br><span class="line">    //如果占用的是同一处内存</span><br><span class="line">    if(this == obj)&#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">    //此处应用instanceof运算符，“对象a instanceof 类型b”的意思是判断a是否为b的实例</span><br><span class="line">    elif(!(obj instance of Student))&#123;//如果对象不是Student类型</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    Student s = (Student)Obj;//将Obj强制转换为student类型，这里实际上也可以省去这一步，但是这样更保险一些。</span><br><span class="line">    if (this.name==s.name&amp;&amp;this.sid==s.sid)//这里判断name是否相同还有一种写法就是“this.name.equals(s.name)”，由此可见Java.lang.String已经重写过一遍equals方法，使其可以用于判断字符串是否相同。</span><br><span class="line">        return true;</span><br><span class="line">    else</span><br><span class="line">    return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><h2 id="我们为什么需要多态？"><a href="#我们为什么需要多态？" class="headerlink" title="我们为什么需要多态？"></a>我们为什么需要多态？</h2><p>接着上面说过的dog、cat和pet类继续讲，现在我们设定pet类增加了健康值health这个属性，当健康值小于50时，认定宠物生病了，需要治疗，我们将治疗方法cure()放在新建的主人类master里，治疗方法的内容是显示治疗方案和修改宠物实例的health值为60。而不同的宠物需要不同的治疗方式，我们设定治疗猫时需要显示“打针”，治疗狗时需要显示“吃药”。我们可以使用<strong>方法重载</strong>来实现，主人类的代码此时如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Master&#123;</span><br><span class="line">    public void cure(Cat cat)&#123;</span><br><span class="line">        if(cat.health&lt;50)&#123;</span><br><span class="line">         System.out.println(&quot;打针&quot;);</span><br><span class="line">         cat.health=60;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    public void cure(Dog dog)&#123;</span><br><span class="line">        if(dog.health&lt;50)&#123;</span><br><span class="line">         System.out.println(&quot;吃药&quot;);</span><br><span class="line">         dog.health=60</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>但当宠物的种类变多时，这种写法会需要频繁修改，更不用说如果不止是主人类需要有这个cure方法，<strong>还有其他和主人类类似的类需要有这个cure方法时</strong>，就会导致代码<strong>臃肿、可扩展性、可维护性差</strong>，因此我们需要多态来优化。</p>
<h2 id="什么是多态？"><a href="#什么是多态？" class="headerlink" title="什么是多态？"></a>什么是多态？</h2><p>多态：<strong>同一个引用类型，使用不同的实例而执行不同的操作</strong><br><strong>使用父类作为方法的形参，是Java中实现和使用多态的主要方式。</strong><br><strong>使用父类作为方法的返回值，也是Java中实现和使用多态的主要方式。</strong><br>我们接着来看刚才的例子。我们的优化思路是将治疗方法cure移到父类pet内，pet的各个子类重写父类的pet方法，此时主人类、父类、子类的代码简化如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public void cure(Pet pet)&#123;//父类作为方法的形参</span><br><span class="line">        if(pet.health&lt;50)&#123;</span><br><span class="line">          pet.cure();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pet&#123;//父类写法</span><br><span class="line">     public int health;</span><br><span class="line">     public String name;</span><br><span class="line">     public String sex;</span><br><span class="line">     public void cure()&#123;</span><br><span class="line">       //这里不要写属性的修改，因为修改的是子类的属性（我好像在说废话x）</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Cat extends Pet&#123;//子类写法</span><br><span class="line">    public void cure()&#123;</span><br><span class="line">        System.out.println(&quot;打针&quot;);</span><br><span class="line">        this.heatlh=60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里附上一个<strong>父类作为方法的返回值</strong>的多态用法，假设我们要送动物给别人。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public Pet sendPet(int type)&#123;//以父类作为返回对象，也是多态的一种用法</span><br><span class="line">        Pet pet = null;</span><br><span class="line">        switch(type)&#123;</span><br><span class="line">            case 1:</span><br><span class="line">                 Pet pet=new Cat();</span><br><span class="line">                 break;</span><br><span class="line">            case 2:</span><br><span class="line">                 Pet pet=new Dog();</span><br><span class="line">                 break;</span><br><span class="line">            default:</span><br><span class="line">                System.out.println(&quot;私密马赛！没有这种宠物&quot;);</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">        return pet;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong>，这时你再构建对象，你就得写成<strong>Pet xx = new Xx()<strong>，即</strong>向上转型</strong>这里和以前的写法规定不一样了。而当master的cure函数收到Pet类型的对象时，系统会<strong>找到这个对象指向的具体的类型Xx</strong>,也就是实际上在调用时将其<strong>视作Xx类型的对象</strong>。</p>
<h3 id="关于向上（向下）转型"><a href="#关于向上（向下）转型" class="headerlink" title="关于向上（向下）转型"></a>关于向上（向下）转型</h3><p>上文中我们把<strong>父类类型引用变量指向子类对象，自动进行类型转换</strong>的写法称为<strong>向上转型</strong>，自然地，我们也将<strong>父类类型引用变量强制转换为子类类型引用变量</strong>的写法称为<strong>向下转型</strong>。</p>
<h4 id="我们为什么需要转型"><a href="#我们为什么需要转型" class="headerlink" title="我们为什么需要转型"></a>我们为什么需要转型</h4><p>当我们需要以多态写法（我个人将多态理解成一种写法）去简化调用这些子类的方法时，我们需要将参数表里传入的类型向上转型成子类共同继承的父类类型来使方法在具备简洁的方法体的同时可以<strong>灵活调用各个子类重写的父类方法</strong>，而当我们需要调用子类的<strong>特有方法</strong>时，由于<strong>父类对象不能调用子类特有的方法</strong>就需要将其强制转换回子类，即向下转型，从而实现调用。</p>
<h4 id="转型需要注意的地方"><a href="#转型需要注意的地方" class="headerlink" title="转型需要注意的地方"></a>转型需要注意的地方</h4><ul>
<li><strong>向上转型后只能调用子类覆盖或继承父类的方法，不能调用子类特有的方法</strong></li>
<li>在向下转型的过程中<strong>如果没有转换成真实子类类型，会出现类型转换异常</strong>，来看下面的代码。</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test()&#123;//测试类</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        Pet dog = new Dog();//先来个向上转型</span><br><span class="line">        Cat cat = (Cat) dog;//再来个向下转型</span><br><span class="line">        cat.meow();//让猫（实际上是“变成猫”的狗）调用喵喵叫方法（狗肯定不会喵喵叫啊所以是猫的特有方法）</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码在写的时候IDE不会给你报错，也就是没有语法问题。但当你编译它的时候，IDE会告诉你存在编译错误（至少我的Myeclipse是这样）<strong>java.lang.ClassCastException:Dog cannot be cast to Cat</strong>（<strong>类型转换异常</strong>：狗变不成猫！），所以注意，向下转型时如果没有转化为真实的子类类型，会触发类型转换异常。<br>如果想要避免类型转换异常的出现，我们可以借助<strong>instanceof</strong>来进行辅助判断，来看下面的代码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Test()&#123;//测试类</span><br><span class="line">    public static void main(String[]args)&#123;</span><br><span class="line">        Pet dog = new Dog();//先来个向上转型</span><br><span class="line">        if (dog instanceof Dog)&#123;</span><br><span class="line">            dog.bark();//汪汪汪</span><br><span class="line">        &#125;</span><br><span class="line">        elif(dog instanceof Cat)&#123;</span><br><span class="line">            cat.meow();//喵喵喵</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>注意</strong>，使用instanceof时，对象的类型必须和instanceof后面的类<strong>在继承上有上下级关系</strong></li>
</ul>
]]></content>
      <categories>
        <category>课程笔记_面向对象编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>方法重写</tag>
        <tag>多态</tag>
        <tag>super</tag>
        <tag>Object类</tag>
        <tag>instanceof</tag>
        <tag>面向对象编程oop</tag>
      </tags>
  </entry>
  <entry>
    <title>抽象类和接口</title>
    <url>/2022/02/13/%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"><a href="#本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。" class="headerlink" title="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"></a>本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。</h2><h1 id="抽象方法和抽象类（欧内的手方法和奥利安费类）"><a href="#抽象方法和抽象类（欧内的手方法和奥利安费类）" class="headerlink" title="抽象方法和抽象类（欧内的手方法和奥利安费类）"></a>抽象方法和抽象类（<del>欧内的手方法和奥利安费类</del>）</h1><h2 id="抽象方法"><a href="#抽象方法" class="headerlink" title="抽象方法"></a>抽象方法</h2><p><a href="https://daniel-qi-114514.github.io/2022/02/09/%E5%A4%9A%E6%80%81/">书接上文</a></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Master&#123;//主人类写法</span><br><span class="line">    public void cure(Pet pet)&#123;//父类作为方法的形参</span><br><span class="line">        if(pet.health&lt;50)&#123;</span><br><span class="line">          pet.cure();</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Pet&#123;//父类写法</span><br><span class="line">     public int health;</span><br><span class="line">     public String name;</span><br><span class="line">     public String sex;</span><br><span class="line">     public void cure()&#123;</span><br><span class="line">       //这里不要写属性的修改，因为要修改的是子类的属性（我好像在说废话x）</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Cat extends Pet&#123;//子类写法</span><br><span class="line">    public void cure()&#123;</span><br><span class="line">        System.out.println(&quot;打针&quot;);</span><br><span class="line">        this.heatlh=60;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们注意到，在上面Pet类里的cure方法内没有具体内容，而它的实现在子类里，此时我们就可以将它写成<strong>public abstract void cure();<strong>，也就是将其写成一个</strong>抽象方法</strong>。而抽象方法所在的类也要通过<strong>public abstract class Pet</strong>的改写来转变为<strong>抽象类</strong>。</p>
<h2 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h2><p>当声明这个类的一个对象是没有意义的时候，就可以将这个类写为抽象类，<strong>抽象类不能被实例化</strong>。</p>
<h2 id="需要注意"><a href="#需要注意" class="headerlink" title="需要注意"></a>需要注意</h2><ul>
<li><strong>抽象类不能被实例化（不存在抽象构造方法），但可以创建一个抽象类的引用变量指向非抽象的子类实例</strong>。</li>
<li><strong>如果子类没有实现父类的所有抽象方法，子类必须被定义为抽象类</strong>。</li>
<li>抽象方法没有方法体</li>
<li><strong>抽象方法必须在抽象类里，而抽象类里可以没有抽象方法。</strong></li>
<li>不存在抽象静态方法</li>
<li><strong>抽象类可以有非抽象构造方法，因为构造非抽象子类实例时可能需要用到，这样可以节省代码</strong></li>
<li>抽象方法<strong>必须在子类中被实现</strong>，<strong>除非子类是抽象类</strong><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2></li>
<li>当子类们既有共性方法又有各自特性方法的时候，我们可以通过声明抽象方法和抽象类来简化代码、方便调用。</li>
</ul>
<h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><h2 id="我们为什么需要接口"><a href="#我们为什么需要接口" class="headerlink" title="我们为什么需要接口"></a>我们为什么需要接口</h2><p>我们知道一个类只能有一个父类，而当<strong>一个类需要继承多组相互之间不相关的方法</strong>时，这些方法都塞在一个父类里或者多个间接父类里显然不合理，因此我们需要多个<strong>接口</strong>来存放和管理各组方法。</p>
<h2 id="什么是接口"><a href="#什么是接口" class="headerlink" title="什么是接口"></a>什么是接口</h2><ul>
<li>概念性的接口指系统对外提供的所有服务。</li>
<li><strong>interface</strong>定义的接口叫<strong>接口类型</strong>,<strong>但是接口不是类</strong></li>
<li>JDK8之前的接口特性<ul>
<li>接口中的变量默认都是静态常量，必须显式初始化</li>
<li>接口中所有方法默认都是抽象方法</li>
<li>接口没有构造方法，不可以被实例化，但可以被实现</li>
<li>通过<strong>implements</strong>关键字声明实现类，一个实现类可以实现多个接口</li>
<li>实现类必须实现接口的所有方法，<strong>除非实现类也是一个抽象类</strong></li>
</ul>
</li>
<li>JDK8新增接口特性1：<strong>接口内可以有默认方法</strong>了<ul>
<li>通过<strong>default</strong>关键字来声明默认方法，<strong>默认方法的用处在于简化代码，降低实现类和接口的耦合度，提升代码可维护性</strong></li>
<li>默认方法可以被继承，通过实例调用</li>
<li>如果一个类实现了多个接口，多个接口都定义了多个同样的默认方法<ul>
<li>实现方案1：实现类需要覆盖重写接口中的默认方法不然会报错</li>
<li>实现方案2：可以使用this来调用指定接口的默认方法</li>
</ul>
</li>
<li>如果一个类继承了一个抽象类，实现了一个接口，抽象类和接口存在相同的方法<ul>
<li>采取类优先的原则，有限继承抽象类的方法</li>
</ul>
</li>
</ul>
</li>
<li>JDK8新增接口特性2：**接口内可以声明（并且可以提供实现）静态方法了<ul>
<li>回顾：静态方法可以直接用类名调用（不用专门new一个对象了）</li>
<li>接口中的静态方法必须是public的，public修饰符可以省略，static修饰符不能省略</li>
<li>静态方法不能被继承及重写，所以只能被具体所在的接口调用</li>
<li>接口中可以有多个静态方法。</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*接口格式</span><br><span class="line">访问修饰符 interface 接口名称 extends 其他接口名（如果有的话）&#123;</span><br><span class="line">    声明变量</span><br><span class="line">    声明方法</span><br><span class="line">&#125;*/</span><br><span class="line">//接口示例</span><br><span class="line">public interface Interface1&#123;</span><br><span class="line">     public static final double PI =3.14;//在接口里，你写个double PI =3.14 也等同于左边的写法</span><br><span class="line">     public void m2();//等同于 public abstract void m2();</span><br><span class="line">     default void m3()&#123;</span><br><span class="line">         System.out.println(&quot;已调用接口Interface1中的默认方法m3&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br><span class="line">//实现类示例</span><br><span class="line">public class Implementation implements Interface1&#123;//多个接口间用逗号隔开</span><br><span class="line">     public void m2()&#123;</span><br><span class="line">         System.out.println(&quot;实现用接口Interface1中的默认方法m2&quot;);</span><br><span class="line">     &#125;</span><br><span class="line">     public void usem3()&#123;</span><br><span class="line">         this.m3();</span><br><span class="line">     &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="抽象类和接口的比较"><a href="#抽象类和接口的比较" class="headerlink" title="抽象类和接口的比较"></a>抽象类和接口的比较</h2><ul>
<li>相同点<ul>
<li>代表系统的抽象层</li>
<li>都不能被实例化</li>
<li>都能包含抽象方法</li>
</ul>
</li>
<li>不同点<ul>
<li>在抽象类中可以为部分普通方法提供默认实现，而接口在JDK8之前只能包含抽象方法，JDK8之后接口可包含默认方法</li>
<li> 一个类只能继承一个直接的父类，但可以实现多个接口</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记_面向对象编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象编程oop</tag>
        <tag>抽象类</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>异常与异常处理</title>
    <url>/2022/02/14/%E5%BC%82%E5%B8%B8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"><a href="#本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。" class="headerlink" title="本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。"></a>本文为华为开发者学堂-面向对象编程的课程笔记，仅供个人学习使用。</h2><h1 id="异常与异常处理"><a href="#异常与异常处理" class="headerlink" title="异常与异常处理"></a>异常与异常处理</h1><h2 id="什么是异常和异常处理"><a href="#什么是异常和异常处理" class="headerlink" title="什么是异常和异常处理"></a>什么是异常和异常处理</h2><p>异常：<strong>异常是在程序的运行过程中所发生的不正常的事件，它会中断正在运行的程序</strong>。在Java中，它是一种特殊的对象，类型为java.lang.Exception或其子类<br>如何解决呢？</p>
<ul>
<li>程序员通过代码堵住程序可能出现的漏洞</li>
<li>程序员在设计程序的阶段预测可能出现的异常并写好对应措施，当程序遇到这些异常时，会按照事先规定好的代码去处理异常而不含让程序中断运行</li>
<li>IDE和编程语言提供的<strong>异常处理机制</strong>（标红，报错等等）</li>
</ul>
<h2 id="异常处理机制"><a href="#异常处理机制" class="headerlink" title="异常处理机制"></a>异常处理机制</h2><ul>
<li>Java的异常处理是通过<strong>try、catch、finally、throw和throws</strong>五个关键字来完成的，<strong>try执行可能产生异常的代码，catch捕获异常，无论是否发生异常，finally中的代码总能执行，throws声明方法可能要抛出的各种异常，throw手动抛出异常</strong></li>
<li>Java内的异常Exception是一个<strong>类</strong>，catch要捕获的是Exception类的对象<ul>
<li>常见的异常类型<ul>
<li><strong>Exception</strong>:异常层次结构的父类</li>
<li><strong>ArithmeticException</strong>:算术错误</li>
<li><strong>InputMismatchException</strong>：输入格式不匹配 <em>（比如要求输入int但得到字符串）</em></li>
<li><strong>ArrayIndexOutOfBoundsException</strong>:数组下标越界</li>
<li><strong>NullPointerException</strong>:尝试访问null对象成员 <em>（比如你将一个字符串用equals()跟指向null的字符串比较）</em></li>
<li><strong>ClassNotFoundException</strong>:不能加载所需的类 <em>（比如打错类名了）</em></li>
<li><strong>lllegalArgumentException</strong>:方法接收到非法参数</li>
<li><strong>ClassCastException</strong>:对象强制类型转换错误</li>
<li><strong>NumberFormatException</strong>:数字格式转换异常 <em>（比如把“abc”转换成数字）</em></li>
</ul>
</li>
</ul>
</li>
<li>在catch块中处理异常：<ul>
<li>使用**System.err.println()**来输出错误反馈信息</li>
<li>使用**e.printStackTrace()**来输出异常的堆栈信息并跟踪异常产生的位置和过程</li>
<li>使用**e.getMessage()**得到描述异常的字符串，而该字符串是printStackTrace()输出信息的一部分，如果异常没有描述字符串则输出null</li>
</ul>
</li>
<li>关于多重catch块<ul>
<li>排列catch语句的顺序：<strong>先子类后父类</strong></li>
<li>发生异常时按顺序逐个匹配</li>
<li><strong>只执行第一个与异常类型匹配的catch语句</strong></li>
</ul>
</li>
</ul>
<h3 id="try-catch-finally"><a href="#try-catch-finally" class="headerlink" title="try-catch-finally"></a>try-catch-finally</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//使用try-catch-finally处理、捕捉异常，分为三种情况：</span><br><span class="line">public void method()&#123;</span><br><span class="line">    try&#123;</span><br><span class="line">        //可能产生异常的代码块</span><br><span class="line">    &#125;</span><br><span class="line">    catch(异常类型 ex)&#123;</span><br><span class="line">        //对异常进行处理的代码段</span><br><span class="line">    &#125;</span><br><span class="line">    finally&#123;</span><br><span class="line">        //无论如何都会执行的代码段，除了极个别情况</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//第一种情况：无事发生，执行顺序：try——&gt;finally（跳过catch）</span><br><span class="line">//第二种情况：产生可以处理的异常：try（try内产生异常的行后面的代码不会被执行）——&gt;catch——&gt;finally（除非catch内的处理方法里有退出Java虚拟机方法System.exit(1)，否则继续）</span><br><span class="line">//第三种情况：产生异常类型不匹配：try——&gt;产生的异常会和catch的异常类型进行匹配，如果不匹配则中断运行，但是一定会在中断之前执行finally</span><br></pre></td></tr></table></figure>
<h3 id="使用throws声明异常"><a href="#使用throws声明异常" class="headerlink" title="使用throws声明异常"></a>使用throws声明异常</h3><p>如果一个方法体可能抛出异常，我们使用throws声明可能抛出的各种异常，异常之间用逗号隔开<br>调用者的对应方式有：</p>
<ul>
<li>处理异常</li>
<li>继续声明异常，比如a方法声明了异常，调用它的b方法不解决异常，可以继续声明a的异常，由于这些方法最后都会回到main方法，所以如果这些方法都不解决异常，就交给虚拟机处理 <em>main方法声明的异常由Java虚拟机处理</em></li>
</ul>
<h3 id="使用throw抛出异常"><a href="#使用throw抛出异常" class="headerlink" title="使用throw抛出异常"></a>使用throw抛出异常</h3><p>写法见以下代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">throw new 某类型Exception(&quot;异常信息&quot;);//当使用throw显式抛出异常，必须对异常处理，或throws声明异常</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th>throw</th>
<th align="center">throws</th>
</tr>
</thead>
<tbody><tr>
<td>生成并抛出异常</td>
<td align="center">声明方法内抛出了异常</td>
</tr>
<tr>
<td>位于方法体内部，可作为单独语句使用</td>
<td align="center">必须跟在方法参数列表后面，不能单独使用</td>
</tr>
<tr>
<td>抛出一个异常对象，且只能是一个</td>
<td align="center">声明抛出异常类型，可以用来一次声明多个异常类型</td>
</tr>
</tbody></table>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ul>
<li>如果在try和catch中遇到return，<strong>先执行finally，再执行return</strong>、</li>
<li>try\catch\finally可以任意组合， 但必须有try，catch和finally至少出现一个</li>
<li>如果方法内产生异常却不在方法内处理 <em>有throw但没有catch</em>，就必须使用throws声明该异常</li>
</ul>
<h2 id="异常体系结构"><a href="#异常体系结构" class="headerlink" title="异常体系结构"></a>异常体系结构</h2><p>我们注意到，Exception对象的直接父类是Throwable类，而Throwable类除了Exception类这个直接子类外，还有一个直接子类叫Error。Error为<strong>仅靠程序本身无法恢复的严重错误，代表Java虚拟机的底层问题</strong>（比如AWTError <em>（发生严重的Abstract Window Toolkit错误时抛出）</em>、线程意外终止ThreadDeath等、内存溢出OutOfMemoryError）而Exception为<strong>由Java应用程序抛出和处理的非严重错误</strong>。而Exception又进一步可细分为<strong>Checked异常和运行时异常RuntimeException</strong>，Checked异常在编译时会被检查出来，程序必须处理该类异常，如ClassNotFoundException、ClassCastException等。RuntimeException表示该异常为运行时可能出现的异常，在编译时不会检查的异常，不要求程序必须做出处理，如ArithmeticException算术异常、调用null对象异常NullPointerException等，这些异常一般是由程序的逻辑错误引起的。</p>
<h2 id="自定义异常"><a href="#自定义异常" class="headerlink" title="自定义异常"></a>自定义异常</h2><h2 id="异常链与异常处理原则"><a href="#异常链与异常处理原则" class="headerlink" title="异常链与异常处理原则"></a>异常链与异常处理原则</h2>]]></content>
      <categories>
        <category>课程笔记_面向对象编程</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>面向对象编程oop</tag>
        <tag>异常</tag>
        <tag>try-catch-finally</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记1</title>
    <url>/2022/04/03/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="依照学校教学安排，第一章为操作系统引论"><a href="#依照学校教学安排，第一章为操作系统引论" class="headerlink" title="依照学校教学安排，第一章为操作系统引论"></a>依照学校教学安排，第一章为操作系统引论</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用虚拟机平台VMware-Workstation"><a href="#使用虚拟机平台VMware-Workstation" class="headerlink" title="使用虚拟机平台VMware Workstation"></a>使用虚拟机平台VMware Workstation</h1><hr>
<h1 id="1-1-操作系统的目标和作用"><a href="#1-1-操作系统的目标和作用" class="headerlink" title="1.1 操作系统的目标和作用"></a>1.1 操作系统的目标和作用</h1><h2 id="1-1-1-操作系统的目标（考点）"><a href="#1-1-1-操作系统的目标（考点）" class="headerlink" title="1.1.1 操作系统的目标（考点）"></a>1.1.1 操作系统的目标（考点）</h2><ul>
<li><strong>方便性</strong>：没有OS的计算机是极难使用的，只能使用机器语言，OS对计算机操作进行了抽象化，使计算机便于易学易用。</li>
<li><strong>有效性</strong>：OS可以通过合理地组织计算机的工作流程，加速程序的运行，缩短程序的运行周期，提高系统的吞吐量。</li>
<li><strong>可扩充性</strong>：为适应计算机硬件、体系结构以及计算机应用发展的要求，OS必须具有很好的可扩充性，这与OS的结构有十分紧密的联系，由此推动OS从早期的无结构发展为模块化结构，进而又发展为层次化结构，近年来OS已广泛采用微内核结构。</li>
<li><strong>开放性</strong>：为适应计算机应用日益普及的要求和互联网时代的发展，使OS的应用环境从单机转向网络环境，其使用环境必须更为开放，要求OS必须能遵循世界标准规范，从而兼容以相同标准开发的硬件软件。</li>
</ul>
<h2 id="1-1-2-操作系统的作用（考点）（见1-4）"><a href="#1-1-2-操作系统的作用（考点）（见1-4）" class="headerlink" title="1.1.2 操作系统的作用（考点）（见1.4）"></a>1.1.2 操作系统的作用（考点）（见1.4）</h2><ul>
<li><strong>OS是用户与计算机硬件系统之间的接口</strong></li>
<li><strong>OS是计算机系统资源的管理者</strong></li>
<li><strong>OS实现了对计算机资源的抽象</strong></li>
<li><strong>OS/虚拟机是计算机硬件平台上的虚拟机器</strong></li>
</ul>
<h2 id="1-1-3-推动操作系统发展的主要动力（考点）"><a href="#1-1-3-推动操作系统发展的主要动力（考点）" class="headerlink" title="1.1.3 推动操作系统发展的主要动力（考点）"></a>1.1.3 推动操作系统发展的主要动力（考点）</h2><ul>
<li><strong>不断提高计算机资源利用率</strong></li>
<li><strong>方便用户</strong></li>
<li><strong>硬件的不断更新换代</strong></li>
<li><strong>计算机体系结构的不断发展</strong></li>
<li><strong>不断提出新的应用需求</strong></li>
</ul>
<h1 id="1-2-操作系统的发展过程"><a href="#1-2-操作系统的发展过程" class="headerlink" title="1.2 操作系统的发展过程"></a>1.2 操作系统的发展过程</h1><ul>
<li>人工操作方式：卡带I/O，一个程序运行完毕并取走计算结果（卡带）后下一个人/程序才能上机，效率极低，人工读带（参考《功勋》里面于敏那集，人工读机器语言，属实是黑客帝国现实版了）。</li>
<li>脱机I/O方式：事先将装有用户程序和数据的纸带装入纸带输入及，在一台外围机的控制下将卡带上的数据或程序输入到磁带上，当CPU需要这些程序或数据时再从磁带上高速地调入内存。输出时先从内存高速输送到磁带上，然后在外围机控制下通过相应输出设备输出。（个人理解是用磁带来当一个缓存），减少了CPU的空闲时间，I/O操作均由外围机操作，提高了I/O速度。</li>
<li>单道批处理系统：处理完一个作业后紧接着处理下一个作业以减少机器的空闲等待时间，旨在提高系统资源利用率，但缺点也在用提高的不够充分，这是因为在内存中仅有一道程序，必须在I/O完成后才能运行，又因为I/O设备的低速性，更使CPU的利用率显著降低。若通过增大内存来提高效率，则会因为实际中80%以上的作业都属于中小型而造成在单道程序环境下对内存的浪费。</li>
<li><strong>多道批处理系统</strong>：用户所提交的作业先存放在外存上，并排成一个队列称为“后备队列”然后由作业调度程序按一定的算法，从后备队列中选择若干个作业调入内存，使它们共享CPU和系统中的各种资源，让它们<strong>交替在CPU上运行</strong><ul>
<li><strong>多道性、调度性、无序性</strong></li>
<li>优点：<strong>资源利用率高、系统吞吐量大</strong></li>
<li>缺点：<strong>平均周转时间长（作业要排队依次进行处理），无交互能力（用户不能与自己的程序交互直至作业完成）</strong></li>
<li>要解决的问题：处理机争用问题、内存分配和保护问题、I/O设备分配问题、文件的组织和管理问题、作业管理问题、用户与系统的接口问题…（后续都会进一步讨论）</li>
</ul>
</li>
<li><strong>分时系统</strong><ul>
<li>需求：人机交互、共享主机（支持多设备同时I/O，多用户共享计算机资源）</li>
<li>关键问题：及时接收、及时处理</li>
<li>特征：<strong>多路性（允许多台终端同时连接到一台主机上，并按分时原则为每个用户服务）、独立性（每个用户彼此之间互不干扰）、及时性（用户请求短时间内获得响应）、交互性（用户可通过终端与系统进行广泛的人机对话）</strong></li>
</ul>
</li>
<li><strong>实时系统</strong><ul>
<li>任务类型：周期性实时任务和非周期性实时任务、硬实时任务和软实时任务</li>
<li>实时系统与分时系统特征的比较<br>区别|实时系统|分时系统</li>
</ul>
</li>
</ul>
<p>–:|:–:|:–<br>多路性|系统周期性地对多路现场信息进行采集、对多个对象进行控制|系统按分时原则为多个终端用户服务<br>独立性|信息采集和对对象控制互不干扰，多用户与系统交互互不干扰|多用户与系统交互互不干扰<br>及时性|以控制对象所要求的的截止时间来决定对实时性的要求|对实时性的要求（延迟）是依据人能所接受的等待时间决定的<br>交互性|交互性仅限于访问系统中某些特定的专用服务程序|能向终端用户提供数据处理、资源共享等服务，实现广泛的人机对话<br>可靠性|要求系统高度可靠，采用多级容错措施| 要求系统可靠</p>
<ul>
<li><strong>多道批处理系统、分时系统、实时系统是三种基本操作系统</strong></li>
<li>微机操作系统的发展（略）</li>
</ul>
<h1 id="1-3-操作系统的基本特性（考点）"><a href="#1-3-操作系统的基本特性（考点）" class="headerlink" title="1.3 操作系统的基本特性（考点）"></a>1.3 操作系统的基本特性（考点）</h1><ul>
<li><strong>操作系统的四个基本特征</strong>：<strong>并发、共享、虚拟、异步</strong></li>
</ul>
<h2 id="1-3-1-并发"><a href="#1-3-1-并发" class="headerlink" title="1.3.1 并发"></a>1.3.1 并发</h2><h3 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h3><ul>
<li><strong>并行</strong>：在同一<strong>时刻</strong>发生多个事件</li>
<li><strong>并发</strong>：在同一<strong>时间间隔</strong>内发生多个事件</li>
<li><strong>并行有并发，并发无并行</strong></li>
</ul>
<h3 id="进程的引入"><a href="#进程的引入" class="headerlink" title="进程的引入"></a>进程的引入</h3><ul>
<li>进程：<strong>在系统中能独立运行并作为资源分配的基本单位</strong>，由<strong>机器指令、数据和堆栈等组成</strong>，是一个<strong>能独立运行的活动实体</strong>，多个进程之间可以并发执行和交换信息，是<strong>操作系统运行的基础</strong></li>
<li>进程将程序的<strong>执行分段化</strong>，使得多个程序可以并发执行，大大提高资源系统的利用率，增加系统的吞吐量</li>
</ul>
<h2 id="1-3-2-共享"><a href="#1-3-2-共享" class="headerlink" title="1.3.2 共享"></a>1.3.2 共享</h2><ul>
<li><strong>共享</strong>：系统中的资源可供内存中多并发作业共同使用</li>
<li>互斥共享方式：<strong>一个进程访问资源时其他进程需要等待</strong>，我们将这种一段时间内只允许一个进程访问的资源称为 <em>临界资源</em>，系统中给的绝大多数物理设备以及栈、变量和表格都属于临界资源，只能被互斥地共享。</li>
<li>同时访问方式：这里的“同时”在单处理机环境下是宏观意义上的，而在微观上，这些进程<strong>对资源的访问是交替进行的</strong>。</li>
<li><strong>并发和共享是多用户OS的两个最基本特征</strong></li>
</ul>
<h2 id="1-3-3-虚拟-无中生有"><a href="#1-3-3-虚拟-无中生有" class="headerlink" title="1.3.3 虚拟 无中生有"></a>1.3.3 虚拟 <em>无中生有</em></h2><ul>
<li>时分复用技术（时间）：<strong>多个用户交替使用处理机/物理IO设备</strong><ul>
<li>虚拟处理机技术：为每道程序建立至少一个进程，让多个程序并发执行，虽然微观上系统只有一台处理机，但通过分时复用方法在宏观将处理机虚拟为多台逻辑上的处理机</li>
<li>虚拟设备技术：将一台物理I/O设备在宏观上虚拟为多台逻辑上的I/O设备，在微观上让不同应用的进程交替使用I/O设备</li>
<li>虚拟设备处理速度≤V/n，n为虚拟设备/并发应用个数，V为处理机处理速度</li>
</ul>
</li>
<li>空分复用技术（空间）：<strong>每次只向内存中导入程序中被需要的部分，实现程序在比它小的内存中运行，并实现多个程序对内存的同时使用。</strong>，空分复用体现在将内存分为多个小部分供多个应用同时使用，时分复用体现在每个应用每次只导入当前需要的部分，用完就置换，让应用的每个部分分时进入内存。<ul>
<li>虚拟设备占用空间≤S/N，n为虚拟设备/并发应用个数，S为内存大小</li>
</ul>
</li>
</ul>
<h2 id="1-3-4-异步"><a href="#1-3-4-异步" class="headerlink" title="1.3.4 异步"></a>1.3.4 异步</h2><ul>
<li><strong>异步</strong>：<strong>每个程序不知何时执行何时结束。</strong></li>
<li>由于资源等因素的限制，进程在发出资源请求时通常不能及时得到满足，因此进程的执行通常不是一气呵成而是以停停走走的方式运行，导致了程序的执行时间是不可知的。</li>
</ul>
<h1 id="1-4-操作系统的主要功能"><a href="#1-4-操作系统的主要功能" class="headerlink" title="1.4 操作系统的主要功能"></a>1.4 操作系统的主要功能</h1><h2 id="1-4-1-处理机管理功能（考点）"><a href="#1-4-1-处理机管理功能（考点）" class="headerlink" title="1.4.1 处理机管理功能（考点）"></a>1.4.1 处理机管理功能（考点）</h2><ul>
<li><strong>进程控制</strong></li>
<li><strong>进程同步</strong></li>
<li><strong>进程通信</strong></li>
<li><strong>处理机调度</strong><h2 id="1-4-2-存储器管理功能（考点）"><a href="#1-4-2-存储器管理功能（考点）" class="headerlink" title="1.4.2 存储器管理功能（考点）"></a>1.4.2 存储器管理功能（考点）</h2></li>
<li><strong>内存分配</strong>：<ul>
<li>为每道程序分配内存空间</li>
<li>提高存储器的利用率</li>
<li>允许正在运行的程序申请附加的内存空间</li>
<li>分配方式：<ul>
<li>静态分配方式：每个作业的内存空间是在作业装入时确定的</li>
<li>动态分配方式：每个作业的内存空间在作业装入是基本确定，反允许作业在运行过程中继续申请添加新的附加内存空间</li>
</ul>
</li>
</ul>
</li>
<li><strong>内存保护</strong>：<ul>
<li>确保每道用户程序都互不干扰，仅在各自内存中运行</li>
<li>绝不允许用户程序访问操作系统的程序和数据，也不允许用户程序转到非共享的其它用户程序中去执行</li>
</ul>
</li>
<li><strong>地址映射</strong>：使各程序段的逻辑地址转换为内存空间中与之相对应的物理地址</li>
<li><strong>内存扩充</strong>：借助虚拟存储技术从逻辑上扩充内存容量（比如1.3.3提到的空分复用技术）<h2 id="1-4-3-设备管理功能（知道有就行）"><a href="#1-4-3-设备管理功能（知道有就行）" class="headerlink" title="1.4.3 设备管理功能（知道有就行）"></a>1.4.3 设备管理功能（知道有就行）</h2></li>
<li>缓冲管理</li>
<li>设备分配</li>
<li>设备处理<h2 id="1-4-4-文件管理功能（知道有就行）"><a href="#1-4-4-文件管理功能（知道有就行）" class="headerlink" title="1.4.4 文件管理功能（知道有就行）"></a>1.4.4 文件管理功能（知道有就行）</h2></li>
<li>文件存储空间的管理</li>
<li>目录管理</li>
<li>文件的读写管理与保护<h2 id="1-4-5-操作系统与用户之间的接口（知道有就行）"><a href="#1-4-5-操作系统与用户之间的接口（知道有就行）" class="headerlink" title="1.4.5 操作系统与用户之间的接口（知道有就行）"></a>1.4.5 操作系统与用户之间的接口（知道有就行）</h2></li>
<li>用户接口：让用户直接或间接地控制自己的作业</li>
<li>程序接口：让程序方便地使用系统调用<h2 id="1-4-6-现代操作系统的新功能：系统安全、网络功能和服务、支持多媒体"><a href="#1-4-6-现代操作系统的新功能：系统安全、网络功能和服务、支持多媒体" class="headerlink" title="1.4.6 现代操作系统的新功能：系统安全、网络功能和服务、支持多媒体"></a>1.4.6 现代操作系统的新功能：系统安全、网络功能和服务、支持多媒体</h2><h1 id="1-5-OS结构设计"><a href="#1-5-OS结构设计" class="headerlink" title="1.5 OS结构设计"></a>1.5 OS结构设计</h1><h2 id="1-5-1-传统操作系统结构"><a href="#1-5-1-传统操作系统结构" class="headerlink" title="1.5.1 传统操作系统结构"></a>1.5.1 传统操作系统结构</h2></li>
<li>古早的无结构操作系统：单人设计，规模小，缺乏首尾一致的设计思想，复杂又混乱</li>
<li>模块化结构OS：有较为清晰的结构，由若干个具有一定独立性和大小的模块构成，每个模块分工不同，模块内又划分为若干个小模块，规定好各子模块之间的接口和模块间的接口<ul>
<li>优点：提高了OS设计的准确性、可理解性和可维护性、增强了OS的可适应性、加速了OS的开发过程</li>
<li>缺点：设计时对各模块间的接口规定很难满足在模块设计完成后对接口的实际需求，设计者的决策必须基于上一个决策，造成可靠性的难以保障</li>
</ul>
</li>
<li>分层式结构OS：目标系统An和裸机系统（物理硬件）A0之间铺设若干个层次的软件，使An通过这些层次的软件最终在A0上运行，在OS中通常采用自底向上法来铺设这些中间层<ul>
<li>优点：由于自底向上保证了决策的顺序性，从而易于保证系统的正确性；在系统中增加、修改、替换一个层次中的模块或整个层次只要不改变相应层次间的接口就不会影响其他层次，这使系统维护和扩充更加容易</li>
<li>缺点：OS每执行一个功能，通常要自上而下地穿越多个层次，增加了系统的通信开销，导致系统效率的降低<h2 id="1-5-2-客户服务器模式-（详情请见计网笔记第一章）"><a href="#1-5-2-客户服务器模式-（详情请见计网笔记第一章）" class="headerlink" title="1.5.2 客户服务器模式 （详情请见计网笔记第一章）"></a>1.5.2 客户服务器模式 <em>（详情请见计网笔记第一章）</em></h2></li>
</ul>
</li>
<li>客户服务器系统的三个部分：客户机、服务器、网络系统</li>
<li>过程：客户机发送请求——服务器接收消息——服务器回送消息——客户机接收消息</li>
<li>优点：数据分布处理和存储提升了可靠性、缓解了处理能力瓶颈；便于集中管理；具有灵活性和可扩充性；支持且易于改编应用软件</li>
<li>缺点：若系统只有一个服务器，则一旦服务器故障，将导致整个网络瘫痪，也存在处理瓶颈，可通过增加网络中服务器数量来缓解该问题<h2 id="1-5-3-面向对象程序设计技术"><a href="#1-5-3-面向对象程序设计技术" class="headerlink" title="1.5.3 面向对象程序设计技术"></a>1.5.3 面向对象程序设计技术</h2></li>
<li>啊这……就是抽象，将数据类型、数据结构、数据文件等进行抽象，方便调用，具体不细说了x</li>
<li>优点：通过重用提高产品质量和生产率、使系统具有更好的易修改性和易扩展性、更易于保证系统的正确性和可靠性<h2 id="1-5-4-微内核OS结构"><a href="#1-5-4-微内核OS结构" class="headerlink" title="1.5.4 微内核OS结构"></a>1.5.4 微内核OS结构</h2><h3 id="什么是微内核"><a href="#什么是微内核" class="headerlink" title="什么是微内核"></a>什么是微内核</h3></li>
<li>内核：能实现现代OS最基本核心功能的小型内核，微内核并非是一个完整的OS，只是具有OS最基本的部分，通常包含：与硬件处理紧密相关的部分、一些较为基本的功能、客户和服务器之间的通信<h3 id="微内核的基本功能"><a href="#微内核的基本功能" class="headerlink" title="微内核的基本功能"></a>微内核的基本功能</h3></li>
<li>进程管理</li>
<li>低级存储器管理</li>
<li>中断和陷入处理<h3 id="微内核操作系统的优点"><a href="#微内核操作系统的优点" class="headerlink" title="微内核操作系统的优点"></a>微内核操作系统的优点</h3></li>
<li>提高了系统的可扩展性</li>
<li>增强了系统的可靠性</li>
<li>可移植性强</li>
<li>提供了对分布式系统的支持</li>
<li>融入了面向对象技术，提高系统正确性、可靠性、易修改性、易扩展性，同时减少开发系统的开销</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记_操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记2</title>
    <url>/2022/04/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="依照学校教学安排，第二章为进程的描述与控制"><a href="#依照学校教学安排，第二章为进程的描述与控制" class="headerlink" title="依照学校教学安排，第二章为进程的描述与控制"></a>依照学校教学安排，第二章为进程的描述与控制</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用虚拟机平台VMware-Workstation"><a href="#使用虚拟机平台VMware-Workstation" class="headerlink" title="使用虚拟机平台VMware Workstation"></a>使用虚拟机平台VMware Workstation</h1><hr>
<h1 id="2-1-前趋图和程序执行（考点）"><a href="#2-1-前趋图和程序执行（考点）" class="headerlink" title="2.1 前趋图和程序执行（考点）"></a>2.1 前趋图和程序执行（考点）</h1><h2 id="2-1-1-前趋图（要求会画并发执行和顺序执行的）"><a href="#2-1-1-前趋图（要求会画并发执行和顺序执行的）" class="headerlink" title="2.1.1 前趋图（要求会画并发执行和顺序执行的）"></a>2.1.1 前趋图（要求会画并发执行和顺序执行的）</h2><ul>
<li>前趋图是一个有向无循环图，用于描述进程之间执行的先后顺序，图中的每个结点可以用来表示一个进程或程序段乃至一条语句，结点间的有向边表示两个结点之间的偏序关系或前驱关系。</li>
<li>直接前趋和直接后继：设前趋图中某有向边为Pi-&gt;Pj，则称Pi为Pj的直接前趋，Pj为Pi的直接后继</li>
<li>初始结点：没有直接前趋的结点</li>
<li>终止结点：没有直接后继的结点</li>
<li>为什么前趋图不能存在循环路径：若图中Pi和Pj间存在循环路径，则会导致Pi开始执行前要求Pj先执行完毕，Pj开始执行前要求Pi先执行完毕，这是相互矛盾的<h2 id="2-1-2-程序顺序执行（考点）"><a href="#2-1-2-程序顺序执行（考点）" class="headerlink" title="2.1.2 程序顺序执行（考点）"></a>2.1.2 程序顺序执行（考点）</h2><h3 id="程序的顺序执行"><a href="#程序的顺序执行" class="headerlink" title="程序的顺序执行"></a>程序的顺序执行</h3></li>
<li><strong>输入操作I要在计算操作C之前执行，打印操作P要在输入操作I和计算操作C后执行</strong></li>
<li>即使是一个程序段，也可能存在着执行顺序问题，下面给出了一个包含了三条语句的程序段：<br>S1:a=x+y<br>S2:b=a-1<br>S3:c=b+2<br>其中，语句S2必须在语句S1后（因为需要先得到a的值），语句S3必须在语句S2后（因为要先得到b的值），因此三条语句存在的前趋关系为S1-&gt;S2-&gt;S3<h3 id="程序顺序执行时的特征"><a href="#程序顺序执行时的特征" class="headerlink" title="程序顺序执行时的特征"></a>程序顺序执行时的特征</h3>由上述可知，在程序顺序执行时具有这样三个特征：</li>
<li><strong>顺序性</strong>：处理机严格地按照程序规定的顺序执行</li>
<li><strong>封闭性</strong>：程序在封闭的环境下运行，程序运行时独占全机资源，资源的状态（除初始状态外）只有程序能改变它，程序一旦开始执行，其执行结果不受外界影响</li>
<li><strong>可再现性</strong>：只要程序执行时的环境和初始条件相同，当程序重复执行时，不论它是从头到尾不停顿地执行还是“停停走走式”执行，都可获得相同的结果<h2 id="2-1-3-程序并发执行（考点）"><a href="#2-1-3-程序并发执行（考点）" class="headerlink" title="2.1.3 程序并发执行（考点）"></a>2.1.3 程序并发执行（考点）</h2></li>
<li>程序顺序执行虽然便利了程序员，但系统资源的利用率却很低，为此引入多道程序技术使程序或程序段间能并发执行。然而，<strong>并非所有程序都能并发执行，只有没有直接前趋关系的程序之间才能并发执行</strong><h2 id="程序并发执行时的特征"><a href="#程序并发执行时的特征" class="headerlink" title="程序并发执行时的特征"></a>程序并发执行时的特征</h2></li>
<li>程序并发执行功能虽然提高了系统的吞吐量和资源利用率，但由于<strong>它们共享系统资源</strong>，以及它们为完成同一项任务而相互合作，导致这些并发执行的程序间必将<strong>形成相互制约的关系</strong></li>
<li><strong>程序并发执行的新特征</strong>：<ul>
<li><strong>间断性</strong>：由于并发执行的程序共享资源导致它们之间存在制约关系，因此只有当使其暂停执行的因素消失后程序才可执行，由此可见，相互制约导致并发程序具有<strong>执行-暂停-执行</strong>的间断活动规律</li>
<li><strong>失去封闭性</strong>：由于并发执行的程序共享资源，导致<strong>任何一个程序运行时都不能独占全机资源，即它们的运行环境能够被其它程序影响</strong>，故失去了封闭性</li>
<li><strong>不可再现性</strong>：由于程序并发执行时失去了封闭性，也将导致其失去可再现性，因为程序的结果不再只受初始环境和条件影响，也在运行过程中受到影响</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-2-进程的描述（考点）"><a href="#2-2-进程的描述（考点）" class="headerlink" title="2.2 进程的描述（考点）"></a>2.2 进程的描述（考点）</h1><h2 id="2-2-1-进程的定义和描述-搭配1-3-1食用"><a href="#2-2-1-进程的定义和描述-搭配1-3-1食用" class="headerlink" title="2.2.1 进程的定义和描述(搭配1.3.1食用)"></a>2.2.1 进程的定义和描述(搭配1.3.1食用)</h2><h3 id="进程的定义"><a href="#进程的定义" class="headerlink" title="进程的定义"></a>进程的定义</h3><ul>
<li><strong>需求</strong>：由于在并发执行的程序失去了顺序性、封闭性、可再现性，尤其是后两者，所以导致通常的程序运行结果不能保障，也就失去了意义。<strong>为了让程序能够并发执行，并且可以对并发执行的程序加以描述和控制</strong>，人们引入了进程的概念</li>
<li><strong>进程控制块PCB</strong>：为了让并发执行的每个程序能够独立运行，操作系统中必须为之配置一个专门的数据结构：进程控制块，这样<strong>由程序段、相关数据、程序控制块</strong>三部分组成了进程实体，即进程，<strong>所谓创建进程，实质是创建进程中的PCB，相对应的，撤销进程实质上就是撤销进程中的PCB</strong></li>
<li><strong>进程的定义</strong> <del>梅开二度</del>：在系统中能独立运行并作为资源分配的基本单位，由进程控制块、相关数据和程序段组成，是一个能独立运行的活动实体，是操作系统运行的基础。<h3 id="进程的特征"><a href="#进程的特征" class="headerlink" title="进程的特征"></a>进程的特征</h3></li>
<li><strong>动态性</strong>：由创建而产生，由调度而执行，由撤销而消亡</li>
<li><strong>并发性</strong>：多个进程同存于内存中，且能在一段时间内并发执行</li>
<li><strong>独立性</strong>：进程实体是一个能独立运行、独立获得资源、独立接收调度的基本单位</li>
<li><strong>异步性</strong>：进程是按异步方式运行的，即“执行-暂停-执行”<h2 id="2-2-2-进程的基本状态及转换"><a href="#2-2-2-进程的基本状态及转换" class="headerlink" title="2.2.2 进程的基本状态及转换"></a>2.2.2 进程的基本状态及转换</h2><h3 id="进程的三种基本状态"><a href="#进程的三种基本状态" class="headerlink" title="进程的三种基本状态"></a>进程的三种基本状态</h3></li>
<li><strong>就绪</strong>：进程已经分配到除CPU外的所有必要资源</li>
<li><strong>执行</strong>：进程已获得CPU并正在执行，单处理机系统中只有一个进程处于执行状态，多处理机系统中有多个进程处于执行状态</li>
<li><strong>阻塞</strong>：正在执行的某进程因为发生某事件（如I/O请求、申请缓冲区失败等）暂时无法继续执行的状态，此时引起进程调度，将阻塞进程放入阻塞队列中等待，一般出于提高系统效率的需要，根据阻塞原因的不同，会设置多个阻塞队列<h3 id="三种基本状态的切换"><a href="#三种基本状态的切换" class="headerlink" title="三种基本状态的切换"></a>三种基本状态的切换</h3>见图<br><img src="../photos/OSCourse/2_1.png" title="就绪-执行-阻塞三态转换示意图"></li>
<li>补充-时间片：操作系统分配给每个进程在CPU上的一段执行时间<h3 id="创建状态与中止状态"><a href="#创建状态与中止状态" class="headerlink" title="创建状态与中止状态"></a>创建状态与中止状态</h3></li>
<li>需求：为了满足PCB对数据及操作的完整性要求以及增强管理的灵活性，通常在系统中又为进程引入了两种常见的状态：创建状态和终止状态。</li>
<li>创建状态：进程由创建而产生，创建一个进程的过程要通过多个步骤：进程申请一个空白PCB，向PCB中填写用于控制和管理进程的信息，为该进程分配除CPU外必须的资源，将进程转入就绪状态并插入就绪队列中。将进程申请PCB开始到加入就绪队列前的这个状态称为创建状态。</li>
<li>终止状态：进程的终止也要通过两个步骤：等待操作系统进行善后处理，再将PCB清理并返还系统。进程到达自然结束点，若出现无法克服的错误，或被操作系统终结，或被其它有终止权的进程所终结，它将进入终结状态，进入终结状态的进程不能再被执行，但在操作系统中保留记录供其它进程收集，一旦其它进程完成收集，操作系统将删除该进程并清零PCB、返还给系统。<br><img src="../photos/OSCourse/2_2.png" title="进程的五种基本状态及其转换示意图"><h2 id="2-2-3-挂起操作和进程状态的转换"><a href="#2-2-3-挂起操作和进程状态的转换" class="headerlink" title="2.2.3 挂起操作和进程状态的转换"></a>2.2.3 挂起操作和进程状态的转换</h2></li>
<li>在许多系统中，进程除了就绪、执行、阻塞三个基本状态外,为了系统和用户观察和分析进程的需要，还引入了一个对进程的重要操作：挂起。<strong>当挂起操作作用域某个进程时，该进程将被挂起，意味着此时该进程处于静止状态，如果该进程正在执行，它将暂停执行，若该进程处于就绪状态，则该进程此时暂不接受调度</strong>，与挂起操作对应的操作是<strong>激活</strong>操作。<h3 id="挂起操作的引入"><a href="#挂起操作的引入" class="headerlink" title="挂起操作的引入"></a>挂起操作的引入</h3></li>
<li>终端用户的需要：发现可疑问题需要暂停程序运行</li>
<li>父进程请求：用于协调各子进程</li>
<li>负荷调节的需要</li>
<li>操作系统的需要：检查运行中的资源使用状况<h3 id="引入挂起原语操作后三个进程基本状态的转换（需要会画图）"><a href="#引入挂起原语操作后三个进程基本状态的转换（需要会画图）" class="headerlink" title="引入挂起原语操作后三个进程基本状态的转换（需要会画图）"></a>引入挂起原语操作后三个进程基本状态的转换（需要会画图）</h3></li>
<li>补充-原语：指由若干条指令组成的程序段，用来实现某个特定功能，<strong>在执行过程中不可被中断</strong>。</li>
<li>挂起原语Suspend：用于活动-&gt;静止的转换</li>
<li>激活原语Active：用于静止-&gt;活动的转换</li>
<li>活动就绪Readys：处于活动就绪状态的进程可以被调度执行</li>
<li>静止就绪Readya：处于静止就绪状态的进程不再被调度执行</li>
<li>活动阻塞Blockeda：处于活动阻塞状态的进程完成I/O后变为活动就绪状态等待调度使用</li>
<li>静止阻塞Blockeds：处于静止阻塞状态的进程完成I/O后变为静止就绪状态等待激活成为活动就绪<h3 id="引入挂起操作后五个进程状态的转换（需要会画图）"><a href="#引入挂起操作后五个进程状态的转换（需要会画图）" class="headerlink" title="引入挂起操作后五个进程状态的转换（需要会画图）"></a>引入挂起操作后五个进程状态的转换（需要会画图）</h3></li>
<li>创建-&gt;活动就绪：若当前系统性能和内存容量均允许，完成创建的必要操作 <em>（申请PCB、填写PCB、分配除CPU外资源）</em>后，相应的系统进程将进程的状态转换为活动就绪状态</li>
<li>创建-&gt;静止就绪：若当前系统性能和内存容量不允许加入新的进程，则不分配给新建进程所需资源，将进程转为静止就绪状态，被安置在外层，此时进程创建工作尚未完成（也就是处于创建状态）</li>
<li>执行-&gt;终止：当一个进程已完成任务时，或是出现了无法克服的错误，或是被OS或是被其他进程所终结，此时将进程的状态转换为终止状态<h2 id="2-2-4-进程管理中的数据结构"><a href="#2-2-4-进程管理中的数据结构" class="headerlink" title="2.2.4 进程管理中的数据结构"></a>2.2.4 进程管理中的数据结构</h2><h3 id="操作系统中用于管理控制的数据结构（考点）"><a href="#操作系统中用于管理控制的数据结构（考点）" class="headerlink" title="操作系统中用于管理控制的数据结构（考点）"></a>操作系统中用于管理控制的数据结构（考点）</h3></li>
<li>OS管理需要的数据结构的分类：<strong>内存表、设备表、文件表和用于进程管理的进程表</strong>，通常<strong>进程表又被称为进程控制块PCB</strong></li>
<li>OS中的数据结构包含了资源或进程的标识、描述、状态等信息以及一批指针。<h3 id="PCB的作用（考点）"><a href="#PCB的作用（考点）" class="headerlink" title="PCB的作用（考点）"></a>PCB的作用（考点）</h3></li>
<li>PCB的作用：使一个在多道程序环境下不能独立运行的程序称为一个能独立运行的基本单位，一个能与其他进程并发执行的进程。</li>
<li>PCB的作用：<ul>
<li><strong>作为独立运行基本单位的标志</strong></li>
<li>能实现间断性运行方式</li>
<li>提供进程管理所需要的信息</li>
<li>提供进程调度所需要的信息</li>
<li>实现与其它进程的同步与通信</li>
</ul>
</li>
</ul>
<h3 id="PCB中的信息（考点）"><a href="#PCB中的信息（考点）" class="headerlink" title="PCB中的信息（考点）"></a>PCB中的信息（考点）</h3><ul>
<li>进程标识符：用于唯一地标识一个进程<ul>
<li>内部标识符：为每一个进程赋予一个唯一的<strong>数字标识符</strong>，方便系统使用</li>
<li>外部标识符：由创建者提供，通常<strong>由字母、数字组成</strong>，往往由用户进程访问该进程时使用</li>
</ul>
</li>
<li>处理机状态：也称为处理机的上下文，由处理机各寄存器中的内容组成：通用寄存器、指令计数器、程序状态字PSW、用户栈指针</li>
<li>进程调度信息：进程状态、进程优先级、进程调度所需的其他信息、阻塞原因</li>
<li>进程控制信息：程序和数据的地址、进程同步和通信机制、资源清单、链接指针<h3 id="进程控制块的组织方式"><a href="#进程控制块的组织方式" class="headerlink" title="进程控制块的组织方式"></a>进程控制块的组织方式</h3></li>
<li>线性方式：将系统中的所有PCB组织在一张线性表中，将该表首地址存放在一个专用区域内。</li>
<li>链接方式：将具有同一状态的PCB用其中的链接字链接成一个队列，排成执行队列、就绪队列、阻塞队列或空白队列等，用相对应的队列指针指向这些队列的第一个PCB。<br><img src="../photos/OSCourse/2_3.png" title="PCB链接方式示意图"></li>
<li>索引方式：系统根据所有进程状态的不同，建立几张索引表如就绪索引表、阻塞索引表等，并把各索引表在内存的首地址记录在内存的一些专用单元中。（用表取代队列）。</li>
</ul>
<hr>
<h1 id="2-3-进程控制"><a href="#2-3-进程控制" class="headerlink" title="2.3 进程控制"></a>2.3 进程控制</h1><p><strong>进程控制、进程同步、进程通信、处理机调度是操作系统处理机管理功能的四个主要组成</strong>，进程的控制包含<strong>进程创建、进程终止、进程阻塞和唤醒</strong>，由OS内核中的<strong>原语</strong>来实现</p>
<h2 id="2-3-1-操作系统内核"><a href="#2-3-1-操作系统内核" class="headerlink" title="2.3.1 操作系统内核"></a>2.3.1 操作系统内核</h2><p><strong>OS内核</strong>：在具有分层结构的OS中由常驻内存且与硬件紧密相关的各类驱动程序和运行频率较高的模块所组成的部分。<br>使用内核的目的：便于对这些软件进行保护、提高OS的运行效率<br>系统态和用户态：为了保护OS本身及关键数据，通常将处理机的执行状态分为系统态和用户态。</p>
<ul>
<li>系统态/管态/内核态：具有较高特权的执行状态，能执行一切指令，访问所有寄存器和存储区</li>
<li>用户态/目态：具有较低特权的执行状态，仅能执行规定的指令，访问指定的寄存器和存储区。一般情况下，应用程序只能在用户态运行，不能去执行OS指令及访问OS区域。</li>
</ul>
<h3 id="OS内核包含的两大功能（考点）"><a href="#OS内核包含的两大功能（考点）" class="headerlink" title="OS内核包含的两大功能（考点）"></a>OS内核包含的两大功能（考点）</h3><ul>
<li>支撑功能：中断处理、时钟管理、原语操作<ul>
<li>中断处理:是整个操作系统赖以活动的基础，内核在对中断进行有限处理后，便转入相关的进程，由这些进程继续完成后续的处理工作。</li>
<li>时钟管理:对进程的执行提供时间控制</li>
<li>原语操作:原语是一个不可分割的基本单位，由若干条指令构成，在执行过程中不允许被中断。原语在系统态下执行，常驻内存。</li>
</ul>
</li>
<li>资源管理功能：进程管理、存储器管理、设备管理<ul>
<li>进程管理：为了提高进程管理的效率和满足多种功能的需要，这些操作相关的原语被放在内核中。</li>
<li>存储器管理：存储器管理软件的运行模块（逻辑地址与物理地址映射、地址转换，内存保护，内存分配和回收等）因为使用频率较高，故也放在内核中。</li>
<li>设备管理：由于设备管理与硬件紧密相关，因此设备管理的相关模块（缓和CPU与I/O速率不匹配矛盾的缓冲管理，各类设备的驱动程序，设备分配等）也放在内核中。</li>
</ul>
</li>
</ul>
<h2 id="2-3-2-进程的创建"><a href="#2-3-2-进程的创建" class="headerlink" title="2.3.2 进程的创建"></a>2.3.2 进程的创建</h2><h3 id="进程的层次结构"><a href="#进程的层次结构" class="headerlink" title="进程的层次结构"></a>进程的层次结构</h3><ul>
<li>子进程和父进程：在OS中，允许一个进程创建另一个进程，我们称创建进程的进程为<strong>父进程</strong>，被创建的进程为<strong>子进程</strong>，子进程能够继承父进程的所有资源 <em>（父进程打开的文件、父进程所分配到的缓冲区等）</em>，相对应的，撤销子进程时，应当将继承的资源返还给父进程，父进程被撤销时其生成的子进程也必须同时撤销。</li>
<li>补充：在WINDOWS中不存在进程层次概念，所有的进程地位相同，而取代上下级控制关系的是<strong>句柄</strong>，拥有句柄的进程就拥有了控制其它进程的权限，句柄也可以进行传递。因此在WINDOWS中，进程之间不是层级关系，而是控制与被控制关系。<h3 id="进程图"><a href="#进程图" class="headerlink" title="进程图"></a>进程图</h3></li>
<li>用于描述进程的家族关系，是一棵有向树，树的根结点称为进程家族的<strong>祖先</strong><h3 id="引起创建进程的事件（考点）"><a href="#引起创建进程的事件（考点）" class="headerlink" title="引起创建进程的事件（考点）"></a>引起创建进程的事件（考点）</h3></li>
<li><strong>用户登录</strong>（为用户创建进程）</li>
<li><strong>作业调度</strong>（为用户创建进程）：在多道批处理系统中，当作业调度程序按一定的算法调度到某个作业时，将它们装入内存，并为它们创建进程、插入就绪队列中</li>
<li><strong>提供服务</strong>（为用户创建进程）：当运行中的用户程序提出某种请求后，系统将专门创建一个进程来提供用户程序需要的服务</li>
<li><strong>应用请求</strong>（用户自己创建进程）：用户进程自己创建新进程以使新进程和创建者进程并发运行完成某些特定任务，从而提高运行效率<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3></li>
<li>Step1：申请空白PCB</li>
<li>Step2：为新进程分配资源</li>
<li>Step3：PCB初始化（填写控制进程所需要的信息如：标识符、状态信息、优先级等）</li>
<li>Step4：如果进程就绪队列能够接纳新进程，便将新进程插入就绪队列<h2 id="2-3-3-进程的终止"><a href="#2-3-3-进程的终止" class="headerlink" title="2.3.3 进程的终止"></a>2.3.3 进程的终止</h2><h3 id="引起进程终止的事件"><a href="#引起进程终止的事件" class="headerlink" title="引起进程终止的事件"></a>引起进程终止的事件</h3></li>
<li>正常结束：进程任务已经完成，准备退出运行。在任何系统中都应该有一个用于表示进程已经运行完成的指示。在批处理系统中对应的指令是Halt，在分时系统中对应的指令是Logs off，当程序运行到这个指令时，产生一个中断告诉OS进程已运行完毕</li>
<li>异常结束：进程在运行时发生了某种异常事件，使程序无法继续运行，常见的异常事件有：<ul>
<li>越界错：程序访问的存储区超出规定区域</li>
<li>保护错：进程试图访问一个不被允许访问的文件</li>
<li>非法指令：指令不存在</li>
<li>特权指令错：进程视图执行一条只允许OS执行的指令</li>
<li>运行超时：进程执行时间超过规定的最大值</li>
<li>等待超时：进程等待某事件的时间超过规定最大值</li>
<li>算术运算错：进程试图执行一个被禁止的运算</li>
<li>I/O故障：I/O过程发生了错误</li>
</ul>
</li>
<li>外界干预：进程应外界请求终止运行，这些干预有：<ul>
<li>操作员或操作系统干预</li>
<li>父进程请求</li>
<li>父进程终止</li>
</ul>
</li>
</ul>
<h3 id="进程的终止进程"><a href="#进程的终止进程" class="headerlink" title="进程的终止进程"></a>进程的终止进程</h3><ul>
<li>Step1：根据被终止进程的标识符从PCB集合中检索对应PCB，读取该进程的状态</li>
<li>Step2-1：若被终止进程处于执行状态，立刻终止该进程执行，并置调度标志为真，用于指示该进程被终止后应重新进行调度</li>
<li>Step2-2：若该进程有子孙进程，应一并终止其所有子孙进程</li>
<li>Step3：将被终止进程及其子孙进程的所有资源或者还给其父进程，或者还给系统</li>
<li>Step4：将被终止进程的PCB从所在队列/链表中一出，等待其它程序来搜索信息<h2 id="2-3-4-进程的阻塞与唤醒"><a href="#2-3-4-进程的阻塞与唤醒" class="headerlink" title="2.3.4 进程的阻塞与唤醒"></a>2.3.4 进程的阻塞与唤醒</h2><h3 id="引起进程阻塞和唤醒的事件"><a href="#引起进程阻塞和唤醒的事件" class="headerlink" title="引起进程阻塞和唤醒的事件"></a>引起进程阻塞和唤醒的事件</h3></li>
<li>向系统请求共享资源失败：资源被其它进程占用-阻塞，释放-唤醒</li>
<li>等待某种操作的完成：操作没完成-阻塞等待，完成-唤醒</li>
<li>新数据尚未到达：未到达-因没有数据而阻塞等待，完成-唤醒</li>
<li>新进程尚未到达：没有需要处理的新进程-进程自我阻塞，有新进程要处理-唤醒<h3 id="进程阻塞过程"><a href="#进程阻塞过程" class="headerlink" title="进程阻塞过程"></a>进程阻塞过程</h3></li>
<li>Step1：调用阻塞原语Block将自己阻塞</li>
<li>Step2：若仍在执行则停止执行，并将PCB中的执行状态改为阻塞</li>
<li>Step3：PCB被插入阻塞队列</li>
<li>Step4：转给调动程序重新调度，将处理机分配给另一就绪进程<h3 id="进程唤醒过程"><a href="#进程唤醒过程" class="headerlink" title="进程唤醒过程"></a>进程唤醒过程</h3></li>
<li>Step1：由有关进程调用唤醒原语Wakeup唤醒进程</li>
<li>Step2：将进程从阻塞队列中调出</li>
<li>Step3：将该进程的PCB由阻塞状态改为就绪</li>
<li>Step4：将该进程插入就绪队列中</li>
</ul>
<h2 id="2-3-5-进程的挂起与激活"><a href="#2-3-5-进程的挂起与激活" class="headerlink" title="2.3.5 进程的挂起与激活"></a>2.3.5 进程的挂起与激活</h2><h3 id="进程的挂起"><a href="#进程的挂起" class="headerlink" title="进程的挂起"></a>进程的挂起</h3><ul>
<li>Step1：由OS调用挂起原语suspend挂起进程</li>
<li>Step2：检查被挂起进程的状态，若活动就绪则改为静止就绪，若活动阻塞则改为静止阻塞</li>
<li>Step3：将该进程PCB复制到某指定内存区域</li>
<li>Step4：若被挂起进程正在执行，则转向调度程序重新调度<h3 id="进程的激活"><a href="#进程的激活" class="headerlink" title="进程的激活"></a>进程的激活</h3></li>
<li>Step1：由OS调用激活原语active激活进程</li>
<li>Step2：被激活进程从外存调入内存</li>
<li>Step3：检查该进程状态，若静止就绪则改为活动就绪，若静止阻塞则改为活动阻塞</li>
<li>Step4：若为静止就绪，改为活动就绪后，将其优先级和队列中其他进程优先级进行比较，若优先级低则不必重新调度，否则直接剥夺当前进程的运行，将处理机分配给刚被激活的进程</li>
</ul>
<hr>
<h1 id="2-4-进程同步"><a href="#2-4-进程同步" class="headerlink" title="2.4 进程同步"></a>2.4 进程同步</h1><h2 id="2-4-1-进程同步的基本概念"><a href="#2-4-1-进程同步的基本概念" class="headerlink" title="2.4.1 进程同步的基本概念"></a>2.4.1 进程同步的基本概念</h2><p>进程同步机制的主要任务是对并发执行的多个相关进程在执行次序上进行协调</p>
<h3 id="两种形式的制约关系"><a href="#两种形式的制约关系" class="headerlink" title="两种形式的制约关系"></a>两种形式的制约关系</h3><p>在多道程序环境下对于同处于一个系统中的多个进程，它们之间可能存在两种形式的制约关系</p>
<ul>
<li>间接相互制约关系：多个进程在并发执行时由于共享CPU、I/O设备等一次只能允许一个进程访问的资源，导致这些并发执行的程序之间形成了间接相互制约关系。对于这类临界资源，必须保证多个进程对之间只能互斥地访问，这类资源由系统实施统一分配，即用户在使用之前应先提出申请。</li>
<li>直接相互制约关系：对于合作完成某一任务的多个进程而言，它们之间会因进程的异步性、并发性和执行顺序导致的无法从缓冲中及时取出数据而产生阻塞，即进程之间的直接制约关系。为了杜绝这种因为不正确的访问顺序而产生的“与时间有关的错误”，系统必须对进程的执行次序进行协调。<br><img src="../photos/OSCourse/2_4.png" title="生产者、消费者对缓冲区中数据的读写"><h3 id="临界资源（考点，会写伪代码）"><a href="#临界资源（考点，会写伪代码）" class="headerlink" title="临界资源（考点，会写伪代码）"></a>临界资源（考点，会写伪代码）</h3></li>
</ul>
<p><strong>临界资源</strong>：进程采用互斥访问方式共享的资源，如各类I/O设备、处理机等。<br><strong>生产者-消费者问题</strong><br>问题描述：有一群生产者在生产产品（数据），同时有一群消费者在消费产品（数据），为了能使生产者（进程）和消费者（进程）并发执行，在两者之间设置了一个具有n个缓冲区的缓冲池，生产者进程将产生的数据放入缓冲区中，消费者进程可从缓冲区取出数据，虽然这两类进程的执行是异步的，但是它们对缓冲区的数据存取必须同步，即<strong>不能让消费者进程从空的缓冲区取数据，也不能让生产者进程将数据存入满的缓冲区</strong><br>生产者-消费者问题的伪代码表示如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int in=0, out =0,count =0;//输入、输出指针初始化，counter表示当前缓冲区中的数据量</span><br><span class="line">item buffer[n];//buffer为缓冲池</span><br><span class="line">void producer()&#123;//生产者进程</span><br><span class="line">   while(1)&#123;</span><br><span class="line">      produce an item in nextp;//将生产的数据存入nextp，nextp和nextc均为局部变量</span><br><span class="line">      ...</span><br><span class="line">      while (counter == n);//counter表示当前缓冲池内数据量，counter==n表示当前缓冲池内数据满，不能将nextp中暂存的数据放入池中，故等待。</span><br><span class="line">         ...</span><br><span class="line">         buffer[in] = nextp;//将nextp中的数据存入当前输入指针指向的缓冲区</span><br><span class="line">         in = (in+1)%n;//in向前移动</span><br><span class="line">         counter++;//数据量++</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void consumer()&#123;//消费者进程</span><br><span class="line">   while(1)&#123;</span><br><span class="line">      while(counter==0);//counter==0表示当前缓冲池空，无数据可取</span><br><span class="line">         ...</span><br><span class="line">         nextc = buffer[out];//将当前输出指针指向缓冲区内容存入nextc</span><br><span class="line">         out = (out+1)%n;//输出指针指向下一个</span><br><span class="line">         counter--;//数据量--</span><br><span class="line">         consumer the item in nextc;//消费nextc中暂存的数据</span><br><span class="line">         ...</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个进程交替执行不会有任何问题，但如果这两个进程的语句是交替进行的会导致counter偏离理论值，因此，<strong>生产者进程和消费者进程要互斥地访问临界资源缓冲池和变量counter</strong></p>
<h3 id="临界区（考点）"><a href="#临界区（考点）" class="headerlink" title="临界区（考点）"></a>临界区（考点）</h3><p>由上述可知无论是硬件临界资源还是软件临界资源，多个并发执行的进程必须互斥地进行访问，我们将这些<strong>进程中访问临界资源的代码段称为临界区</strong>。若要保证进程对临界资源的互斥访问，要让每个进程在进入临界区之前，检查欲访问的临界资源是否在被其他进程访问。由此可知，在进程的临界区前要加上一段<strong>对临界资源进行预检查的代码段，即进入区</strong>，相应地，在临界区后也要加上一段<strong>退出临界资源访问的代码，即退出区</strong>，<strong>进程中除进入区、临界区、退出区外的剩余部分被称为剩余区</strong>，故一个访问临界资源的循环进程描述如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">while(1)&#123;</span><br><span class="line">   剩余区;</span><br><span class="line">   进入区;</span><br><span class="line">   临界区;</span><br><span class="line">   退出区;</span><br><span class="line">   剩余区;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="同步机制应遵循的规则（考点）"><a href="#同步机制应遵循的规则（考点）" class="headerlink" title="同步机制应遵循的规则（考点）"></a>同步机制应遵循的规则（考点）</h3><ul>
<li><strong>空闲让进</strong>：临界资源空闲（无进程进入临界区）时应允许一个请求进入临界区的进程立即进入临界区。</li>
<li><strong>忙则等待</strong>：当已有进程进入临界区时，表明临界资源正在被访问，因而其它试图进入临界区的进程必须等待。</li>
<li><strong>有限等待</strong>：进程等待进入临界区的时间应该有上限。</li>
<li><strong>让权等待</strong>：当进程不能进入自己的临界区时，应立即释放分配给这个进程的处理机<h2 id="2-4-2-硬件同步机制"><a href="#2-4-2-硬件同步机制" class="headerlink" title="2.4.2 硬件同步机制"></a>2.4.2 硬件同步机制</h2>由于使用软件指令解决临界区问题有一定难度且有局限性，因此目前许多计算机提供了硬件指令解决临界区问题。<ul>
<li>临界区管理提供一个作为锁的标识，“锁开”进入，“锁关”等待</li>
<li>初始状态下锁为打开状态，每个进入临界区的进程必须对锁进行测试</li>
<li>为了不让所同时进行多个测试，故测试和关锁操作必须连续（原语操作），<em>先关锁后开锁</em></li>
</ul>
</li>
</ul>
<h3 id="关中断"><a href="#关中断" class="headerlink" title="关中断"></a>关中断</h3><p>进入锁测试前关闭中断，完成锁测试并关锁后打开中断，进程在临界区时计算机系统不响应中断，不会引发调度，缺点：</p>
<ul>
<li>滥用关中断可能导致严重后果</li>
<li>关中断时间过长会影响系统效率</li>
<li>不适用于多CPU系统</li>
</ul>
<h3 id="利用Test-and-Set-（测试并建立）指令实现互斥"><a href="#利用Test-and-Set-（测试并建立）指令实现互斥" class="headerlink" title="利用Test-and-Set （测试并建立）指令实现互斥"></a>利用Test-and-Set <em>（测试并建立）</em>指令实现互斥</h3><p><strong>在进程内实现互斥访问</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">boolean TS(boolean *lock)&#123;//获取lock参数，*lock==TRUE时，表示锁关；*lock==FALSE时，表示锁开</span><br><span class="line">   boolean old;</span><br><span class="line">   old = *lock;//将lock存储的地址指向的空间内内容赋给old</span><br><span class="line">   *lock = TRUE;</span><br><span class="line">   return old;</span><br><span class="line">&#125;</span><br><span class="line">do&#123;//进程代码</span><br><span class="line">   ...</span><br><span class="line">   while (TS(&amp;lock));//这个代码逻辑妙啊，如果lock第一次传入时是true，即锁关，那么传出来的old也是true，进程将阻塞在while语句，而lock仍保持true（锁关）</span><br><span class="line">   //而如果lock第一次传入时是false，即锁开，那么传出来的old是false，进程跳出while循环继续执行，而false将改为true，表示当前进程进入临界区并关锁，关锁和传参（测试）是在一块的，因此不可分开，也就实现了逻辑上的连续</span><br><span class="line">   critical section;//临界区</span><br><span class="line">   *lock:=FALSE;//:=为赋值语句</span><br><span class="line">   remainder section;//退出区、剩余区</span><br><span class="line">&#125;while(TRUE);</span><br></pre></td></tr></table></figure>
<h3 id="利用Swap指令实现进程互斥"><a href="#利用Swap指令实现进程互斥" class="headerlink" title="利用Swap指令实现进程互斥"></a>利用Swap指令实现进程互斥</h3><p><strong>在资源中实现互斥访问</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void Swap(boolean *a,boolean *b)&#123;</span><br><span class="line">   boolean temp;</span><br><span class="line">   temp = *a;</span><br><span class="line">   *a = *b;</span><br><span class="line">   *b = temp;</span><br><span class="line">&#125;</span><br><span class="line">do&#123;</span><br><span class="line">   key = TRUE;//给资源的初始状态是“可访问”</span><br><span class="line">   do&#123;</span><br><span class="line">      swap(&amp;lock,&amp;key);</span><br><span class="line">   &#125;while(key!=FALSE);//先进行do操作，若，lock为false，key为true，则第一次测试可以访问该资源，lock和key转换，表示该进程正在被访问，而key变为false后则不再进行转换操作，即其它进程的访问无效，直至lock变为true后再次重头访问该进程时（退出区）再度交换释放该资源。</span><br><span class="line">   lock = FALSE;</span><br><span class="line">   ...</span><br><span class="line">&#125;while(1);</span><br></pre></td></tr></table></figure>
<h2 id="2-4-3-信号量机制"><a href="#2-4-3-信号量机制" class="headerlink" title="2.4.3 信号量机制"></a>2.4.3 信号量机制</h2><p><strong>信号量</strong>是一种卓有成效的进程同步工具，它包含：</p>
<ul>
<li>整型信号量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wait(S)&#123;//P操作</span><br><span class="line">   while(S&lt;=0);//信号量少于0，即表示没有资源，则一直wait（阻塞）</span><br><span class="line">   S--;//能操作了，占用资源，S--</span><br><span class="line">&#125;</span><br><span class="line">signal(S)&#123;//V操作</span><br><span class="line">   S++;//释放了资源，S++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>记录型信号量<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">typedef struct&#123;</span><br><span class="line">   int value;//表示某类资源数目，若value值为1，则可实现进程互斥</span><br><span class="line">   struct process_control_block *list;//进程列表指针list</span><br><span class="line">&#125;semaphore;//记录型信号量定义</span><br><span class="line">wait(semaphore *S)&#123;//P操作</span><br><span class="line">   S-&gt;value --;//请求一个单位的该类资源</span><br><span class="line">   if (S-&gt;value&lt;0)//若该资源已经被分配完毕，进程调用block原语自我阻塞</span><br><span class="line">      block(S-&gt;list);</span><br><span class="line">&#125;</span><br><span class="line">signal(S)&#123;//V操作</span><br><span class="line">   S-&gt;value ++;//释放一个单位的该类资源</span><br><span class="line">   if(S-&gt;value&lt;=0)//若仍有等待该类资源的进程被阻塞</span><br><span class="line">      wakeup(S-&gt;list);//调用wakeup原语，唤醒链表中的第一个等待进程</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>AND型信号量<br>整型信号量和记录型信号量的问题<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//若进程A和进程B为两个共享数据D和E的进程，它们按下列次序交替进行wait操作，Dmutex和Emutex的初始值均为1以实现互斥访问</span><br><span class="line">processA: wait(Dmutex);//Dmutex = 0</span><br><span class="line">processB: wait(Emutex);//Emutex = 0</span><br><span class="line">processA: wait(Emutex);//Emutex = -1，A阻塞</span><br><span class="line">processB: wait(Dmutex);//Dmutex = -1，B阻塞，两个进程死锁。</span><br></pre></td></tr></table></figure>
AND同步机制的思想：<strong>将进程所需要的所有资源一次性分配</strong><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Signal（S1，S2，···，Sn）&#123;//释放所有资源</span><br><span class="line">   for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">      Si=Si+1;</span><br><span class="line">      Remove all the process waiting in the queue associated with Si into the ready queue.//有了资源，将所有需要Si的进程移入就绪队列</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">Swait（S1，S2，···，Sn）&#123;</span><br><span class="line">   while（true）&#123;</span><br><span class="line">      if（S1≥1andS2≥1and...andSn≥1）&#123;//若需要的所有类型资源都有</span><br><span class="line">         for(i=1;i&lt;=n;i++)//</span><br><span class="line">         Si=Si–1;//分别发出请求</span><br><span class="line">         break;</span><br><span class="line">      &#125;</span><br><span class="line">      else&#123;</span><br><span class="line">            place the process in the waiting queue associated with the first Si found with Si＜1,</span><br><span class="line">            and set the program count of this process to the beginning of Swait operation.//一旦发现第i类资源不满足要求，则将该进程调入与Si相关联的等待队伍，还要将此进程中PCB的程序计数器设置到Swait操作的开始处。</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>信号量集<br>在每次分配时，采用信号量集来控制，可以分配多个资源<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Swait（S1，t1，d1，...，Sn，tn，dn）&#123;//满足ti≥di，Si、ti、di分别对应资源信号量、资源下限值、需求量</span><br><span class="line">   if(S1≥t1&amp;...&amp;Sn≥tn)&#123;//如果所有资源都就绪了</span><br><span class="line">      for(i=1;i&lt;=n;i++)&#123;</span><br><span class="line">         Si＝Si－di;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   else&#123;</span><br><span class="line">      Place the executing process in the waiting queue of the first Si with Si＜ti and set its program counter to the beginning of the Swait operation。将该进程调入与Si相关联的等待队伍并将此进程中PCB的程序计数器设置到Swait操作的开始处。</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line">//Swait(S,d,d)：允许每次申请d个资源。当资源数少于d时，不予分配。</span><br><span class="line">//Swait(S,1,1)：S&gt;1，记录型信号量。S=1时，互斥型信号量。</span><br><span class="line">//Swait(S,1,0)，可控开关，当S&gt;=1时，允许进入，S&lt;1时，不能进入。</span><br></pre></td></tr></table></figure>
<h2 id="2-4-4-信号量的应用"><a href="#2-4-4-信号量的应用" class="headerlink" title="2.4.4 信号量的应用"></a>2.4.4 信号量的应用</h2><h3 id="利用信号量实现互斥访问"><a href="#利用信号量实现互斥访问" class="headerlink" title="利用信号量实现互斥访问"></a>利用信号量实现互斥访问</h3>为了使多个进程能互斥地访问某临界资源，只须为该资源设置一互斥信号量mutex，并设其初始值为1，然后将各进程访问该资源的临界区CS置于wait（mutex）和signal（mutex）操作之间即可。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore mutex=1;</span><br><span class="line">process1()&#123;// or process2</span><br><span class="line">   while(1)&#123;</span><br><span class="line">      wait(mutex);//为了实现进程对资源的互斥访问，wait和signal必须成对出现，缺少wait(mutex)会导致系统混乱，不能实现互斥访问。</span><br><span class="line">      critical section;//临界区</span><br><span class="line">      signal(mutex);//缺少signal(mutex)会使临界资源永远不被释放，从而使因等待该资源而阻塞的进程不能被唤醒。</span><br><span class="line">      remainder section;//剩余区</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用信号量实现前趋关系（可能考看伪代码画前趋图或看前趋图写伪代码，希望不会是后者）"><a href="#利用信号量实现前趋关系（可能考看伪代码画前趋图或看前趋图写伪代码，希望不会是后者）" class="headerlink" title="利用信号量实现前趋关系（可能考看伪代码画前趋图或看前趋图写伪代码，希望不会是后者）"></a>利用信号量实现前趋关系（可能考看伪代码画前趋图或看前趋图写伪代码，希望不会是后者）</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">p1()&#123;S1；signal（a）；signal（b）；&#125;//浅显易懂</span><br><span class="line">p2()&#123;wait(a);S2；signal（c）；signal（d）;&#125;</span><br><span class="line">p3()&#123;wait（b）；S3；signal（e）；&#125;</span><br><span class="line">p4()&#123;wait（c）；S4；signal（f）；&#125;</span><br><span class="line">p5()&#123;wait（d）；S5；signal（g）；&#125;</span><br><span class="line">p6()&#123;wait（e）；wait（f）；wait（g）；S6；&#125;</span><br><span class="line">voidmain()&#123;</span><br><span class="line">   semaphorea,b,c,d,e,f,g;</span><br><span class="line">   a.value=b.value=c.value=0;</span><br><span class="line">   d.value=e.value=f.value=g.value=0;</span><br><span class="line">   cobegin</span><br><span class="line">     p1();p2();p3();p4();p5();p6();</span><br><span class="line">   coend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h2 id="2-4-5-管程机制"><a href="#2-4-5-管程机制" class="headerlink" title="2.4.5 管程机制"></a>2.4.5 管程机制</h2><h3 id="管程的定义"><a href="#管程的定义" class="headerlink" title="管程的定义"></a>管程的定义</h3>当共享资源用共享数据结构semaphore表示时，资源管理程序可用对该数据结构进行操作的一组过程来表示（如资源的请求和释放），我们把这样一组相关的数据结构和过程一并称为<strong>管程</strong></li>
</ul>
<p><strong>管程</strong>：一个管程定义了一个数据结构和能被并发进程在该数据结构上所执行的一组操作，这组操作能够同步进程和改变管程中的数据。</p>
<h3 id="管程的组成"><a href="#管程的组成" class="headerlink" title="管程的组成"></a>管程的组成</h3><ul>
<li>管程的名字</li>
<li>管程局部的共享数据结构的说明</li>
<li>对该数据结构进行操作的一组过程</li>
<li>对管程局部的数据设置初始值的语句<h3 id="管程的主要特点"><a href="#管程的主要特点" class="headerlink" title="管程的主要特点"></a>管程的主要特点</h3></li>
<li>局部数据变量只能被管程的过程访问，任何外部过程都不能访问</li>
<li>一个进程通过调用管程的一个过程进入管程</li>
<li>在任何时候，只能有一个进程在管程中执行，调用管程的任何其他进程都被挂起，以等待管程变为可用的</li>
</ul>
<hr>
<h1 id="2-5-经典进程的同步问题"><a href="#2-5-经典进程的同步问题" class="headerlink" title="2.5 经典进程的同步问题"></a>2.5 经典进程的同步问题</h1><h2 id="2-5-1-生产者-消费者问题"><a href="#2-5-1-生产者-消费者问题" class="headerlink" title="2.5.1 生产者-消费者问题"></a>2.5.1 生产者-消费者问题</h2><h3 id="利用记录型信号量解决生产者-消费者问题"><a href="#利用记录型信号量解决生产者-消费者问题" class="headerlink" title="利用记录型信号量解决生产者-消费者问题"></a>利用记录型信号量解决生产者-消费者问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int in=0,out=0;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphore mutex = 1, empty = n, full = 0;//初始状态下所有缓冲区都是空的</span><br><span class="line">void producer();</span><br><span class="line">void consumer();</span><br><span class="line">void main()&#123;</span><br><span class="line">   //cobegin </span><br><span class="line">      producer();</span><br><span class="line">      consumer();</span><br><span class="line">   //coend</span><br><span class="line">&#125;</span><br><span class="line">void producer()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      ...</span><br><span class="line">      produce an item in nextp;</span><br><span class="line">      ...</span><br><span class="line">      wait(empty);</span><br><span class="line">      wait(mutex);</span><br><span class="line">      buffer(in):=nextp;</span><br><span class="line">      in:=(in+1) % n;</span><br><span class="line">      signal(mutex);</span><br><span class="line">      signal(full);</span><br><span class="line">      ...</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br><span class="line">void consumer()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      wait(full);</span><br><span class="line">      wait(mutex);</span><br><span class="line">      nextc:=buffer(out);</span><br><span class="line">      out:=(out+1) % n;</span><br><span class="line">      signal(mutex);</span><br><span class="line">      signal(empty);</span><br><span class="line">      consume an item in nextc;</span><br><span class="line">      ...</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">   ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用AND信号量解决生产者-消费者问题"><a href="#利用AND信号量解决生产者-消费者问题" class="headerlink" title="利用AND信号量解决生产者-消费者问题"></a>利用AND信号量解决生产者-消费者问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int in =0,out = 0;</span><br><span class="line">item buffer[n];</span><br><span class="line">semaphoremutex = 1, empty = n,full = 0;</span><br><span class="line">void producer()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      ...</span><br><span class="line">      produce an item in nextp;</span><br><span class="line">      ...</span><br><span class="line">      wait(empty,mutex);</span><br><span class="line">      buffer[in]=nextp;</span><br><span class="line">      in:=(in+1)%n;</span><br><span class="line">      signal(mutex,full);</span><br><span class="line">   &#125;while(True);</span><br><span class="line">&#125;</span><br><span class="line">void consumer&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      wait(full,mutex);</span><br><span class="line">      nextc = buffer[out];</span><br><span class="line">      out = (out+1)%n;</span><br><span class="line">      signal(mutex,empty);</span><br><span class="line">      consumer the item in nextc;</span><br><span class="line">   &#125;whiel(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="2-5-2-哲学家进餐问题"><a href="#2-5-2-哲学家进餐问题" class="headerlink" title="2.5.2 哲学家进餐问题"></a>2.5.2 哲学家进餐问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p>五个哲学家共用一张圆桌，每个人之间有一只筷子，哲学家要么思考，要么吃饭，吃饭时先左后右拿起两边的筷子，思考前放下筷子。若五个哲学家要同时吃饭，则它们同时拿起左边的筷子后，都等待右边的筷子被放下，从而引发死锁。<br>对于死锁，有以下几种解决方法：</p>
<ul>
<li>至多只允许有四位哲学家同时去拿左边的筷子，保证至少有一位哲学家能进餐</li>
<li>仅当哲学家的左右两只筷子均可用时才允许进餐</li>
<li>规定奇数号哲学家先左后右拿筷子，偶数号科学家先右后左拿筷子，这样总有哲学家能进餐<h3 id="利用AND信号量机制解决哲学家进餐问题"><a href="#利用AND信号量机制解决哲学家进餐问题" class="headerlink" title="利用AND信号量机制解决哲学家进餐问题"></a>利用AND信号量机制解决哲学家进餐问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore chopstick[5]=&#123;1,1,1,1,1&#125;;</span><br><span class="line">do&#123;</span><br><span class="line">   ...</span><br><span class="line">   //think</span><br><span class="line">   ...</span><br><span class="line">   wait(chopstick[(i+1)%5],chopstick[i]);</span><br><span class="line">   ...</span><br><span class="line">   ///eat</span><br><span class="line">   ...</span><br><span class="line">   signal(chopstick[(i+1)%5],chopstick[i]);</span><br><span class="line">&#125;while(true);</span><br></pre></td></tr></table></figure>
<h2 id="2-5-3-读者-写者问题"><a href="#2-5-3-读者-写者问题" class="headerlink" title="2.5.3 读者-写者问题"></a>2.5.3 读者-写者问题</h2><h3 id="问题描述-1"><a href="#问题描述-1" class="headerlink" title="问题描述"></a>问题描述</h3>存在读者和写者两类进程，我们将<strong>只读取文件</strong>的进程称为Reader进程，其它进程则称为Writer进程，<strong>读进程可共享同一对象，写进程不可共享同一对象</strong>，即我们允许多个Reader进程同时访问一个共享对象，但不允许Writer进程和其它任何类型进程同时访问数据对象，因为会引起混乱。因此Writer进程必须互斥地与其它进程访问共享对象。<h3 id="利用记录型信号量解决读者-写者问题"><a href="#利用记录型信号量解决读者-写者问题" class="headerlink" title="利用记录型信号量解决读者-写者问题"></a>利用记录型信号量解决读者-写者问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">semaphore rmutex=1,wmutex=1;//设置两个信号量：读信号量和写信号量，初始值均为1，故先写还是先读都可以</span><br><span class="line">int readcount=0;//readcount用于表示当前有多少个进程在执行读操作，是读进程释放写信号量的判断依据</span><br><span class="line">void reader()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      wait(rmutex);//先等待读信号量为1（表示可以开始执行读进程，注意是开始进程不是正式读），且读信号量并不由写进程控制</span><br><span class="line">      if(readcount==0)//如果当前没有其他读进程在读程序，也有第二层含义是没有其它读进程有可能是因为有写进程在执行，因此要进行进一步检查</span><br><span class="line">         wait(wmutex);//检查当前是否有写进程在写文件，如果有（即wmutex=0）则等待，没有（即wmutex=1）则wmutex--，不让新的写进程执行</span><br><span class="line">      readcount++;//计数器++,表示该读进程正式进入读文件环节，也让其它并发执行的读进程得知有读进程在执行故可以跳过上面的if语句</span><br><span class="line">      signal(rmutex);//释放读信号量供并发读进程使用</span><br><span class="line">      ...</span><br><span class="line">      perform read operation;//正式读取操作</span><br><span class="line">      ...</span><br><span class="line">      wait(rmutex);//要结束了，需要释放写信号量，故进入检查环节</span><br><span class="line">      readcount --;//表示该进程已经结束读文件环节</span><br><span class="line">      if(readcount==0)//检查当前还是否有其它进程在读文件，并保证释放写信号量的进程是最后一个在执行的读进程</span><br><span class="line">         signal(wmutex);//注意，要先释放写信号量以防止新的读进程挤入导致写进程无法执行，然后再释放读信号量</span><br><span class="line">      signal(rmutex);</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">void writer()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      wait(wmutex);//要么初始情况下先于读进程写，要么等读进程释放再写</span><br><span class="line">      perform write operation;</span><br><span class="line">      signal(wmutex);</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">   //cobegin</span><br><span class="line">      writer();//这里私认为读进程还是写进程在前并不重要</span><br><span class="line">      reader();</span><br><span class="line">   //coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="利用信号量集机制解决读者-写者问题"><a href="#利用信号量集机制解决读者-写者问题" class="headerlink" title="利用信号量集机制解决读者-写者问题"></a>利用信号量集机制解决读者-写者问题</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int RN;//同时读进程最大数量</span><br><span class="line">semaphore L=RN,mx=1;//初始化，mx为互斥信号量</span><br><span class="line">void Reader()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      wait(L,1,1);//如果还能允许多一个读进程，就进入，否则等待</span><br><span class="line">      wait(mx,1,0);//满足ti≥di才能执行下一步，Si、ti、di分别对应资源信号量、资源下限值、需求量，这里是mx阻止读进程和写进程同时进行的步骤，若ti&lt;di即mx=0，则说明有写进程在执行，读进程需等待</span><br><span class="line">      ...</span><br><span class="line">      perform read operation;//正式读取操作</span><br><span class="line">      ...</span><br><span class="line">      signal(L,1);//将占用的一个读进程位（姑且这么叫）释放</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">void writer()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      wait(mx,1,1);//先抢占写进程位以实现互斥写入（写进程间）和互斥读写（读写进程间）</span><br><span class="line">      wait(L,RN,0);//满足ti≥di才能执行下一步，Si、ti、di分别对应资源信号量、资源下限值、需求量，这里是检查是否还有其他读进程在执行的步骤，若L&lt;RN，则说明有读进程在执行，写进程需等待</span><br><span class="line">      perform write operation;//正式写入操作</span><br><span class="line">      signal(mx,1);//写入完毕，立即释放占用的写进程位</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">void main()&#123;</span><br><span class="line">   cobegin</span><br><span class="line">      Reader();//顺序不重要</span><br><span class="line">      Writer();</span><br><span class="line">   coend</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="2-6-进程通信"><a href="#2-6-进程通信" class="headerlink" title="2.6 进程通信"></a>2.6 进程通信</h1><p>进程通信，即进程之间的信息交换，分为两类</p>
<ul>
<li>低级通信：以信号量机制为代表，它存在的缺点：<ul>
<li>效率低：生产者每次只能向缓冲池内投放一个产品/信息，消费者每次只能从缓冲池中取出一个产品</li>
<li>通信对用户不透明 <del>（我觉得就是根本没有）</del>：OS只为进程间的通信提供了共享存储器，而关于进程之间通信需要的数据结构、数据传送、进程互斥和同步机制都需要程序员实现，这对用户而言是不方便的</li>
</ul>
</li>
<li>高级通信：使用OS提供的高级通信工具，其特点是：<ul>
<li>便于使用：OS将进程通信封装为一组用于实现高级通信的原语，用户直接利用它实现进程之间的通信</li>
<li>高效地传送大量数据：用户可直接利用高级通信命令/原语高效地传送大量数据<h2 id="2-6-1-进程通信的类型"><a href="#2-6-1-进程通信的类型" class="headerlink" title="2.6.1 进程通信的类型"></a>2.6.1 进程通信的类型</h2><h3 id="共享存储器系统"><a href="#共享存储器系统" class="headerlink" title="共享存储器系统"></a>共享存储器系统</h3></li>
</ul>
</li>
<li>基于共享数据结构的通信方式，如生产者-消费者问题中的缓冲区</li>
<li>基于共享存储区的通信方式，在内存中划出一块共享存储区域，数据的形式、位置和访问控制都是进程而不是OS负责，进程向OS申请得到存储区域中的一个分区，读写完成或不再需要时归还给共享存储区<h3 id="管道通信系统"><a href="#管道通信系统" class="headerlink" title="管道通信系统"></a>管道通信系统</h3></li>
<li>指用于连接一个读进程和一个写进程以实现它们之间通信的一个共享文件，向管道提供输入的写进程以字符流形式将大量数据送入管道，读进程接收管道输出的数据</li>
<li>建立管道通信需要提供以下三方面的协调能力：<ul>
<li>互斥</li>
<li>同步</li>
<li>对方是否存在<h3 id="消息传递系统"><a href="#消息传递系统" class="headerlink" title="消息传递系统"></a>消息传递系统</h3></li>
</ul>
</li>
<li>目前主要的通信方式，信息单位：消息（报文）</li>
<li>实现方式：将通信数据封装在报文中，利用OS提供的一组通信命令/原语，在进程间进行消息传递</li>
<li>基于消息传递系统的通信方式属于高级通信方式，因其实现方式的不同，可分为两类：<ul>
<li>直接通信方式：发送进程利用OS提供的发送原语直接把消息发送给目标进程</li>
<li>间接通信方式：发送和接收进程都通过共享中间实体（邮箱）进行消息的发送和接收<h3 id="客户机-服务器系统（略）"><a href="#客户机-服务器系统（略）" class="headerlink" title="客户机-服务器系统（略）"></a>客户机-服务器系统（略）</h3><h2 id="2-6-2-消息传递通信的实现方式"><a href="#2-6-2-消息传递通信的实现方式" class="headerlink" title="2.6.2 消息传递通信的实现方式"></a>2.6.2 消息传递通信的实现方式</h2><h3 id="直接消息传递系统"><a href="#直接消息传递系统" class="headerlink" title="直接消息传递系统"></a>直接消息传递系统</h3>直接消息传递系统指发送进程利用OS所提供的发送命令，直接把消息发送给目标进程<h4 id="直接通信原语"><a href="#直接通信原语" class="headerlink" title="直接通信原语"></a>直接通信原语</h4></li>
</ul>
</li>
<li>对称寻址方式（<strong>1 to 1</strong>发送进程和接收进程都必须以显式方式提供对方的标识符）<ul>
<li>系统提供下述两条通信命令/原语：<ul>
<li>send(Receiver,message)</li>
<li>receive(Sender,message)</li>
<li>不足：一旦改变进程的名称，则可能需要找到有关该进程旧名称的所有引用以便修改，不利于进程定义的模块化</li>
</ul>
</li>
</ul>
</li>
<li>非对称寻址方式（<strong>1 to n</strong>在接收进程原语中，不需要命名发送进程，只填写表示源进程的参数，即完成通信后的返回值，而发送进程仍需要命名接收进程）<ul>
<li>系统中该方式的发送和接收原语表示为：<ul>
<li>send(P,message)</li>
<li>receive(id,message)//id也可以是进程名字</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void producer()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      ...</span><br><span class="line">      produce an item in nextp;</span><br><span class="line">      ...</span><br><span class="line">      send(receiver,nextp);</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">&#125;</span><br><span class="line">void consumer()&#123;</span><br><span class="line">   do&#123;</span><br><span class="line">      ...</span><br><span class="line">      receive(producer,nextc);</span><br><span class="line">      ...</span><br><span class="line">      consume the item in nextc;</span><br><span class="line">   &#125;while(TRUE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="间接通信-信箱通信"><a href="#间接通信-信箱通信" class="headerlink" title="间接通信/信箱通信"></a>间接通信/信箱通信</h3><p>进程之间需要通过共享数据结构的实体进行通信，该实体建立在随机存储器的公用缓冲区上，通常把这种中间实体称为信箱。系统为信箱通信提供了若干条原语，分别用于信箱的创建、撤销和消息的发送、接收等</p>
<h4 id="信箱的结构"><a href="#信箱的结构" class="headerlink" title="信箱的结构"></a>信箱的结构</h4><h4 id="信箱的创建和撤销"><a href="#信箱的创建和撤销" class="headerlink" title="信箱的创建和撤销"></a>信箱的创建和撤销</h4><ul>
<li>进程可利用信箱创建原语来建立一个新信箱，创建者进程需给出：<ul>
<li>信箱名称</li>
<li>信箱属性/类型（公用、私用或共享）<ul>
<li>私用邮箱：邮箱是创建邮箱进程的一部分，随进程消失</li>
<li>公用邮箱：邮箱供系统中的所有核准进程使用，所有核准进程均可对邮箱进行信息送取操作，通常公用邮箱在系统运行期间始终存在</li>
<li>共享邮箱：由某进程创建，在创建时或创建后指明它是可共享的，并给出共享进程/用户的名字，创建进程和其它共享进程权限相同，均可对邮箱进行信息送取操作</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="信箱的发送和接收"><a href="#信箱的发送和接收" class="headerlink" title="信箱的发送和接收"></a>信箱的发送和接收</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Send(mailbox,message)</span><br><span class="line">Receive(mailbox,message)//浅显易懂</span><br></pre></td></tr></table></figure>
<h2 id="2-6-3-直接消息传送系统实例"><a href="#2-6-3-直接消息传送系统实例" class="headerlink" title="2.6.3 直接消息传送系统实例"></a>2.6.3 直接消息传送系统实例</h2><h3 id="消息缓冲队列通信机制中的数据结构"><a href="#消息缓冲队列通信机制中的数据结构" class="headerlink" title="消息缓冲队列通信机制中的数据结构"></a>消息缓冲队列通信机制中的数据结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在消息缓冲队列通信方式中，主要利用的数据结构是消息缓冲区（一种数据缓冲区）</span><br><span class="line">typedef struct message_buffer&#123;</span><br><span class="line">   int sender;//发送者进程标识符</span><br><span class="line">   int size;//消息长度</span><br><span class="line">   char*text;//消息正文</span><br><span class="line">   message_buffer*next;//指向下一个发送区的指针</span><br><span class="line">&#125;</span><br><span class="line">//PCB中有关通信的数据项</span><br><span class="line">typedef struct processcontrol_block&#123;</span><br><span class="line">   ...</span><br><span class="line">   struct message_buffer * mq;//消息队列队首指针</span><br><span class="line">   semaphore mutex;//消息队列互斥信号量</span><br><span class="line">   semaphore sm;//消息队列资源信号量</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="发送原语"><a href="#发送原语" class="headerlink" title="发送原语"></a>发送原语</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void send(receiver,a)&#123;//a和下面的b都是message_buffer类型数据，但a是发送区，b是接收区</span><br><span class="line">   getbuf(a.size,i);//根据a的size申请缓冲区</span><br><span class="line">   i.sender = a.sender;//这行起的三行的意思是将发送区a中的信息复制到消息缓冲区之中</span><br><span class="line">   i.size=a.size;</span><br><span class="line">   copy(i.text,a.text);</span><br><span class="line">   i.next=0;//或者也可以说i.next=null</span><br><span class="line">   getid(PCBset,receiver.j);//获得接收进程内部标识符</span><br><span class="line">   wait(j.mutex);//等待接收进程内部标识符状态为“队列可插入”</span><br><span class="line">   insert(&amp;j.mq,i);//将消息缓冲区插入消息队列j</span><br><span class="line">   signal(j.mutex);//释放以供其他进程使用</span><br><span class="line">   signal(j.sm);//这块没看懂，应该是++，毕竟是资源信号量，但是书上却没写wait(j.sm)，求解惑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收原语"><a href="#接收原语" class="headerlink" title="接收原语"></a>接收原语</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void receive(b)&#123;</span><br><span class="line">   j = internal name;//j为接收进程内部的标识符</span><br><span class="line">   wait(j.sm);</span><br><span class="line">   wait(j.mutex);</span><br><span class="line">   remove(j.mq,i);//将消息队列中第一个消息移出</span><br><span class="line">   signal(j.mutex);</span><br><span class="line">   b.sender=i.sender;</span><br><span class="line">   b.size=i.size;</span><br><span class="line">   copy(b.text,i.text);//将消息缓冲区i中的信息复制到接收区b</span><br><span class="line">   releasebuf(i);//释放消息缓冲区</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-7-线程的基本概念"><a href="#2-7-线程的基本概念" class="headerlink" title="2.7 线程的基本概念"></a>2.7 线程的基本概念</h1><h2 id="2-7-1-线程的引入"><a href="#2-7-1-线程的引入" class="headerlink" title="2.7.1 线程的引入"></a>2.7.1 线程的引入</h2><p>线程：<strong>为了减少程序在并发执行时所付出的时空开销，使OS具有更好的并发性</strong></p>
<h3 id="进程的两个基本属性"><a href="#进程的两个基本属性" class="headerlink" title="进程的两个基本属性"></a>进程的两个基本属性</h3><ul>
<li>进程 <del>三羊开泰</del>：在系统中能独立运行并作为资源分配的基本单位，由进程控制块、相关数据和程序段组成，是一个能独立运行的活动实体，是操作系统运行的基础。</li>
<li>进程是一个可独立调度和分派的基本单位<h3 id="程序并发执行所需付出的时空开销"><a href="#程序并发执行所需付出的时空开销" class="headerlink" title="程序并发执行所需付出的时空开销"></a>程序并发执行所需付出的时空开销</h3></li>
<li>创建进程：需要分配资源</li>
<li>撤销进程：需要回收资源</li>
<li>进程切换：内存访问域变化，占用处理机时间</li>
<li>以上这些限制了系统中所设置进程的数目，且进程切换也不宜过于频繁，从而限制了并发程度的进一步提高<h2 id="2-7-2-线程和进程相比-我还是觉得我们线程牛批"><a href="#2-7-2-线程和进程相比-我还是觉得我们线程牛批" class="headerlink" title="2.7.2 线程和进程相比 我还是觉得我们线程牛批"></a>2.7.2 线程和进程相比 <del>我还是觉得我们线程牛批</del></h2>线程 <em>threads</em>：<strong>线程是一个被调度和分派的基本单位并可独立运行的实体。</strong>大多数与执行相关的信息可以保存在线程级的数据结构中，线程是对进程的进一步细分。</li>
<li>线程具有以下性质：<ul>
<li><strong>线程可以并发执行</strong></li>
<li><strong>线程是系统资源分配和调度的基本单位</strong></li>
<li><strong>同一进程内的线程共享进程资源，它们驻留在同一块地址空间中，并且可以访问到相同的数据</strong></li>
<li><strong>线程具有独立性</strong></li>
<li><strong>线程的切换代价、创建和删除开销要远小于进程</strong></li>
<li><strong>线程支持多处理机系统</strong><br><img src="../photos/OSCourse/2_5.png" title="进程和线程的结构示意图"></li>
</ul>
</li>
</ul>
<h2 id="2-7-3-线程的状态和线程控制块TCB"><a href="#2-7-3-线程的状态和线程控制块TCB" class="headerlink" title="2.7.3 线程的状态和线程控制块TCB"></a>2.7.3 线程的状态和线程控制块TCB</h2><h3 id="线程运行的三个状态"><a href="#线程运行的三个状态" class="headerlink" title="线程运行的三个状态"></a>线程运行的三个状态</h3><ul>
<li>执行状态：表示线程已经获得处理机且正在运行</li>
<li>就绪状态：表示线程已具备了各种执行条件，只需再获得CPU（处理机）便可立即执行</li>
<li>阻塞状态：表示线程在执行中因某事件受阻而处于暂停状态<h3 id="线程控制块TCB"><a href="#线程控制块TCB" class="headerlink" title="线程控制块TCB"></a>线程控制块TCB</h3></li>
<li>如同每个进程有一个进程控制块一样，系统也为每个线程配置了一个线程控制块，将所有用于控制和管理线程的信息记录在线程控制块中。</li>
<li>线程控制块的内容通常由以下几项构成：<ul>
<li>线程标识符</li>
<li>一组寄存器：包含程序计数器、状态寄存器和通用寄存器</li>
<li>线程运行状态</li>
<li>优先级</li>
<li>线程专有存储区：存放现场保护信息和线程运行相关统计信息</li>
<li>信号屏蔽</li>
<li>堆栈指针：用于线程调用，保存局部变量和返回地址</li>
</ul>
</li>
<li>备注：线程运行状态不是线程的上下文，线程/进程的上下文是在改变线程/进程的状态时的参考</li>
</ul>
<h3 id="多线程OS中的进程属性"><a href="#多线程OS中的进程属性" class="headerlink" title="多线程OS中的进程属性"></a>多线程OS中的进程属性</h3><ul>
<li>OS支持在一个进程中的多个线程能并发执行，但此时的进程就不再作为一个执行的实体。多线程OS中的进程有以下属性：<ul>
<li>进程是一个可拥有资源的基本单位（以前是可独立调度和分派的基本单位）</li>
<li>一个进程内的多个线程可并发执行 </li>
<li>进程已不是可执行的实体。在多线程OS中，把线程作为独立运行/调度分派的基本单位，但进程仍具有执行相关的状态。如“执行状态”指的是进程中的某线程正在执行;被挂起的进程中的所有线程也被挂起;被激活的进程中的所有线程也被激活</li>
</ul>
</li>
</ul>
<h3 id="线程状态变化的四种基本操作"><a href="#线程状态变化的四种基本操作" class="headerlink" title="线程状态变化的四种基本操作"></a>线程状态变化的四种基本操作</h3><ul>
<li>派生：当产生一个新进程时，同时也为该进程派生了一个初始化线程，随后，可以在同一个进程中派生另一个线程，新线程被放置在就绪队列中</li>
<li>阻塞：当线程需要等待另一个事件时，它将阻塞，此时处理器转而执行另一个就绪线程</li>
<li>解除阻塞：当阻塞一个线程的事件发生时，该线程被转移到就绪队列中</li>
<li>结束：当一个线程完成时，其寄存器的信息和栈都被释放</li>
</ul>
<hr>
<h1 id="2-8-线程的实现"><a href="#2-8-线程的实现" class="headerlink" title="2.8 线程的实现"></a>2.8 线程的实现</h1><h2 id="2-8-1-线程的实现方式"><a href="#2-8-1-线程的实现方式" class="headerlink" title="2.8.1 线程的实现方式"></a>2.8.1 线程的实现方式</h2><p>在OS中的所有进程，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的。</p>
<h3 id="内核支持线程KST"><a href="#内核支持线程KST" class="headerlink" title="内核支持线程KST"></a>内核支持线程KST</h3><ul>
<li>无论是用户进程中的线程，还是系统进程中的线程，它们的创建、撤销和切换等，也是依靠内核实现的</li>
<li>在内核空间为每一个内核线程设置了一个线程控制块，内核是根据该控制块而感知某线程的存在的，并对其加以控制</li>
<li>内核支持线程的四个主要优点<ul>
<li>在多处理器系统中，内核能够同时调度同一进程中的多个线程并行执行</li>
<li>如果进程中的一个线程被阻塞了，内核可以调度该进程中的其它线程占有处理器运行，也可以运行其它进程中的线程</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程的切换比较快，切换开销小</li>
<li>内核本身也可以采用多线程技术，可以提高系统的执行速度和效率</li>
</ul>
</li>
<li>内核支持线程的主要缺点：对于用户的线程切换而言其<strong>模式切换</strong>的开销较大，需要从用户态转到和心态，这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的<h3 id="用户级线程ULT"><a href="#用户级线程ULT" class="headerlink" title="用户级线程ULT"></a>用户级线程ULT</h3></li>
<li>用户级线程是在用户空间中实现的，线程的<strong>创建、撤销、同步和通信</strong>等功能都无需内核支持，<strong>用户级线程是与内核无关的</strong></li>
<li>用户级线程的优点：<ul>
<li>线程控制块设置在用户空间，内核完全不知道用户级线程的存在，这样可以节省模式切换系统开销</li>
<li>各进程可以独立选择线程调度算法</li>
<li>用户级线程与操作系统平台无关，甚至可以在不支持线程机制的操作系统平台上实现</li>
</ul>
</li>
<li>用户级线程的缺点：<ul>
<li>当线程执行系统调用引起进程阻塞时，进程中所有的线程都会被阻塞，会削弱进程中的线程的并发性，而内核支持线程不存在这个问题</li>
<li>由于内核每次给一个进程分配一个CPU（处理机），用户级线程不能有效利用多处理机进行进程内的多线程并行操作，进程中仅有一个线程能够执行，在该线程释放处理机前，其它线程只能等待</li>
</ul>
</li>
</ul>
<h3 id="组合方式：同时支持内核线程和用户线程"><a href="#组合方式：同时支持内核线程和用户线程" class="headerlink" title="组合方式：同时支持内核线程和用户线程"></a>组合方式：同时支持内核线程和用户线程</h3><ul>
<li>三种模式：<ul>
<li>多对一（多个用户线程映射到一个内核控制线程）：纯用户线程模式</li>
<li>一对一：内核线程模式、轻量级进程模式</li>
<li>多对多（多个用户线程映射到<strong>同样数量或更少数量</strong>的内核线程上）：组合模式</li>
</ul>
</li>
</ul>
<h2 id="2-8-2-线程的实现"><a href="#2-8-2-线程的实现" class="headerlink" title="2.8.2 线程的实现"></a>2.8.2 线程的实现</h2><h3 id="内核支持线程的实现"><a href="#内核支持线程的实现" class="headerlink" title="内核支持线程的实现"></a>内核支持线程的实现</h3><p>在仅设置了内核支持线程的OS中，系统在创建一个新进程时便为它分配一个任务数据区PTDA，其中包括若干个TCB空间，在每一个TCB中可保存线程标识符、优先级、线程运行的CPU状态等信息，每当进程要创建一个线程时，便为新线程分配一个TCB并将有关信息填入TCB中、为之分配必要的资源。当PTDA中的所有TCB空间已用完，而进程又要创建新的进程时，只要其所创建的线程数目未超过系统的允许值，系统可为再为其分配新的TCB空间。在撤销一个线程时，要么由系统回收，要么由进程回收供进程内的其它线程使用</p>
<h3 id="用户级线程的实现"><a href="#用户级线程的实现" class="headerlink" title="用户级线程的实现"></a>用户级线程的实现</h3><h4 id="运行时系统"><a href="#运行时系统" class="headerlink" title="运行时系统"></a>运行时系统</h4><p>运行时系统，即用于管理和控制线程的函数（过程）的集合，其中包括用于创建和撤销线程的函数、线程同步和通信的函数以及实现线程调度的函数等。因为有这些函数，才能使用户级线程与内核无关。运行时系统中的所有函数都驻留在用户空间，作为用户级线程和内核之间的接口。<strong>用户层对用户级线程的全部支持</strong></p>
<h4 id="内核控制线程"><a href="#内核控制线程" class="headerlink" title="内核控制线程"></a>内核控制线程</h4><p>内核控制线程，也称为轻型进程LWP，每一个进程都可拥有多个LWP。每个LWP都有自己的数据结构（和2.7.3中给出的一样）他们也可以共享进程所拥有的资源。LWP可以通过系统调用来获得内核提供的服务，这样可使用户级线程运行时只用连接到一个LWP上便具有内核支持线程的所有属性。<strong>用户级线程进行系统调用的接口</strong></p>
<h2 id="2-8-3-线程的创建和终止（略）"><a href="#2-8-3-线程的创建和终止（略）" class="headerlink" title="2.8.3 线程的创建和终止（略）"></a>2.8.3 线程的创建和终止（略）</h2>]]></content>
      <categories>
        <category>课程笔记_操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>课程笔记</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理笔记1</title>
    <url>/2022/03/10/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="依照学校教学安排，第一章为数据库系统概论"><a href="#依照学校教学安排，第一章为数据库系统概论" class="headerlink" title="依照学校教学安排，第一章为数据库系统概论"></a>依照学校教学安排，第一章为数据库系统概论</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="1-1-数据库及其系统概念"><a href="#1-1-数据库及其系统概念" class="headerlink" title="1.1 数据库及其系统概念"></a>1.1 数据库及其系统概念</h1><h1 id="1-1-1-什么是数据库？"><a href="#1-1-1-什么是数据库？" class="headerlink" title="1.1.1 什么是数据库？"></a>1.1.1 什么是数据库？</h1><ul>
<li>在任何信息系统的技术实现中均需要一类<strong>用于组织和存储数据的数据容器</strong></li>
<li>支持应用程序对数据的共享操作访问</li>
<li>将信息系统的各类数据如<strong>文本数据、图表数据、音视频数据等</strong>进行组织存储并<strong>提供能对外访问</strong></li>
<li><strong>数据库的定义</strong>：一种依照特定<strong>数据模型</strong>组织、存储和管理数据的文件集合，这些文件一般存放在外部存储器中，以便长久保存数据，并可快速访问</li>
<li><strong>数据库文件组成</strong>：<strong>数据文件</strong>和<strong>日志文件</strong></li>
<li><strong>数据库的本质就是一类数据文件</strong></li>
<li>数据库与普通数据文件的主要区别<ul>
<li>数据库可以支持不同应用对数据共享访问，普通数据文件难以支持</li>
<li>数据库可以实现复杂的数据管理，普通数据文件难以实现</li>
<li>数据库可独立于应用程序，普通数据文件与应用程序紧耦合</li>
<li>数据库的操作访问与控制管理由数据库管理系统软件实现，普通数据文件的操作访问与控制管理都必须由应用程序实现</li>
</ul>
</li>
</ul>
<h1 id="1-1-2-什么是数据模型"><a href="#1-1-2-什么是数据模型" class="headerlink" title="1.1.2 什么是数据模型"></a>1.1.2 什么是数据模型</h1><ul>
<li>数据模型是指描述事物对象的<strong>数据结构组成</strong>、<strong>数据语义联系</strong>、<strong>数据约束的抽象结构及其说明</strong>，由数据结构、数据操作和数据约束组成<ul>
<li>数据结构：用于描述事物对象的静态特征，包括事物对象的数据组成、数据类型、数据性质等</li>
<li>数据操作：用于描述事物对象的动态特征，包括数据的插入、修改、删除和查询等访问操作</li>
<li>数据约束：用于描述数据结构中数据之间的语义联系，数据之间的制约和依存关系，以及数据动态变化的规则等</li>
</ul>
</li>
</ul>
<h1 id="1-1-3-数据库使用的数据模型"><a href="#1-1-3-数据库使用的数据模型" class="headerlink" title="1.1.3 数据库使用的数据模型"></a>1.1.3 数据库使用的数据模型</h1><ul>
<li><strong>层次数据模型</strong>：最早使用的一种数据模型<ul>
<li>采用树结构来组织、存储和管理数据，每个结点存储一个数据记录，数据结点之间通过链接指针相互联系，通过结点遍历访问方法实现查询数据</li>
<li>由于树结构受限于上下结点层次访问，缺乏灵活性，故后来使用网状数据模型</li>
</ul>
</li>
<li><strong>网状数据模型</strong><ul>
<li>采用网状图结构组织、存储和管理数据，在网状图中，中间结点不但可以上下层次访问，还可以横向关联访问</li>
<li>优点：可灵活地表示数据之间的复杂关系，数据冗余小</li>
<li>缺点：结构复杂，增加了数据查询、数据修改 <em>（需要更改数据结点和关联指针）</em>和数据定位的难度，因此使用关系数据模型</li>
</ul>
</li>
<li><strong>关系数据模型</strong><ul>
<li>采用二维表结构组织、存储和管理数据，并以关联列实现表之间的关系</li>
<li>优点：数据结构简单、操作灵活，支持关系与集合运算操作，支持广泛使用的SQL数据库操作语言标准，拥有众多产品与用户</li>
<li>缺点：只用于结构化数据的组织与存储管理，支持的数据类型较简单，难以支持互联网广泛应用的非结构化数据和复杂数据管理</li>
</ul>
</li>
<li><strong>其它数据模型</strong>：如对象数据模型、键值对数据模型、列式数据模型、文档数据模型、图形数据模型等</li>
</ul>
<h1 id="1-1-4-数据库系统"><a href="#1-1-4-数据库系统" class="headerlink" title="1.1.4 数据库系统"></a>1.1.4 数据库系统</h1><ul>
<li>定义：<strong>一类基于数据库进行数据管理与信息服务的软件系统</strong></li>
<li>组成：<strong>数据库用户、数据库应用程序、数据库管理系统、数据库</strong><ul>
<li>数据库用户：由应用程序员 <em>（开发）</em>、系统分析员 <em>（开发）</em>、数据库管理员 <em>（使用DBMS提供的工具维护数据库系统）</em>、最终用户构成</li>
<li>数据库应用程序：是一种在DBMS支持下对数据库中数据进行访问处理的应用程序，基本功能有：<ul>
<li>通过输入框采集用户输入数据</li>
<li>通过接口连接访问数据库</li>
<li>执行用户数据查询</li>
<li>通过表单列表输出结果数据</li>
<li>…</li>
</ul>
</li>
<li>数据库管理系统DBMS：一种专门用于**创建、管理 <em>（包括读写、修改、删除数据等）</em>、维护、提供外部访问数据库支持 <em>（执行数据访问规则）</em>、执行数据库备份和恢复**的系统软件</li>
<li>数据库：一种依照特定数据模型组织、存储和管理数据的文件集合</li>
</ul>
</li>
</ul>
<h1 id="1-1-5-关系数据库中的数据内容"><a href="#1-1-5-关系数据库中的数据内容" class="headerlink" title="1.1.5 关系数据库中的数据内容"></a>1.1.5 关系数据库中的数据内容</h1><ul>
<li>在关系数据库中，除了存储和管理应用的<strong>用户数据</strong> <em>（存放于用户表）</em>外，还需要存与管理数据库本身的<strong>元数据、索引数据、运行数据</strong> <em>（存放于系统表）</em>等系统数据</li>
</ul>
<h1 id="1-1-6-关系数据库的对象组织"><a href="#1-1-6-关系数据库的对象组织" class="headerlink" title="1.1.6 关系数据库的对象组织"></a>1.1.6 关系数据库的对象组织</h1><ul>
<li>用户表：存储用户的应用数据</li>
<li>系统表：存储数据库系统自身数据</li>
<li>视图：通过虚拟表实现数据查询处理</li>
<li>索引：通过目录数据结构支持快速数据查询</li>
<li>约束：对关系表及其数据施加规则</li>
<li>存储过程：在数据库内部实现特定功能程序的数据处理</li>
<li>触发器：在数据库内部实现数据操作事件触发自动执行的过程程序</li>
</ul>
<hr>
<h1 id="1-2-数据库技术发展"><a href="#1-2-数据库技术发展" class="headerlink" title="1.2 数据库技术发展"></a>1.2 数据库技术发展</h1><h2 id="1-2-1数据管理技术发展阶段"><a href="#1-2-1数据管理技术发展阶段" class="headerlink" title="1.2.1数据管理技术发展阶段"></a>1.2.1数据管理技术发展阶段</h2><ul>
<li>人工管理阶段<ul>
<li>应用需求：科学计算</li>
<li>硬件背景：简单的计算机，纸带打孔I/O</li>
<li>软件背景：没有操作系统</li>
<li>数据管理：人工在代码中控制处理</li>
<li>管理特点：<ul>
<li>程序员组织与管理数据</li>
<li>应用程序依赖数据集</li>
<li>应用之间无数据共享、数据冗余度大</li>
<li>数据集无结构</li>
</ul>
</li>
</ul>
</li>
<li>文件系统管理阶段<ul>
<li>应用需求：科学计算、信息管理</li>
<li>硬件背景：磁鼓、磁带、磁盘等外部存储设备的出现</li>
<li>软件背景：操作系统、文件系统等系统软件的出现</li>
<li>数据管理：文件方式组织和存储数据，应用程序可通过文件系统提供的文件存取方法接口访问数据文件</li>
<li>管理特点：<ul>
<li>由文件组织与存储数据</li>
<li>数据文件的数据记录具有简单的字段结构，但文件整体无结构</li>
<li>应用程序依赖于数据文件，需自己维护数据文件</li>
<li>数据独立性差，难以实现应用程序之间的数据共享访问</li>
</ul>
</li>
</ul>
</li>
<li>数据库系统管理阶段<ul>
<li>应用需求：大规模信息管理</li>
<li>硬件背景：大容量磁盘、磁盘阵列的出现，支持大容量数据管理</li>
<li>软件背景：数据库管理系统出现</li>
<li>数据管理：数据库管理系统组织、存储和访问数据</li>
<li>管理特点：<ul>
<li>数据集结构化，易于查询和统计处理</li>
<li>不同应用程序可以实现数据共享访问</li>
<li>数据独立性高，应用可扩展</li>
<li>数据由DBMS统一管理和操作访问<h2 id="1-2-2数据库技术发展经历时代"><a href="#1-2-2数据库技术发展经历时代" class="headerlink" title="1.2.2数据库技术发展经历时代"></a>1.2.2数据库技术发展经历时代</h2></li>
</ul>
</li>
</ul>
</li>
<li>第一代数据库技术：20世纪60年代末出现的层次模型数据库技术和网状模型数据库技术</li>
<li>第二代数据库技术：20世纪70年代出现的关系模型数据库技术</li>
<li>第三代数据库技术：20世纪90年代出现的面向对象数据库技术和对象-关系数据模型数据库技术</li>
<li>第四代数据库技术：本世纪初期出现的半结构化数据库技术，以及当今面向互联网应用的非结构化数据库技术、大规模分布式数据库技术<h2 id="1-2-3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术"><a href="#1-2-3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术" class="headerlink" title="1.2.3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术"></a>1.2.3数据库技术领域的三个维度：应用处理技术、工程技术、数据模型技术</h2><h2 id="1-2-4数据库技术发展趋势"><a href="#1-2-4数据库技术发展趋势" class="headerlink" title="1.2.4数据库技术发展趋势"></a>1.2.4数据库技术发展趋势</h2></li>
<li>数据库规模朝两级发展，大型数据库系统越来越大，小型数据库系统越来越小</li>
<li>从数据库行数据访问模式，到列数据访问模式</li>
<li>从结构化数据库，到半结构化XML数据库、非结构化数据库</li>
<li>从操作型数据库系统，到数据仓库、商业智能数据分析、大数据处理</li>
<li>从通用数据库，到实时数据库、多媒体数据库、空间数据库、分布式数据库、并行数据库等专业领域数据库</li>
</ul>
<hr>
<h1 id="1-3-数据库应用系统"><a href="#1-3-数据库应用系统" class="headerlink" title="1.3 数据库应用系统"></a>1.3 数据库应用系统</h1><h2 id="1-3-1数据库应用系统类型"><a href="#1-3-1数据库应用系统类型" class="headerlink" title="1.3.1数据库应用系统类型"></a>1.3.1数据库应用系统类型</h2><ul>
<li>业务处理系统TPS：运用数据库应用程序对机构业务活动信息进行记录、计算、检索、汇总、统计等数据处理，为机构操作层面提供基本业务服务，提高业务处理效率的信息系统。</li>
<li>管理信息系统MIS：一种以机构职能管理为主导，利用计算机软硬件、网络通信、数据库等IT技术，实现机构职能整体信息化管理，以达到规范化管理和提高机构工作效率，并支持机构职能服务的信息系统</li>
<li>决策支持系统DSS：以管理科学、运筹学、控制论和行为科学为基础，以计算机技术、数据库技术、人工智能技术为手段，针对特定领域问题解决，为管理者提供辅助决策服务与方案的信息系统 <h2 id="1-3-2数据库系统应用结构"><a href="#1-3-2数据库系统应用结构" class="headerlink" title="1.3.2数据库系统应用结构"></a>1.3.2数据库系统应用结构</h2></li>
<li>单机用户结构：整个数据库应用系统都装在一台计算机上，由一个用户进行访问操作，<strong>数据不能共享，数据冗余度大</strong></li>
<li>集中式结构：数据库系统的应用程序、DBMS、数据都部署在同一服务器上运行，多个用户使用自己的计算机终端网络连接服务器，并可实现共享访问数据库，<strong>结构简单，易于维护，但当终端用户增加到一定数量后，服务器及网络将成为数据存取访问的瓶颈，使系统的性能大大降低</strong></li>
<li>客户/服务器结构：数据库应用程序的数据集中在数据库服务器管理、应用分布客户机处理。客户端应用程序通过网络并发访问数据库服务器中的数据库，客户机程序与数据库服务器<strong>分工进行数据处理，提高系统负载分担能力，但仍会因大量客户端并发访问数据库服务器，导致系统性能瓶颈</strong></li>
<li>分布式结构：分布式结构下的各服务器结点数据库在逻辑上是一个整体，但物理分布在计算机网络的不同服务器结点上运行，每个数据库服务器可通过网络既支持多个本地客户机访问，也支持远程客户机访问。<strong>既实现数据分布，又实现处理分布，并执行全局应用</strong>，适合跨地区的大型机构及企业等组织对数据库应用的要求，<strong>处理性能强，但数据库的分布处理与维护有一定的开销和技术难度</strong><h2 id="1-3-3数据库应用系统生命周期"><a href="#1-3-3数据库应用系统生命周期" class="headerlink" title="1.3.3数据库应用系统生命周期"></a>1.3.3数据库应用系统生命周期</h2></li>
<li><strong>需求分析</strong>：系统分析人员与用户交流，利用软件工程方法获取系统数据需求信息，并采用需求模型定义系统数据组成及其数据字典</li>
<li><strong>系统设计</strong>：系统设计人员根据系统功能和性能需求，对系统数据库进行设计，包括系统概念数据模型、系统逻辑数据模型和系统物理数据模型设计</li>
<li><strong>系统实现</strong>：按照系统设计方案进行数据库创建与应用编程实现，主要包括DBMS安装部署、数据库创建、数据对象创建、应用编程实现等方面的工作</li>
<li><strong>系统测试</strong>：系统测试人员将测试数据上载到数据库中，对数据库对象进行测试操作访问，实现数据库功能和性能测试</li>
<li><strong>系统运行与维护</strong>：系统运维人员在信息系统投入运行过程中，对数据库系统进行定期维护和优化，以保证数据库系统正常地、高效地运行</li>
</ul>
<hr>
<h1 id="1-4-典型数据库管理系统"><a href="#1-4-典型数据库管理系统" class="headerlink" title="1.4 典型数据库管理系统"></a>1.4 典型数据库管理系统</h1><h2 id="1-4-1-数据库管理系统类型"><a href="#1-4-1-数据库管理系统类型" class="headerlink" title="1.4.1 数据库管理系统类型"></a>1.4.1 数据库管理系统类型</h2><ul>
<li>按用途分类<ul>
<li>通用DBMS：支持公共领域数据库应用，广泛应用在各个机构的业务信息系统、办公管理系统、商业信息系统中，如 SQL Server</li>
<li>专用领域DBMS：支持专用领域数据库应用，如嵌入式应用、实时计算、多媒体应用等领域，如SQLite</li>
</ul>
</li>
<li>按用户数分类<ul>
<li>单用户DBMS：仅支持单用户访问，如miniSQL</li>
<li>多用户DBMS：可支持多用户并行访问，如MySQL</li>
</ul>
</li>
<li>按系统部署分类<ul>
<li>集中式DBMS：数据库集中部署在单一物理机器中，针对中小型信息系统，如Access</li>
<li>分布式DBMS：数据库可分布在不同位置的物理机器中，针对跨区域的大规模信息系统，如Oracle Database</li>
</ul>
</li>
<li>按使用场景分类<ul>
<li>桌面级DBMS：适用于微小型的信息服务应用，针对小规模或个人信息服务，对数据处理能力要求不高，通常只支持单一语言的应用程序开发，如Access、SQLite等</li>
<li>企业级DBMS：适用于中大型的企业级应用，针对中大规模信息服务，对功能、可靠性和性能有较高要求，支持多种不同语言的应用程序开发，如DB2、Oracle Database、Sybase ASE等</li>
</ul>
</li>
<li>按软件版权分类<ul>
<li>产品DBMS：厂商拥有版权的数据库软件，面向市场出售技术服务，如SQL Server、 Oracle Database等</li>
<li>开源DBMS：开源组织提供的数据库软件，免费下载供学习科研使用，如MySQL、PostgreSQL等</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-5-PostgreSQL对象-关系数据库系统软件、"><a href="#1-5-PostgreSQL对象-关系数据库系统软件、" class="headerlink" title="1.5 PostgreSQL对象-关系数据库系统软件、"></a>1.5 PostgreSQL对象-关系数据库系统软件、</h1><h2 id="1-5-1–1-5-3-略"><a href="#1-5-1–1-5-3-略" class="headerlink" title="1.5.1–1.5.3 略"></a>1.5.1–1.5.3 略</h2><h2 id="1-5-4-PostgreSQL数据库软件的服务器程序的部分常用命令"><a href="#1-5-4-PostgreSQL数据库软件的服务器程序的部分常用命令" class="headerlink" title="1.5.4 PostgreSQL数据库软件的服务器程序的部分常用命令"></a>1.5.4 PostgreSQL数据库软件的服务器程序的部分常用命令</h2><ul>
<li>initdb:初始化PostgreSQL数据库</li>
<li>pg_controldata:显示一个PostgreSQL数据库集群的控制信息</li>
<li>pg_ctl:启动、停止或者控制PostgreSQL服务器</li>
<li>pg_resetxlog:重置一个数据库集群的预写日志以及其它控制内容</li>
<li>postgres:PostgreSQL数据库服务器进程</li>
<li>postmaster:PostgreSQL守护进程<h2 id="1-5-5-PostgreSQL数据库的常用管理工具"><a href="#1-5-5-PostgreSQL数据库的常用管理工具" class="headerlink" title="1.5.5 PostgreSQL数据库的常用管理工具"></a>1.5.5 PostgreSQL数据库的常用管理工具</h2></li>
<li>psql命令行管理工具：psql是一个PostgreSQL内置的客户端工具，该工具使用户通过执行命令以交互式方式实现PostgreSQL数据库管理</li>
<li>pgAdmin图形界面管理工具<h2 id="1-5-6-PostgreSQL数据库主要对象"><a href="#1-5-6-PostgreSQL数据库主要对象" class="headerlink" title="1.5.6 PostgreSQL数据库主要对象"></a>1.5.6 PostgreSQL数据库主要对象</h2></li>
<li>模式对象：一种构成数据库下级逻辑结构的数据库对象，用于按用户或按应用分类组织其它数据库对象</li>
<li>表对象：一种用户组织存储数据的数据库对象，主要有三种类型：<strong>关系表、继承表、外部表</strong></li>
<li>视图对象：一种基于虚拟表操作数据的数据库对象</li>
<li>序列对象：一种为代理键列提供自动增量序列值的数据库对象，提供自动增量序列值的数据库对象</li>
<li>函数对象：一种使用内置编程语言编写数据库访问操作功能程序的数据库对象，PostgreSQL没有单独的存储对象，而是通过函数来实现存储过程功能</li>
<li>触发器对象：一种事件触发、自动执行的数据库访问操作功能程序的数据库对象</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记_数据库原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据库原理</tag>
      </tags>
  </entry>
  <entry>
    <title>操作系统笔记3</title>
    <url>/2022/04/13/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>数据库原理笔记3</title>
    <url>/2022/03/24/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h1 id="依照学校教学安排，第三章为数据库操作SQL语言"><a href="#依照学校教学安排，第三章为数据库操作SQL语言" class="headerlink" title="依照学校教学安排，第三章为数据库操作SQL语言"></a>依照学校教学安排，第三章为数据库操作SQL语言</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="3-1-SQL语言概述"><a href="#3-1-SQL语言概述" class="headerlink" title="3.1 SQL语言概述"></a>3.1 SQL语言概述</h1><h2 id="3-1-1-SQL简介"><a href="#3-1-1-SQL简介" class="headerlink" title="3.1.1 SQL简介"></a>3.1.1 SQL简介</h2><p>结构化查询语言SQL是一种对关系数据库进行访问的数据操作语言，于上世纪70年代由SEQUEL语言演变而来。当下主流关系型数据库管理系统均支持SQL标准语言实现数据库操作。<br>SQL的语言特点：</p>
<ul>
<li>一体化：SQL语言命令集可以完成关系数据库的数据查询、数据定义、数据操纵、数据库管理、数据库控制等操作。</li>
<li>使用方式灵活：既可以以交互命令方式操作访问数据库，也可以嵌入到程序语言中编程访问数据库。</li>
<li>非过程化：SQL对数据库的操作只需告诉DBMS做什么而不需要告诉它怎么做。</li>
<li>语言语法简单：语句少且简洁。</li>
</ul>
<h2 id="3-1-2-SQL对关系数据库的操作原理"><a href="#3-1-2-SQL对关系数据库的操作原理" class="headerlink" title="3.1.2 SQL对关系数据库的操作原理"></a>3.1.2 SQL对关系数据库的操作原理</h2><p>用户（数据库应用程序）对关系数据库进行任何操作，都需要将SQL语句提交给DBMS执行，DBMS执行时将SQL语句转为对数据库文件的输入输出操作，并将读取的数据组装为<strong>操作结果集</strong>返回给用户（数据库应用程序）<br>SQL主要操作功能：</p>
<ul>
<li>数据库对象创建、修改、删除</li>
<li>数据库表的数据插入、修改、删除、查询、统计</li>
<li>存储过程、触发器、函数等程序执行</li>
<li>数据库权限、角色、用户等管理</li>
</ul>
<h2 id="3-1-3-SQL语言语句类型"><a href="#3-1-3-SQL语言语句类型" class="headerlink" title="3.1.3 SQL语言语句类型"></a>3.1.3 SQL语言语句类型</h2><ul>
<li>数据定义语句DDL：是SQL语言中用于创建、修改或删除数据库对象的语句，DDL不但可以用于数据库对象的管理，也可以定义数据库对象约束<ul>
<li>CREATE DATABASE - 创建新数据库 </li>
<li>DROP DATABASE - 删除数据库</li>
<li>ALTER DATABASE - 修改数据库属性</li>
<li>CREATE TABLE - 创建新表</li>
<li>ALTER TABLE - 修改数据库表结构</li>
<li>DROP TABLE - 删除表</li>
<li>CREATE INDEX - 创建索引</li>
<li>DROP INDEX - 删除索引</li>
</ul>
</li>
<li>数据操纵语句DML：是SQL语言中用于增加、修改、删除的语句<ul>
<li>INSERT - 向数据库表中插入语句</li>
<li>UPDATE - 更新数据库表中的数据</li>
<li>DELETE - 从数据库表中删除数据</li>
</ul>
</li>
<li>数据查询语句DQL：是SQL语言中用于对数据库进行数据查询的语句<ul>
<li>SELECT - 对表的内容进行查询</li>
<li>DESC - 查看关系表结构</li>
</ul>
</li>
<li>数据控制语句DCL：是SQL语言中用于对数据库对象访问权进行控制的语句<ul>
<li>GRANT - 授予用户对数据库对象的权限</li>
<li>DENY - 拒绝授予用户对数据库对象的权限</li>
<li>REVOKE - 撤销用户对数据库对象的权限</li>
</ul>
</li>
<li>事务处理语句TPL：是SQL语言中用于数据库内部事务处理的语句<ul>
<li>BEGIN TRANSACTION - 开始事务</li>
<li>COMMIT - 提交事务</li>
<li>ROLLBACK - 回滚事务</li>
</ul>
</li>
<li>游标控制语言CCL：是SQL语言中用于数据库游标操作的语句，游标是是一个存储在MySQL服务器上的数据库查询，它不是一条SELECT语句，而是被该语句检索出来的结果集。在存储了游标之后，应用程序可以根据需要滚动或浏览其中的数据<ul>
<li>DECLARE CURSOR - 定义游标 </li>
<li>FETCH INTO - 提交游标数据</li>
<li>CLOSE CURSOR - 关闭游标</li>
</ul>
</li>
</ul>
<h2 id="3-1-4-SQL语言的数据类型"><a href="#3-1-4-SQL语言的数据类型" class="headerlink" title="3.1.4 SQL语言的数据类型"></a>3.1.4 SQL语言的数据类型</h2><ul>
<li>SQL语言基本数据类型<ul>
<li>字符：CHAR\VARCHAR\TEXT…</li>
<li>整数：SMALLINT\INTEGER…</li>
<li>浮点数：NUMBER\FLOAT…</li>
<li>日期：DATE\DATETIME…</li>
<li>货币：MONEY…<br><img src="../photos/DataBaseCourse/3_1.png" title="PostgreSQL主要数据类型"><br><img src="../photos/DataBaseCourse/3_2.png" title="SQL Server数据类型"><br><img src="../photos/DataBaseCourse/3_3.png" title="MySQL数据类型"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-2-数据定义SQL语句"><a href="#3-2-数据定义SQL语句" class="headerlink" title="3.2 数据定义SQL语句"></a>3.2 数据定义SQL语句</h1><h2 id="3-2-1-数据库创建SQL语句"><a href="#3-2-1-数据库创建SQL语句" class="headerlink" title="3.2.1 数据库创建SQL语句"></a>3.2.1 数据库创建SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE &lt;数据库名&gt;;</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句创建数据库</li>
</ul>
<h2 id="3-2-2-数据库、关系表修改SQL语句"><a href="#3-2-2-数据库、关系表修改SQL语句" class="headerlink" title="3.2.2 数据库、关系表修改SQL语句"></a>3.2.2 数据库、关系表修改SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//修改方式语句类型</span><br><span class="line">//ADD修改方式，用于添加新列或列完整性约束</span><br><span class="line">ALTER TABLE &lt;表名&gt; ADD &lt;新列名称&gt; &lt;数据类型&gt; 完整性约束;</span><br><span class="line"></span><br><span class="line">//DROP修改方式，用于删除指定列或列的完整性约束条件</span><br><span class="line">ALTER TABLE &lt;表名&gt; DROP COLUMN &lt;列名&gt;;</span><br><span class="line">ALTER TABLE &lt;表名&gt; DROP CONSTRAINT;&lt;完整性约束名&gt;;</span><br><span class="line"></span><br><span class="line">//RENAME修改方式，用于修改表名称、列名称</span><br><span class="line">ALTER TABLE &lt;表名&gt; RENAME TO &lt;新表名&gt;;</span><br><span class="line">ALTER TABLE &lt;表名&gt; RENAME &lt;原列名&gt; TO &lt;新列名&gt;;</span><br><span class="line"></span><br><span class="line">//ALTER修改方式，用于修改数据库名、表名、列的数据类型</span><br><span class="line">ALTER DATABASE &lt;数据库名&gt; &lt;修改内容&gt;;</span><br><span class="line">ALTER TABLE &lt;表名&gt; 修改方式;</span><br><span class="line">ALTER TABLE &lt;表名&gt; ALTER COLUMN &lt;列名&gt; TYPE &lt;新的数据类型&gt;;</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句修改数据库或数据库内容</li>
</ul>
<h2 id="3-2-3-数据库、关系表删除SQL语句"><a href="#3-2-3-数据库、关系表删除SQL语句" class="headerlink" title="3.2.3 数据库、关系表删除SQL语句"></a>3.2.3 数据库、关系表删除SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP DATABASE &lt;数据库名&gt;;</span><br><span class="line">DROP TABLE &lt;表名&gt;;</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句删除数据库或数据库内容</li>
</ul>
<h2 id="3-2-4-数据库表创建SQL语句"><a href="#3-2-4-数据库表创建SQL语句" class="headerlink" title="3.2.4 数据库表创建SQL语句"></a>3.2.4 数据库表创建SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;列名1&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   ...</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句创建数据库关系表</li>
</ul>
<h2 id="3-2-5-列完整性约束"><a href="#3-2-5-列完整性约束" class="headerlink" title="3.2.5 列完整性约束"></a>3.2.5 列完整性约束</h2><ul>
<li>约束类型<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PRIMARY KEY //主键</span><br><span class="line">NOT NULL //非空值</span><br><span class="line">NULL //空值</span><br><span class="line">UNIQUE //值唯一</span><br><span class="line">CHECK //有效性检查</span><br><span class="line">DEFAULT //缺省值</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句添加列完整性约束</li>
</ul>
<h2 id="3-2-6-表约束定义主键"><a href="#3-2-6-表约束定义主键" class="headerlink" title="3.2.6 表约束定义主键"></a>3.2.6 表约束定义主键</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//PRIMARY KEY定义表的主键列只能定义单列主键，若要定义由多个列构成的复合主键，则需要使用表约束方式来定义</span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;列名1&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">...</span><br><span class="line">   CONSTRAINT &lt;约束名&gt; PRIMARY Key (主键列名1,主键列名2)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句定义主键、复合主键</li>
<li>使用表约束定义主键的优点：<ul>
<li>便于定义复合主键</li>
<li>可命名主键约束</li>
<li>便于定义代理键</li>
</ul>
</li>
</ul>
<h2 id="3-2-7-表约束定义代理键"><a href="#3-2-7-表约束定义代理键" class="headerlink" title="3.2.7 表约束定义代理键"></a>3.2.7 表约束定义代理键</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在一些关系表中，为了方便数据处理，可以使用代理键去替代复合主键。在SQL语句中，关系表的代理键采用表约束方式来定义</span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;代理键列名&gt; &lt;Serial数据类型&gt; NOT NULL,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">...</span><br><span class="line">   CONSTRAINT &lt;约束名&gt; PRIMARY Key (代理键列名)</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句定义代理键</li>
</ul>
<h2 id="3-2-8-表约束定义外键"><a href="#3-2-8-表约束定义外键" class="headerlink" title="3.2.8 表约束定义外键"></a>3.2.8 表约束定义外键</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//在数据库中，一些关系表之间存在关联，在一个表中作为主键的列，在另外的关联表中则作为外键</span><br><span class="line">CREATE TABLE &lt;表名&gt;</span><br><span class="line"> ( &lt;列名1&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名2&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">   &lt;列名3&gt; &lt;数据类型&gt; 列完整性约束,</span><br><span class="line">...</span><br><span class="line">   CONSTRAINT &lt;约束名&gt; FOREIGN Key (外键列名)</span><br><span class="line">       REFERENCES  外键列所在表名(外键列名)</span><br><span class="line">     ON DELETE CASCADE//联级删除，如果主表中的一个列被删除了，那么应用该列的从表中的所有记录也被删除</span><br><span class="line"> );</span><br></pre></td></tr></table></figure></li>
<li>语句执行：在PostgreSQL服务器中，执行SQL语句定义外键</li>
</ul>
<h2 id="3-2-9-数据库索引操作语句、"><a href="#3-2-9-数据库索引操作语句、" class="headerlink" title="3.2.9 数据库索引操作语句、"></a>3.2.9 数据库索引操作语句、</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><ul>
<li>索引是一种按照关系表中指定列的取值顺序组织元组数据存储的数据结构，使用它可以加快表中数据的查询访问</li>
<li>在索引数据结构中，采用树结构的各个结点存储索引值及其指针，索引叶结点的指针指向数据库文件中的元组数据块地址<br><img src="../photos/DataBaseCourse/3_4.png" title="B树索引结构图"></li>
<li>索引作用及其特点<ul>
<li>索引作用：支持对数据库表中数据快速查找</li>
<li>索引优点<ul>
<li>提高数据检索速度</li>
<li>可快速连接关联表</li>
<li>减少分组和排序时间</li>
</ul>
</li>
<li>索引开销<ul>
<li>创建和维护索引都需要较大开销</li>
<li>索引会占用额外存储空间</li>
<li>数据操纵困难因维护索引带来系统性能开销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="数据库索引创建、修改、删除语句"><a href="#数据库索引创建、修改、删除语句" class="headerlink" title="数据库索引创建、修改、删除语句"></a>数据库索引创建、修改、删除语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 数据库索引创建语句</span><br><span class="line">CREATE INDEX &lt;索引名&gt; ON &lt;表名&gt; &lt;(列名)&gt;;</span><br><span class="line"></span><br><span class="line">// 数据库索引修改语句</span><br><span class="line">ALTER INDEX &lt;索引名&gt; 修改项;//具体修改语法见3.2.2</span><br><span class="line"></span><br><span class="line">// 数据库索引删除语句</span><br><span class="line">DROP INDEX &lt;索引名&gt;;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-3-数据操纵SQL语句"><a href="#3-3-数据操纵SQL语句" class="headerlink" title="3.3 数据操纵SQL语句"></a>3.3 数据操纵SQL语句</h1><h2 id="3-3-1-数据插入SQL语句"><a href="#3-3-1-数据插入SQL语句" class="headerlink" title="3.3.1 数据插入SQL语句"></a>3.3.1 数据插入SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//插入一个元组语法如下，插入几个元组就写几行</span><br><span class="line">INSERT INTO 表名或视图名    如果元组只有个别列有数据，这里可以再写一个列名表表示要给哪几个列赋值，不写的话缺省值默认为NULL并自动补全 VALUES (该元组的所有数据从左到右排列，之间用逗号隔开);</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-3-2-数据修改SQL语句"><a href="#3-3-2-数据修改SQL语句" class="headerlink" title="3.3.2 数据修改SQL语句"></a>3.3.2 数据修改SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">UPDATE 表名或视图名 //UPDATE关键字指定修改的是哪个表或视图</span><br><span class="line">SET 列名1=新数据 //SET关键字指定对哪些列设定新值，注意字符串要给单引号</span><br><span class="line">WHERE 条件表达式;//WHERE关键字给出修改的前提条件，比如需要指定行用到的 xxx=xxx</span><br><span class="line">//看不懂的见下图</span><br></pre></td></tr></table></figure>
<img src="../photos/DataBaseCourse/3_5.png" title="数据更新实例"></li>
</ul>
<h2 id="3-3-3-数据删除SQL语句"><a href="#3-3-3-数据删除SQL语句" class="headerlink" title="3.3.3 数据删除SQL语句"></a>3.3.3 数据删除SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//一次删除一个元组，删几个元组写几遍</span><br><span class="line">DELETE</span><br><span class="line">FROM 表名或视图名</span><br><span class="line">WHERE 条件表达式</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h1 id="3-4-数据查询SQL语句"><a href="#3-4-数据查询SQL语句" class="headerlink" title="3.4 数据查询SQL语句"></a>3.4 数据查询SQL语句</h1><h2 id="3-4-1-单表数据查询"><a href="#3-4-1-单表数据查询" class="headerlink" title="3.4.1 单表数据查询"></a>3.4.1 单表数据查询</h2><h3 id="数据查询SQL语句格式"><a href="#数据查询SQL语句格式" class="headerlink" title="数据查询SQL语句格式"></a>数据查询SQL语句格式</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT ALL或DISTINCT 目标列 //选ALL就是有啥输出啥，有DISTINCT就是去掉重复的数据行，如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">INTO 新表</span><br><span class="line">FROM 表名或视图名 //多个表名或视图名可以用逗号隔开，往后续</span><br><span class="line">//如果是条件查询 就写 &quot;WHERE 条件表达式&quot;</span><br><span class="line">//如果是分组统计查询就写 &quot;GROUP BY 列名&quot;,如果有条件接着写 &quot;HAVING 条件表达式&quot;</span><br><span class="line">//如果查询结果需要排序输出就写 &quot;ORDER BY 列名&quot;这个子句要放在WHERE后面（如果有的话）,如果接着写&quot;ASC或DESC&quot;, ASC是升序排列，DESC是降序排列</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="从单个表读取指定列"><a href="#从单个表读取指定列" class="headerlink" title="从单个表读取指定列"></a>从单个表读取指定列</h3><p>在关系数据库中，最简单的数据查询操作就是从单个关系表中读取指定列的数据，即关系的投影操作 <em>（说白了就是把列拎出来组成结果集）</em></p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 目标列//如果有多个目标列可以用逗号隔开，接着往后续，如果要查询所有列数据，就写个 *</span><br><span class="line">FROM 关系表名;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="从单个表读取指定行"><a href="#从单个表读取指定行" class="headerlink" title="从单个表读取指定行"></a>从单个表读取指定行</h3><p>SQL查询语句也可以从一个关系表中读取满足条件的指定行数据，即完成关系数据的元组选择操作</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT *</span><br><span class="line">FROM 关系表</span><br><span class="line">WHERE 条件表达式;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="从单个表读取指定行和列"><a href="#从单个表读取指定行和列" class="headerlink" title="从单个表读取指定行和列"></a>从单个表读取指定行和列</h3><p>在SQL查询语句中，还可以从一个关系表中读取指定行与指定列范围内的数据。既完成关系的行选择，又完成关系的列投影操作。</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 目标列//如果有多个目标列可以用逗号隔开，接着往后续，如果要查询所有列数据，就写个 *</span><br><span class="line">FROM 关系表</span><br><span class="line">WHERE 条件表达式;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="WHERE条件子句"><a href="#WHERE条件子句" class="headerlink" title="WHERE条件子句"></a>WHERE条件子句</h3><p>使用WHERE子句中可以使用如下方式，指定范围数据</p>
<ul>
<li>使用<strong>BETWEEN…AND</strong>关键词来限定列值范围，还可以使用关键词LIKE与通配符来限定查询条件</li>
<li>使用通配符来限定字符串数据范围。_通配符用于代表一个未指定的字符，%通配符用于代表一个或多个未指定的字符<br>在SQL查询WHERE子句中，还可以使用多个条件表达式，并通过逻辑运算符AND\OR\NOT连接操作，以及使用IN\NOT IN关键词，进一步限定结果集的数据范围</li>
</ul>
<h3 id="对结果集进行排序"><a href="#对结果集进行排序" class="headerlink" title="对结果集进行排序"></a>对结果集进行排序</h3><p>在SELECT查询语句返回的结果集中，行的顺序是任意的。如果需要结果集排序，可以在SELECT语句中加入ORDER BY 关键字<br>在ORDER子句中可以使用ASC和DESC指定排序是升序还是降序，也可以ASC和DESC搭配使用，若要先按某列数据升序\降序排列元组，再对其中数据相同的元组以别的列的数据升序\降序排列元组，则在ORDER BY后的这几个列之间用逗号隔开。</p>
<h2 id="3-4-2-内置函数与分组统计"><a href="#3-4-2-内置函数与分组统计" class="headerlink" title="3.4.2 内置函数与分组统计"></a>3.4.2 内置函数与分组统计</h2><h3 id="SQL内置函数类型"><a href="#SQL内置函数类型" class="headerlink" title="SQL内置函数类型"></a>SQL内置函数类型</h3><p>SQL语言提供了大量内置函数，支持对SELECT查询结果数据进行处理<br>典型SQL内置函数类型如下：</p>
<ul>
<li>聚合函数</li>
<li>算术函数</li>
<li>字符串函数</li>
<li>日期时间函数</li>
<li>数据类型转换函数</li>
</ul>
<h3 id="SQL聚合函数"><a href="#SQL聚合函数" class="headerlink" title="SQL聚合函数"></a>SQL聚合函数</h3><p>聚合函数是一些对关系表中数值属性列进行计算并以表的形式返回查询结果的函数<br>AVG() 计算结果集指定列数据的平均值<br>COUNT() 计算结果集行数<br>MIN() 找出结果集指定列数据的最小值<br>MAX() 找出结果集指定列数据的最大值<br>SUM() 计算结果集指定列数据的总和</p>
<h3 id="SQL内置函数与分组统计"><a href="#SQL内置函数与分组统计" class="headerlink" title="SQL内置函数与分组统计"></a>SQL内置函数与分组统计</h3><p>在SQL语言中，可使用内置函数对查询结果集进行分组数据统计。这是通过在SELECT语句中加入Group By子语句来实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//分组统计SQL语句基本格式：</span><br><span class="line">SELECT 统计函数/目标列</span><br><span class="line">FROM 表名</span><br><span class="line">//如果需要添加条件就写&quot;WHERE 条件表达式&quot;</span><br><span class="line">GROUP BY 目标列</span><br><span class="line">//HAVING字句 是对GROUP BY的结果进行限制，如要添加，则写&quot;HAVING 条件表达式&quot;</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h2 id="3-4-3-多表关联查询"><a href="#3-4-3-多表关联查询" class="headerlink" title="3.4.3 多表关联查询"></a>3.4.3 多表关联查询</h2><h3 id="子查询与多表关联"><a href="#子查询与多表关联" class="headerlink" title="子查询与多表关联"></a>子查询与多表关联</h3><p>在实际应用中，通常需要关联多表才能获得所需的信息。在SELECT查询语句中，可使用子查询方式实现多表关联查询。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//子查询SQL语句基本格式：</span><br><span class="line">SELECT 目标列 //如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">FROM 表名</span><br><span class="line">WHERE 条件中嵌套另一关系表的SELECT查询结果集</span><br><span class="line">;</span><br><span class="line">//例子见下表</span><br></pre></td></tr></table></figure>
<p><img src="../photos/DataBaseCourse/3_6.png" title="子查询示例"></p>
<h3 id="使用连接关联多表查询"><a href="#使用连接关联多表查询" class="headerlink" title="使用连接关联多表查询"></a>使用连接关联多表查询</h3><p>在使用多个表查询时，子查询只有在结果数据均来自一个表的情况下才有用。但如果需要从两个或多个表中获取结果数据，就不能使用子查询，而需要采用连接关联多表查询</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//关联多表查询SQL语句基本格式：</span><br><span class="line">SELECT 目标列 //如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">FROM 表名  //如果数据来自多个表可以用逗号隔开，接着往后续</span><br><span class="line">WHERE 关系表之间的连接关联条件</span><br><span class="line">;</span><br><span class="line">//例子见下表</span><br></pre></td></tr></table></figure>
<p><img src="../photos/DataBaseCourse/3_7.png" title="关联多表查询示例"></p>
<h3 id="SQL-JOIN…ON连接查询语句"><a href="#SQL-JOIN…ON连接查询语句" class="headerlink" title="SQL JOIN…ON连接查询语句"></a>SQL JOIN…ON连接查询语句</h3><p>在SQL语言中，实现多表连接关联查询还可以使用JOIN…ON关键词的语句格式。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//两表连接关联查询的JOIN...ON语句格式：</span><br><span class="line">SELECT 目标列 //如果有多个目标列可以用逗号隔开，接着往后续</span><br><span class="line">FROM 表名1 JOIN 表名2 ON 连接条件</span><br><span class="line">//有具体排序需要可以添加ORDER BY子句;</span><br><span class="line">//例子见下表</span><br></pre></td></tr></table></figure>
<p><img src="../photos/DataBaseCourse/3_8.png" title="使用JOIN...ON语句进行关联多表查询示例"></p>
<h3 id="外部连接"><a href="#外部连接" class="headerlink" title="外部连接"></a>外部连接</h3><p>在一些特殊情况下，如关联表中的一些行的主键与外键不匹配（比如某个属性作为主键时的行数和在其它表中做外键时的行数不同），查询结果集就会丢失部分数据，此时就不能找出在某表中存在但在其它表没有的元组。在SQL应用中，有时候也希望输出那些不满足连接条件的元组数据。此时，可使用JOIN…ON外连接方式实现。其实现方式有三种形式，具体如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">//搭配2.2.5食用风味更佳</span><br><span class="line">LEFT JOIN //即使没有与右表关联列值匹配，也从左表返回所有的行</span><br><span class="line">RIGHT JOIN //即使没有与左表关联列值匹配，也从右表返回所有的行</span><br><span class="line">FULL JOIN //全外连接，同时进行左连接和右连接，返回所有行</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-5-数据控制SQL语句"><a href="#3-5-数据控制SQL语句" class="headerlink" title="3.5 数据控制SQL语句"></a>3.5 数据控制SQL语句</h1><h2 id="3-5-1-什么是数据控制SQL语句"><a href="#3-5-1-什么是数据控制SQL语句" class="headerlink" title="3.5.1 什么是数据控制SQL语句"></a>3.5.1 什么是数据控制SQL语句</h2><p>在SQL语言中，数据控制SQL语句是一种可对用户数据访问权进行控制的操作语句，它可以控制特定用户或角色对数据表、视图、存储过程、触发器等数据库对象的访问权限</p>
<ul>
<li>数据控制SQL语句分类<ul>
<li>GRANT授权语句：是一种由数据库对象创建者或管理员执行的权限授予语句，它可以把访问数据库对象权限赋予给其他用户或角色</li>
<li>REVOKE收权语句：是一种由数据库对象创建或管理员赋予其它用户或角色的权限进行收回的语句，它可以收回原赋予给其他用户或角色的权限</li>
<li>DENY拒绝权限语句：是一种用于拒绝给当前数据库内的用户或者角色授予权限并防止用户或角色通过其组或角色成员继承权限的语句</li>
</ul>
</li>
</ul>
<h3 id="GRANT授权语句"><a href="#GRANT授权语句" class="headerlink" title="GRANT授权语句"></a>GRANT授权语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">GRANT 权限列表  ON 数据库对象 TO 用户或角色</span><br><span class="line">//若后面接&quot;WITH GRANT OPTION&quot;子句，则被授权角色或用户还可将这些权限赋给其他用户或角色</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="REVOKE收权语句"><a href="#REVOKE收权语句" class="headerlink" title="REVOKE收权语句"></a>REVOKE收权语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REVOKE 权限列表 ON 数据库对象 FROM 用户或角色</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<h3 id="DENY拒绝权限语句"><a href="#DENY拒绝权限语句" class="headerlink" title="DENY拒绝权限语句"></a>DENY拒绝权限语句</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DENY 权限列表 ON 数据库对象 TO 用户或角色</span><br><span class="line">;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="3-6-视图SQL语句"><a href="#3-6-视图SQL语句" class="headerlink" title="3.6 视图SQL语句"></a>3.6 视图SQL语句</h1><h2 id="3-6-1-什么是视图"><a href="#3-6-1-什么是视图" class="headerlink" title="3.6.1 什么是视图"></a>3.6.1 什么是视图</h2><p><strong>视图</strong>是一种通过基础表或其它视图构建的虚拟表，它本身没有自己的数据，而是使用了存储在基础表中的数据</p>
<h2 id="3-6-2-视图创建SQL语句"><a href="#3-6-2-视图创建SQL语句" class="headerlink" title="3.6.2 视图创建SQL语句"></a>3.6.2 视图创建SQL语句</h2><ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE VIEW 视图名 AS SELECT查询//SELECT语句用于指定目标列</span><br><span class="line">FROM 表名</span><br><span class="line">//如果有条件限制 就加上 &quot;WHERE 条件表达式&quot;</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-6-3-视图调用SQL语句"><a href="#3-6-3-视图调用SQL语句" class="headerlink" title="3.6.3 视图调用SQL语句"></a>3.6.3 视图调用SQL语句</h2><p>当视图在数据库中创建后，用户可以像访问关系表一样去操作访问视图</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT 列名表/*</span><br><span class="line">FROM 视图名</span><br><span class="line">//如果要特殊排列，则添加&quot;ORDER BY 列名&quot;子句</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-6-4-视图删除SQL语句"><a href="#3-6-4-视图删除SQL语句" class="headerlink" title="3.6.4 视图删除SQL语句"></a>3.6.4 视图删除SQL语句</h2><p>当数据库不再需要某视图时，可以在数据库中删除该视图</p>
<ul>
<li>语句基本格式<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP VIEW 视图名//</span><br><span class="line">;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="3-6-5-视图应用"><a href="#3-6-5-视图应用" class="headerlink" title="3.6.5 视图应用"></a>3.6.5 视图应用</h2><h3 id="使用视图简化复杂SQL查询操作"><a href="#使用视图简化复杂SQL查询操作" class="headerlink" title="使用视图简化复杂SQL查询操作"></a>使用视图简化复杂SQL查询操作</h3><p>数据库开发人员可以将复杂的SQL查询语句封装在视图内，外部程序只需使用简单的试图访问方式，便可获取所需要的数据<br><img src="../photos/DataBaseCourse/3_9.png" title="创建关联表语句写法"><br><img src="../photos/DataBaseCourse/3_10.png" title="创建视图语句写法"><br><del>Emm…感觉视图写法更复杂了…</del><br>当视图被创建完成后，外部程序就可以通过SELECT语句查询视图数据 <em>(具体写法见3.6.3)</em></p>
<h3 id="使用视图提高数据访问安全性"><a href="#使用视图提高数据访问安全性" class="headerlink" title="使用视图提高数据访问安全性"></a>使用视图提高数据访问安全性</h3><p>通过视图可以将数据表内敏感数据隐藏起来，外部用户无法得知数据表的完整数据，降低数据库被攻击的风险，还可以保护用户隐私数据</p>
<h3 id="提供一定程度的数据逻辑独立性"><a href="#提供一定程度的数据逻辑独立性" class="headerlink" title="提供一定程度的数据逻辑独立性"></a>提供一定程度的数据逻辑独立性</h3><p>通过视图，可提供一定程度的数据逻辑独立性。当数据表结构发生改变，只要视图结构不变，应用程序可以不作修改</p>
<h3 id="集中展示用户所感兴趣的特定数据"><a href="#集中展示用户所感兴趣的特定数据" class="headerlink" title="集中展示用户所感兴趣的特定数据"></a>集中展示用户所感兴趣的特定数据</h3><p>通过视图，可以将用户不关心的部分数据进行过滤</p>
<hr>
<h1 id="3-7-PostgreSQL数据库实践（略）"><a href="#3-7-PostgreSQL数据库实践（略）" class="headerlink" title="3.7 PostgreSQL数据库实践（略）"></a>3.7 PostgreSQL数据库实践（略）</h1>]]></content>
      <categories>
        <category>课程笔记_数据库原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据库原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理笔记2</title>
    <url>/2022/03/21/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="依照学校教学安排，第二章为数据库关系模型"><a href="#依照学校教学安排，第二章为数据库关系模型" class="headerlink" title="依照学校教学安排，第二章为数据库关系模型"></a>依照学校教学安排，第二章为数据库关系模型</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<h1 id="2-1-关系及其相关概念"><a href="#2-1-关系及其相关概念" class="headerlink" title="2.1 关系及其相关概念"></a>2.1 关系及其相关概念</h1><h2 id="2-1-1-关系模型的提出"><a href="#2-1-1-关系模型的提出" class="headerlink" title="2.1.1 关系模型的提出"></a>2.1.1 关系模型的提出</h2><p>关系模型以关系代数理论为数学基础，将数据操作抽象为关系处理，其关系表结构简单，便于理解和访问。关系模型在当今几乎所有商业数据库中得到广泛应用，该理论由E.F.Codd于1970年发表。</p>
<h2 id="2-1-2-实体、关系的概念"><a href="#2-1-2-实体、关系的概念" class="headerlink" title="2.1.2 实体、关系的概念"></a>2.1.2 实体、关系的概念</h2><ul>
<li><strong>实体</strong>：包含有数据特征的事物对象在概念模型世界中的抽象名称，可以理解成对象</li>
<li><strong>关系</strong>：在关系模型中，使用关系来存储实体中的数据，关系指<strong>具有关系特征、用于存放实体数据的二维表</strong>，关系也常被称为关系表</li>
<li><strong>关系特征</strong>：在关系表中，每一行称为<strong>元组</strong>，每一列称为<strong>属性</strong><ul>
<li>表中每行存储实体的一个示例数据</li>
<li>表中每列包含实体的一项属性数据</li>
<li>表中单元格只能存储单个值</li>
<li>不允许有重复的行、列</li>
<li>行列顺序可任意</li>
</ul>
</li>
</ul>
<h2 id="2-1-3-关系的数学定义"><a href="#2-1-3-关系的数学定义" class="headerlink" title="2.1.3 关系的数学定义"></a>2.1.3 关系的数学定义</h2><ul>
<li><strong>定义</strong>：关系是指在集合域D<sub>1</sub>、…、D<sub>n</sub>上运算笛卡尔积 *(设A、B是两个集合，称集合AxB={&lt;a,b&gt;|(a∈A)^(b∈B)}为集合A与B的笛卡尔积)*的有意义子集，其数学描述为R⊆D<sub>1</sub>xD<sub>2</sub>x、…、xD<sub>n</sub>，其中每一个向量(d1,d2,…dn)称为一个<strong>n元组</strong>，简称元组。想两种的每个di称为分量。若集合域D<sub>i</sub>(i=1,2,…,n)为有限集，每个域的基数为m<sub>i</sub>(i=1,2,…,n)，则笛卡尔积D<sub>1</sub>xD<sub>2</sub>x、…、xD<sub>n</sub>的基数M为m<sub>i</sub>从1到n的累乘</li>
<li><strong>注意</strong>：关系R只是该笛卡尔积的<strong>有意义子集</strong>，即关系R的元组数≤笛卡尔积的元组数</li>
</ul>
<h2 id="2-1-4-关系的键定义"><a href="#2-1-4-关系的键定义" class="headerlink" title="2.1.4 关系的键定义"></a>2.1.4 关系的键定义</h2><ul>
<li>在关系中，可以用来唯一标识元组的属性列称为<strong>键</strong>，其它属性列都为非键列</li>
<li><strong>复合键</strong>：关系中用来唯一标识元组的<strong>多列</strong></li>
<li><strong>候选键</strong>：关系中可能有多个列均适合作为键，将其中每个都称为候选键</li>
<li><strong>主键</strong>：关系表中最有代表性的一个候选键，每个关系表中只能定义一个主键<ul>
<li>主键作用<ul>
<li>唯一标识关系表的每行（元组）</li>
<li>与关联表的外键建立联系，实现关系表之间连接</li>
<li>数据库文件使用主键值来组织关系表的数据存储</li>
<li>数据库使用主键索引快速检索数据</li>
</ul>
</li>
</ul>
</li>
<li><strong>代理键</strong>：采用DBMS自动生成的数字序列作为关系表的主键<ul>
<li>代理键的作用：由DBMS自动生成的数字序列作为主键，可替代复合主键，以便获得更高性能的数据访问操作处理</li>
</ul>
</li>
</ul>
<h2 id="2-1-5-关系模式语句表示"><a href="#2-1-5-关系模式语句表示" class="headerlink" title="2.1.5 关系模式语句表示"></a>2.1.5 关系模式语句表示</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">RELATION_NAME(Column01,Column02,...,LastColumn)//关系名称(主键属性,属性名2,...,最后一个属性名)</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="2-2-关系模型原理"><a href="#2-2-关系模型原理" class="headerlink" title="2.2 关系模型原理"></a>2.2 关系模型原理</h1><h2 id="2-2-1-关系模型及其组成"><a href="#2-2-1-关系模型及其组成" class="headerlink" title="2.2.1 关系模型及其组成"></a>2.2.1 关系模型及其组成</h2><ul>
<li><strong>关系模型</strong>：一种基于二维表结构存储数据实体及实体间联系的数据模型<ul>
<li>数据结构：关系模型由若干二维表组成，并且表之间存在一定的联系，它们一起组织、存储数据</li>
<li>数据操作：关系模型中可以进行集合运算操作（选择、投影、连接、交、并、差……）、专门关系运算操作（数据行插入、修改、删除）</li>
<li>数据约束：在关系模型中，数据关系约束是指关系表中实体数据完整性、关联表之间数据一致性（属性列取值类型、属性列取值范围、属性列取值是否唯一、属性列是否允许空值）等要求，一般由业务需求来确定</li>
</ul>
</li>
</ul>
<h2 id="2-2-2-关系模型数据操作"><a href="#2-2-2-关系模型数据操作" class="headerlink" title="2.2.2 关系模型数据操作"></a>2.2.2 关系模型数据操作</h2><p>关系模型数据操作采用基于关系代数的数据操作，包括传统的集合运算操作和专门的关系运算操作</p>
<ul>
<li>关系并运算操作：关系并运算的结果集是由属于R或属于S的所有元组组成</li>
<li>关系差运算操作：关系差运算的结果集是由属于R但不属于S的所有元组组成</li>
<li>关系交运算操作：关系交运算的结果集是由既属于R又属于S的所有元组组成</li>
<li>关系笛卡尔积操作：关系笛卡尔积的结果集是由所有属于R的元组和所有属于S的元组进行组合而成</li>
</ul>
<h2 id="2-2-3-关系模型完整性"><a href="#2-2-3-关系模型完整性" class="headerlink" title="2.2.3 关系模型完整性"></a>2.2.3 关系模型完整性</h2><p>关系模型完整性是指在关系数据模型中对关系实施的完整性约束</p>
<ul>
<li>完整性约束作用<ul>
<li>消除关系表的元组重复存储</li>
<li>保持关联表的数据一致性 </li>
<li>实现业务数据规则</li>
</ul>
</li>
<li>关系模型完整性约束组成<ul>
<li>实体完整性约束</li>
<li>参照完整性约束</li>
<li>用户自定义完整性约束</li>
</ul>
</li>
</ul>
<h3 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h3><p>实体完整性是指在关系表中实施的主键取值约束，以保证关系表中的每个元组可以被唯一标识</p>
<ul>
<li>实体完整性约束规则<ul>
<li>每个关系表中的主键属性列都不允许为空值，否则就不可能标识实体</li>
<li>现实世界中的实体是靠主键来标识，主键取值应该唯一，并区分关系表中的每个元组</li>
</ul>
</li>
</ul>
<h3 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h3><p>参照完整性是指关系表之间需要遵守的数据约束，以保证关系之间关联列的数据一致性</p>
<ul>
<li><strong>外键</strong>：在关联的两个主系中，它们具有一个或多个相同属性。若关联列在第一个关系中作为主键，则在第二个关系中作为外键。</li>
<li>参照完整性约束规则：若关系R中的外键F与关系S中的主键K相关联，则R中外键F值必须与S中主键K值一致</li>
</ul>
<h3 id="用户自定义完整性"><a href="#用户自定义完整性" class="headerlink" title="用户自定义完整性"></a>用户自定义完整性</h3><p>用户自定义完整性是指用户根据具体业务对数据处理规则要求所定义的数据约束</p>
<ul>
<li>用户可以定义如下类型的完整性约束：<ul>
<li>定义列的数据类型和数据范围</li>
<li>定义类的缺省值 <em>（无干预情况下的默认值）</em></li>
<li>定义列是否允许取空值</li>
<li>定义列取值唯一性</li>
<li>定义列之间的数据依赖性</li>
</ul>
</li>
</ul>
<h2 id="2-2-4-ON条件、where条件"><a href="#2-2-4-ON条件、where条件" class="headerlink" title="2.2.4 ON条件、where条件"></a>2.2.4 ON条件、where条件</h2><ul>
<li>ON条件：在生成临时表时使用的条件，它不管on中的条件是否都为真，都会返回左表中的记录</li>
<li>where条件：在临时表生成好后，再对临时表进行过滤的条件，此时已经没有leftjoin的含义，条件不为真的就全部过滤掉、</li>
</ul>
<h2 id="2-2-5-自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接"><a href="#2-2-5-自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接" class="headerlink" title="2.2.5 自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接"></a>2.2.5 自然连接、内连接、外连接（左外连接、右外连接、全外连接）、交叉连接</h2><ul>
<li>自然连接：自然连接不用指定连接列，也不能使用ON语句，它默认比较两张表里相同的列</li>
<li>内连接：内连接可以自定义两张表的不同列字段，内连接有两种形式：显式（有INNER JOIN，形成的中间表为两个表经过ON条件过滤后的笛卡尔积）和隐式（没有INNER JOIN，形成的中间表为两个表的笛卡尔积）</li>
<li>外连接<ul>
<li>左外连接：返回指定左表的全部行+右表对应的行，如果左表中数据在右表中没有与其相匹配的行，则在查询结果集合中显示为空值 <em>（null）</em>。</li>
<li>右外连接：与左外连接类似，是左外连接的反向链接</li>
<li>全外连接：将左右两表进行自然连接，左表或右表只要有一个没有就显示NULL<br><a href="https://www.w3school.com.cn/sql/sql_join_inner.asp">关键字使用参考</a></li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-3-PostgreSQL数据库关系操作实践（略）"><a href="#2-3-PostgreSQL数据库关系操作实践（略）" class="headerlink" title="2.3 PostgreSQL数据库关系操作实践（略）"></a>2.3 PostgreSQL数据库关系操作实践（略）</h1>]]></content>
      <categories>
        <category>课程笔记_数据库原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据库原理</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库原理笔记4</title>
    <url>/2022/03/31/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E7%AC%94%E8%AE%B04/</url>
    <content><![CDATA[<h1 id="依照学校教学安排，第四章为数据库设计与实现"><a href="#依照学校教学安排，第四章为数据库设计与实现" class="headerlink" title="依照学校教学安排，第四章为数据库设计与实现"></a>依照学校教学安排，第四章为数据库设计与实现</h1><h1 id="本帖仅供个人学习使用"><a href="#本帖仅供个人学习使用" class="headerlink" title="本帖仅供个人学习使用"></a>本帖仅供个人学习使用</h1><h1 id="使用软件-pgAdmin4-Power-Designer"><a href="#使用软件-pgAdmin4-Power-Designer" class="headerlink" title="使用软件 pgAdmin4, Power Designer"></a>使用软件 pgAdmin4, Power Designer</h1><hr>
<p>（更新中）</p>
<h1 id="4-1-数据库设计概述"><a href="#4-1-数据库设计概述" class="headerlink" title="4.1 数据库设计概述"></a>4.1 数据库设计概述</h1><h2 id="4-1-1-数据库设计方案"><a href="#4-1-1-数据库设计方案" class="headerlink" title="4.1.1 数据库设计方案"></a>4.1.1 数据库设计方案</h2><p>数据库设计是数据库应用系统开发的重要内容。在实现数据库之前，必须有明确的设计方案。数据库设计方案主要体现为数据库设计报告及其设计模型。在数据库设计报告中，需要明确：</p>
<ul>
<li>数据库设计目标</li>
<li>数据库设计思路</li>
<li>数据库设计约束</li>
<li>数据库命名规则</li>
<li>数据库应用结构</li>
<li>数据库应用访问方式</li>
<li>数据库设计模型<br>…</li>
</ul>
<p><strong>数据库设计方案的核心内容有数据库应用架构设计、数据库结构模型设计、数据库应用访问方法设计</strong></p>
<h3 id="数据库应用架构设计"><a href="#数据库应用架构设计" class="headerlink" title="数据库应用架构设计"></a>数据库应用架构设计</h3><p>在不同应用需求场景中，数据库的应用架构方式是不同的。数据库应用架构可分为<strong>单用户结构、集中式结构、客户-服务器结构和分布式结构</strong>。</p>
<h3 id="数据库结构模型设计"><a href="#数据库结构模型设计" class="headerlink" title="数据库结构模型设计"></a>数据库结构模型设计</h3><p>数据库结构模型设计一般分为<strong>概念层设计、逻辑层设计、物理层设计</strong>，它们的设计模型分别为<strong>概念数据模型、逻辑数据模型和物理数据模型</strong>。</p>
<h3 id="数据库应用访问方法设计"><a href="#数据库应用访问方法设计" class="headerlink" title="数据库应用访问方法设计"></a>数据库应用访问方法设计</h3><p>数据库应用对数据库访问可以有多种方式，如<strong>直接本地接口连接访问、基于标准结构连接访问、基于数据访问层框架连接访问</strong></p>
<h2 id="4-1-2-数据库结构模型"><a href="#4-1-2-数据库结构模型" class="headerlink" title="4.1.2 数据库结构模型"></a>4.1.2 数据库结构模型</h2><ul>
<li><strong>概念数据模型</strong>是一种面向用户的系统数据模型，它用来描述现实世界的系统概念化数据结构。使数据库设计人员在系统设计的初始阶段摆脱计算机系统及DBMS的具体技术问题，集中精力分析业务数据以及数据之间的联系等，描述系统的数据对象及其组成关系。</li>
<li><strong>逻辑数据模型</strong>是在概念数据模型的基础上，从系统设计角度描述系统的数据对象组成及其关联结构，并考虑这些数据对象符合数据库对象的逻辑表示。</li>
<li><strong>物理数据模型</strong>是在逻辑数据模型基础上，针对具体DBMS所设计的数据模型。它用于描述系统数据模型在具体DBMS中的数据对象组织、存储方式、索引方式、访问路径等实现信息。<h2 id="4-1-3-数据库开发过程及设计策略"><a href="#4-1-3-数据库开发过程及设计策略" class="headerlink" title="4.1.3 数据库开发过程及设计策略"></a>4.1.3 数据库开发过程及设计策略</h2><h3 id="数据库开发过程"><a href="#数据库开发过程" class="headerlink" title="数据库开发过程"></a>数据库开发过程</h3></li>
<li><strong>数据需求分析阶段</strong><ul>
<li>从现实业务获取数据表单、报表、查询、业务规则、数据更新的说明</li>
<li>分析系统的数据特征、数据类型、数据取值约束</li>
<li>描述系统的数据关系、数据处理要求</li>
<li>建立系统的数据字典</li>
</ul>
</li>
<li><strong>数据库设计阶段</strong><ul>
<li>数据库模型结构设计（概念数据模型、逻辑数据模型、物理数据模型）</li>
<li>数据库索引、视图、查询设计</li>
<li>数据库表约束设计</li>
<li>数据库触发器、存储过程设计</li>
</ul>
</li>
<li><strong>数据库实现阶段</strong><ul>
<li>数据库创建</li>
<li>数据模型物理实现</li>
</ul>
</li>
<li><strong>数据库测试阶段</strong><ul>
<li>数据库数据上线</li>
<li>数据库系统测试</li>
</ul>
</li>
</ul>
<h3 id="设计策略"><a href="#设计策略" class="headerlink" title="设计策略"></a>设计策略</h3><ul>
<li>自底向上设计：首先具体分析各业务数据需求，并抽象各业务的数据实体及其关系，然后设计各个业务的数据模型。在设计过程中，不断地概括、分类与规范数据模型，并建立反应整个组织的全局数据模型。</li>
<li>自顶向下设计：首先从组织机构全局角度规划设计组织机构顶层的数据模型，然后分别对各部门所涉及的业务数据进行实体联系建模。在设计过程中，自顶向下逐步细化数据模型设计。</li>
<li>自内向外设计策略：首先确定组织机构的核心业务，对核心业务数据进行建模设计，然后逐步扩散到其它外围业务的数据模型设计。</li>
<li>混合策略设计：融合以上设计策略，对组织机构数据库进行建模设计，同时应用多种设计策略进行数据建模，避免单一设计策略导致的数据库建模设计局限。</li>
</ul>
<h2 id="4-1-4-主流数据库建模工具Power-Designer"><a href="#4-1-4-主流数据库建模工具Power-Designer" class="headerlink" title="4.1.4 主流数据库建模工具Power Designer"></a>4.1.4 主流数据库建模工具Power Designer</h2><p>当今，数据库设计都必须借助系统建模工具来实现模型设计，此处介绍Power Designer。<br>Power Designer 是一种面向软件开发生命周期的建模工具，它提供软件需求模型、业务流程模型、数据库模型、面向对象模型、自定义模型的开发支持。</p>
<h2 id="4-1-5-Power-Designer各个数据模型之间的关系"><a href="#4-1-5-Power-Designer各个数据模型之间的关系" class="headerlink" title="4.1.5 Power Designer各个数据模型之间的关系"></a>4.1.5 Power Designer各个数据模型之间的关系</h2><p><img src="../photos/DataBaseCourse/4_1.png" title="Power Designer各个数据模型之间的关系示意图 "><br>在通常数据库设计中，首先设计概念数据模型，然后将其转换设计为逻辑数据模型，最后针对选型的数据库DBMS将逻辑数据模型转化为支持该DBMS的物理数据模型。若设计中不考虑规范化问题，可以将概念数据模型直接转换设计为物理数据模型。当完成PDM物理数据模型设计后，便可将其在DBMS系统中进行数据库实现。</p>
<h1 id="4-2-E-R模型方法"><a href="#4-2-E-R模型方法" class="headerlink" title="4.2 E-R模型方法"></a>4.2 E-R模型方法</h1><hr>
<h1 id="4-3-数据库建模设计"><a href="#4-3-数据库建模设计" class="headerlink" title="4.3 数据库建模设计"></a>4.3 数据库建模设计</h1><hr>
<h1 id="4-4-数据库规范化设计"><a href="#4-4-数据库规范化设计" class="headerlink" title="4.4 数据库规范化设计"></a>4.4 数据库规范化设计</h1><hr>
<h1 id="4-5-数据库设计模型SQL实现"><a href="#4-5-数据库设计模型SQL实现" class="headerlink" title="4.5 数据库设计模型SQL实现"></a>4.5 数据库设计模型SQL实现</h1><hr>
<h1 id="4-6-基于Power-Designer的数据库设计建模实践（略）"><a href="#4-6-基于Power-Designer的数据库设计建模实践（略）" class="headerlink" title="4.6 基于Power Designer的数据库设计建模实践（略）"></a>4.6 基于Power Designer的数据库设计建模实践（略）</h1>]]></content>
      <categories>
        <category>课程笔记_数据库原理</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>数据库原理</tag>
      </tags>
  </entry>
  <entry>
    <title>视频拍摄方案</title>
    <url>/2022/04/18/%E8%A7%86%E9%A2%91%E6%8B%8D%E6%91%84%E6%96%B9%E6%A1%88/</url>
    <content><![CDATA[<h1 id="视频组成（自上而下为时间轴）"><a href="#视频组成（自上而下为时间轴）" class="headerlink" title="视频组成（自上而下为时间轴）"></a>视频组成（自上而下为时间轴）</h1><ul>
<li>场景展示</li>
<li>成员介绍</li>
<li>实操视频</li>
<li>项目细节展示</li>
</ul>
<p><strong>预期时长6-8分钟</strong><br><strong>分辨率固定为1K</strong></p>
<hr>
<h1 id="实现方案"><a href="#实现方案" class="headerlink" title="实现方案"></a>实现方案</h1><h2 id="场景展示"><a href="#场景展示" class="headerlink" title="场景展示"></a>场景展示</h2><ul>
<li>包含内容：三个场景的展示</li>
<li>拍摄方式：使用unity camera recorder录制并导出main camera画面</li>
<li>排序原因：先用视觉元素唬住评委<h2 id="成员介绍"><a href="#成员介绍" class="headerlink" title="成员介绍"></a>成员介绍</h2></li>
<li>包含内容：成员介绍（分工）</li>
<li>拍摄方式：由五个短片段组成，每个短片段5s左右，每个片段内容如下：<br><img src="../photos/Unity/VR/x_1.jpg" title="拍摄方式示意图 "><br>拍摄的时候让成员做一些操作，比如lzy的片段可以是：拖动场景内的某个物体，或者修改水面参数，然后弹出弹窗：lzy——技术美术</li>
<li>排序原因：介绍团队最好放在偏开头的地方，让评委认识你<h2 id="实操视频"><a href="#实操视频" class="headerlink" title="实操视频"></a>实操视频</h2></li>
<li>包含内容：完整的游玩过程（主场景——灯谜场景，玩一个灯谜——园林场景，刻几个字——回到主场景）</li>
<li>拍摄方式：画面主要是游戏内画面，即使用unity camera recorder录制并导出main camera画面，玩家实况以小窗形式在画面左下角，将场景切换的部分以加速方式压缩</li>
<li>需要注意的：<ul>
<li>场景切换时尽量不要动头（因为动头会露出锯齿状的画面边缘）</li>
<li>在主场景就需要将玩家移动方式（走动、传送）和大部分UI交互（按钮动态效果、制作人员名单，国赛要用）展示出来</li>
<li>刻字要慢，增强笔画连续性，刻几个字就行，展示临摹UI和介绍UI，在场景内移动时尽量不要让人看出穿模</li>
<li>灯谜只用做一个，然后让评委看到下一个灯谜的内容（在下一个灯谜只用将提示触发即可）</li>
<li>一次录完，不要分段拼凑</li>
</ul>
</li>
<li>排序原因：全视频的核心<h2 id="项目细节展示"><a href="#项目细节展示" class="headerlink" title="项目细节展示"></a>项目细节展示</h2></li>
<li>包含内容：代码截图和shader graph截图</li>
<li>拍摄方式：几秒过一张图</li>
<li>排序原因：因为是最无聊的部分，故放在最后</li>
</ul>
<hr>
<h1 id="目前问题"><a href="#目前问题" class="headerlink" title="目前问题"></a>目前问题</h1><ul>
<li>unity camera recorder功能仍需论证</li>
<li>必剪有待上手</li>
<li>考虑飞花令玩法是否加入和加入后对视频结构的影响，目前仍然需要留插入的空余</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>VR</tag>
        <tag>计设</tag>
      </tags>
  </entry>
  <entry>
    <title>测试文档</title>
    <url>/2022/02/02/%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="这是一个一级标题"><a href="#这是一个一级标题" class="headerlink" title="这是一个一级标题"></a>这是一个一级标题</h1><p>内容</p>
<h2 id="字体"><a href="#字体" class="headerlink" title="字体"></a>字体</h2><p><strong>字体加粗</strong><br><em>字体倾斜</em><br><em><strong>字体加粗倾斜</strong></em><br><del>字体加删除线</del></p>
<blockquote>
<p>这是嵌套</p>
<blockquote>
<p>这是嵌套</p>
<blockquote>
<p>这是嵌套</p>
</blockquote>
</blockquote>
</blockquote>
<h6 id="这是一个六级标题"><a href="#这是一个六级标题" class="headerlink" title="这是一个六级标题"></a>这是一个六级标题</h6><p>分割线</p>
<hr>
<h1 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h1><p>添加<del>涩图</del>测试<br><img src="../photos/hexo/1_1.jpg" title="图片标题"></p>
<hr>
<h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><p>超链接测试<br><a href="https://space.bilibili.com/13720945?spm_id_from=333.788.0.0">b站主页</a></p>
<hr>
<h1 id="代码和代码块"><a href="#代码和代码块" class="headerlink" title="代码和代码块"></a>代码和代码块</h1><p>代码</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">system.out.println(&quot;hello world!&quot;);</span><br></pre></td></tr></table></figure>
<p>代码块</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">for(i=0;i&lt;=9;i++)&#123;</span><br><span class="line">    system.out.println(&quot;当前数字是&quot;+i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h1><table>
<thead>
<tr>
<th>乘数</th>
<th align="center">乘数</th>
<th align="right">积</th>
</tr>
</thead>
<tbody><tr>
<td>2</td>
<td align="center">2</td>
<td align="right">4</td>
</tr>
<tr>
<td>3</td>
<td align="center">3</td>
<td align="right">9</td>
</tr>
<tr>
<td>1</td>
<td align="center">2</td>
<td align="right">2</td>
</tr>
</tbody></table>
<hr>
<h1 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h1><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><hr>
<h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol>
<li>列表内容</li>
<li>列表内容</li>
<li>列表内容</li>
</ol>
<hr>
<h2 id="列表嵌套"><a href="#列表嵌套" class="headerlink" title="列表嵌套"></a>列表嵌套</h2><ol>
<li>列表内容<ul>
<li>分支列表内容</li>
<li>分支列表内容<br>  +分支列表内容</li>
</ul>
</li>
<li>列表内容</li>
</ol>
<hr>
]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
        <tag>test</tag>
      </tags>
  </entry>
  <entry>
    <title>计网课程笔记1</title>
    <url>/2022/02/05/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B01/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.bilibili.com/video/BV1H3411y7q6?spm_id_from=333.999.0.0">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="1-1-计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）"><a href="#1-1-计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）" class="headerlink" title="1.1 计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）"></a>1.1 计算机网络在信息时代中的作用（略）（原课程下置顶评论内有完整课程PPT）</h1><hr>
<h1 id="1-2-计算机网络、互联网的定义与发展"><a href="#1-2-计算机网络、互联网的定义与发展" class="headerlink" title="1.2 计算机网络、互联网的定义与发展"></a>1.2 计算机网络、互联网的定义与发展</h1><h2 id="1-2-1互联网·计算机网络·互连网"><a href="#1-2-1互联网·计算机网络·互连网" class="headerlink" title="1.2.1互联网·计算机网络·互连网"></a>1.2.1互联网·计算机网络·互连网</h2><ul>
<li><strong>互联网（Internet）</strong>：覆盖全球的计算机网络，<strong>采用TCP/IP协议</strong></li>
<li><strong>计算机网络（computer network）</strong>：由若干结点和连接这些<em>结点（node）</em>的链路组成</li>
<li><strong>互连网（internet）</strong>：泛指通过路由器将各个计算机网络连接起来形成的更大的计算机网络<h3 id="关于“云”这个图形"><a href="#关于“云”这个图形" class="headerlink" title="关于“云”这个图形"></a>关于“云”这个图形</h3></li>
<li>当使用一朵云来表示网络时，可能有两种不同的情况：<ul>
<li>云表示的网络已经包含了和网络相连的计算机</li>
<li>云表示的网络里剩下许多路由器和连接这些路由器的<em>链路（link）</em>，把有关的计算机画在云的外面，将网络相连的计算机称为<em>主机（host）</em></li>
</ul>
</li>
</ul>
<h2 id="1-2-2计算机网络发展的三个阶段"><a href="#1-2-2计算机网络发展的三个阶段" class="headerlink" title="1.2.2计算机网络发展的三个阶段"></a>1.2.2计算机网络发展的三个阶段</h2><ul>
<li>第一阶段：军用网络ARPANET</li>
<li>第二阶段：三级结构互联网：主干网-地区网-园区网</li>
<li>第三阶段：<em>多层次互联网服务提供者（ISP）</em>结构互联网</li>
</ul>
<h2 id="1-2-3互联网的标准化"><a href="#1-2-3互联网的标准化" class="headerlink" title="1.2.3互联网的标准化"></a>1.2.3互联网的标准化</h2><p>**<strong>所有互联网标准都以RFC形式在互联网上发表</strong></p>
<ul>
<li><strong>互联网草案（Internet Draft）</strong>：有效期只有六个月，在这个阶段还不是RFC文档</li>
<li><strong>建议标准（Proposed Standard）</strong>：从这个阶段的开始就是RFC文档</li>
<li><strong>互联网标准 （Internet Standard）</strong>：形成正式标准后，每个标准就分配到一个编号。一个标准可以和多个RFC文档关联</li>
</ul>
<hr>
<h1 id="1-3互联网的组成"><a href="#1-3互联网的组成" class="headerlink" title="1.3互联网的组成"></a>1.3互联网的组成</h1><p>从互联网的工作方式上看，可以划分为两大块：<strong>边缘部分</strong>和<strong>核心部分</strong></p>
<ul>
<li>边缘部分：由所有连接在互联网上的主机组成，这部分是用户直接使用的，用于通信（数据传输）和资源共享</li>
<li>核心部分：由大量网络和连接这些网络的路由器组成，这部分是为边缘部分提供服务的（提供连通性和交换）</li>
</ul>
<h2 id="1-3-1互联网的边缘部分"><a href="#1-3-1互联网的边缘部分" class="headerlink" title="1.3.1互联网的边缘部分"></a>1.3.1互联网的边缘部分</h2><p>构成互联网边缘部分的主机称为<strong>端系统（end system）</strong>，端系统可以有很大的差别（功能、所有者、性能……）</p>
<h3 id="端系统间通信的含义"><a href="#端系统间通信的含义" class="headerlink" title="端系统间通信的含义"></a>端系统间通信的含义</h3><p>端系统间的通信，实际上是指运行在主机A上的某个程序 <em>（从占用计算机资源的角度划分为进程）</em>与运行在主机B上的某个程序（进程）进行通信</p>
<h3 id="端系统间的两种通信方式"><a href="#端系统间的两种通信方式" class="headerlink" title="端系统间的两种通信方式"></a>端系统间的两种通信方式</h3><p>端系统之间的通信方式通常可划分为两大类：</p>
<ul>
<li><p><strong>客户-服务器方式（C/S方式）</strong> Client/Server</p>
<ul>
<li>客户和服务器都是指通信中所涉及的两个应用进程</li>
<li>C/S方式所描述的是进程之间服务和被服务的关系</li>
<li>客户是<strong>服务的请求方</strong>，服务器是<strong>服务的提供方</strong> </li>
<li>客户软件的特点<ul>
<li>被客户调用后运行，在打算通信时主动向远地服务器发起服务请求。因此客户程序必须知道服务器程序的地址</li>
<li>不需要很特殊的硬件和很复杂的操作系统</li>
</ul>
</li>
<li>服务器软件的特点<ul>
<li>一种专门用来提供某种服务的程序，可同时处理多个远地或本地客户的请求</li>
<li>系统启动后即自动调用并一直不断地运行着，<strong>被动地</strong>等待并接受来自各地的客户的服务请求。因此，服务器程序不需要知道客户程序的地址</li>
<li>客户和服务器的通信关系建立后，通信服务是双向的，客户和服务器都可发送和接收数据</li>
<li>一般需要强大的硬件和高级的操作系统支持</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>对等方式（P2P方式）</strong> Peer to Peer（点到点/端对端）</p>
<ul>
<li>对等链接是指两个主机在通信时并不区分哪一个是服务请求方还是服务提供方</li>
<li>只要两个主机都运行了对等连接软件，就可以进行平等的、对等连接通信</li>
<li>双方都可以下载对方已经存储在硬盘内的资料</li>
</ul>
</li>
</ul>
<h3 id="接入网络"><a href="#接入网络" class="headerlink" title="接入网络"></a>接入网络</h3><ul>
<li>接入网：将端系统连接到其边缘路由器的物理链路，是用户连接到网络的基础设施</li>
<li>边缘路由器：端系统到任何其他远程端系统的路径上的<strong>第一台路由器</strong></li>
<li>将端系统连接到网络边缘路由器的粗糙分类：<ul>
<li>家庭接入网络（点对点接入）<ul>
<li>方式1：使用传统的电话线路连接本地中心局，数据通信和电话不能同时使用 <em>（拨号上网）</em></li>
<li>方式2：使用传统的电话线路连接本地中心局，数据通信和电话采用频分多路复用技术<ul>
<li>有多种传输速率</li>
<li>住宅和中心局距离不超过8——10英里</li>
<li>采用非对称数字用户线路模式（ADSL） <em>（下行需要大带宽支持，上行只需小量带宽）</em>，ASDL调制解调器始终和互联网连接，省去拨号上网、在电话线上产生三个通道 <em>（上行、下行、电话）</em>三个通道可以同时工作</li>
</ul>
</li>
<li>方式3：使用线缆调制解调器、混合光纤同轴电缆HFC<ul>
<li>通过一个以太网端口与家庭PC连接</li>
<li>光节点发送的分组经下行信道传输到每个家庭，若多个用户同时下载则会导致接收速率下降</li>
<li>每个家庭发送的分组经上行信道向光节点传输，几个用户同时发送分组将会冲突，需要多路访问协议协调</li>
</ul>
</li>
<li>方式4：使用光纤到户FTTH<ul>
<li>从本地局到每个家庭都提供一条光纤路径</li>
<li>从中心局出来的每根光纤由多个家庭共享，在临近家庭的位置通过光纤分配器给每个家庭提供一根光纤</li>
</ul>
</li>
</ul>
</li>
<li>企业/家庭接入网络、广域无线接入网络：见1.5.2</li>
</ul>
</li>
</ul>
<h2 id="1-3-2互联网的核心部分"><a href="#1-3-2互联网的核心部分" class="headerlink" title="1.3.2互联网的核心部分"></a>1.3.2互联网的核心部分</h2><ul>
<li>网络核心部分是互联网中最复杂的部分</li>
<li>网络中的核心部分要向网络边缘中的大量主机提供连通性，使得边缘部分中的任何一个主机都能够向其他主机通信</li>
<li>在网络核心部分起特殊作用的是<strong>路由器（router）</strong>，路由器是实现<strong>分组交换</strong>的关键构件，其任务是转发收到的分组，这是网络核心部分最重要的功能</li>
</ul>
<p>为了理解分组交换，首先要看电路交换</p>
<h3 id="电路交换的主要特点"><a href="#电路交换的主要特点" class="headerlink" title="电路交换的主要特点"></a>电路交换的主要特点</h3><p>如果N台电话要两两相连，那么需要N（N-1）/2对电话线，当N很大时，电话线的数量与N²近似成正比，这对不利于电话网的建设。因此当电话机的数量增多时，就要使用<strong>交换机</strong>来完成全网的交换任务。而交换机所采用的交换方式就是<strong>电路交换</strong></p>
<ul>
<li>在这里，交换的含义就是<strong>转接</strong>，将两条电话线连通起来。</li>
<li>从通信资源的分配角度来看，交换就是依照某种方式<strong>动态</strong>地分配传输线路的资源</li>
<li>电路交换的特点<ul>
<li>电路交换必定是<strong>面向连接</strong><em>（必须得接通才能连接）</em>的</li>
<li>电路交换分为三个阶段：<ul>
<li>建立连接：建立一条专用的物理通路，以保证双方通话所需的通信资源在通信时不会被其他用户占用</li>
<li>通信：双方交流信息的过程</li>
<li>释放连接： 释放占用的所有通信资源</li>
</ul>
</li>
</ul>
</li>
<li>电路交换的优点：通信稳定</li>
<li>电路交换用于计算机网络时的缺点：计算机数据具有突发性（不是一直都在传数据），导致在传送计算机数据时通信线路的利用率很低，产生资源的浪费</li>
</ul>
<h3 id="分组交换的主要特点"><a href="#分组交换的主要特点" class="headerlink" title="分组交换的主要特点"></a>分组交换的主要特点</h3><ul>
<li>分组交换采用<strong>存储转发</strong>技术</li>
<li>在发送端，先把较长的报文划分成<strong>较短的、固定长度的</strong>数据段</li>
<li>每一个数据段前面添加上<strong>首部</strong>构成<strong>分组</strong></li>
<li>分组交换传输单元（此处假定在传输过程中数据没有损失）<ul>
<li>分组交换网以<strong>分组</strong>作为数据传输单元，每一个分组的首部都含有目的地址和源地址等控制信息，分组交换网中的结点交换机根据收到的分组首部地址中的地质信息，把分组转发到下一个结点交换机</li>
<li>每个分组在互联网中<strong>独立地选择传输路径</strong></li>
<li>依次把各分组发送到接收端</li>
<li>接收端收到分组后剥去首部还原成数据，再恢复成原来的报文</li>
</ul>
</li>
<li>分组交换的优点<ul>
<li>高效：在分组传输的过程中<strong>动态分配</strong>传输带宽，对通信链路<strong>逐段占用</strong></li>
<li>灵活：为每一个分组<strong>独立</strong>地选择最合适的转发路由</li>
<li>迅速：以分组为传送单位，可以<strong>不先建立连接</strong>就能向其他主机发送分组</li>
<li>可靠：保证可靠性的网络协议；分布式多路由组成的交换网使得网络有很好的的生存性</li>
</ul>
</li>
<li>分组交换的缺点<ul>
<li>分组在各节点存储转发需要<strong>排队</strong>，造成一定的<strong>时延</strong><del>ping</del></li>
<li>分组必须携带的首部造成一定的<strong>开销</strong></li>
</ul>
</li>
</ul>
<h3 id="互联网核心的组成"><a href="#互联网核心的组成" class="headerlink" title="互联网核心的组成"></a>互联网核心的组成</h3><ul>
<li>互联网的核心部分由许多网络和将它们连接起来的路由器组成，而主机（端系统）处在互联网的边缘部分</li>
<li>互联网核心部分中的路由器之间一般都用高速链路相连接，而在网络边缘的主机接入到核心部分通常以相对较低速率的链路相连接</li>
<li>主机的用途是为用户进行信息处理，并和其它主机通过网络交换信息 <em>（发送分组，接收分组）</em> 。路由器的用途是用来转发分组，即进行分组交接，先<strong>存储</strong>收到的数据，再决定要<strong>转发</strong>到哪里</li>
</ul>
<h3 id="路由器"><a href="#路由器" class="headerlink" title="路由器"></a>路由器</h3><ul>
<li>在路由器中的输入和输出端口之间没有直接连线</li>
<li>路由器处理分组的过程是：<ul>
<li>把收到的分组先<strong>放入缓存</strong></li>
<li><strong>查找转发表</strong>，找出到某个目的地址应该从哪个端口转发</li>
<li>把分组送到适当的端口<strong>转发</strong>出去</li>
</ul>
</li>
</ul>
<h3 id="电路交换、报文交换、分组交换的不同（个人理解）"><a href="#电路交换、报文交换、分组交换的不同（个人理解）" class="headerlink" title="电路交换、报文交换、分组交换的不同（个人理解）"></a>电路交换、报文交换、分组交换的不同（个人理解）</h3><ul>
<li>电路交换需要等待连接建立后才能传递信息，有一定的时间的浪费，且发送信息期间链路均被占用，成本高</li>
<li>报文交换不需要等待连接建立，对每个链路的占用时长降低，因此成本低，但因为结点之间的传送存在次序，必须要等上一级结点传送完毕才能传给下一结点，导致用时长</li>
<li>分组交换将报文分成多个分组，压缩了传送时间且具有报文交换的优点。</li>
</ul>
<hr>
<h1 id="1-4-计算机网络在我国的发展（略）"><a href="#1-4-计算机网络在我国的发展（略）" class="headerlink" title="1.4 计算机网络在我国的发展（略）"></a>1.4 计算机网络在我国的发展（略）</h1><hr>
<h1 id="1-5-计算机网络的类别"><a href="#1-5-计算机网络的类别" class="headerlink" title="1.5 计算机网络的类别"></a>1.5 计算机网络的类别</h1><h2 id="1-5-1-计算机网络的定义（计算机网络的精确定义并未统一）"><a href="#1-5-1-计算机网络的定义（计算机网络的精确定义并未统一）" class="headerlink" title="1.5.1 计算机网络的定义（计算机网络的精确定义并未统一）"></a>1.5.1 计算机网络的定义（计算机网络的精确定义并未统一）</h2><ul>
<li>课程给出的定义：计算机网络主要是由一些通用的、可编程的硬件 <em>（表明这种硬件一定含有CPU）</em>互连而成的，而这些硬件并非专门用来实现某一特定目的。这些可编程的硬件能够用来传送多种不同类型的数据，并能支持广泛的和日益增长的应用。</li>
</ul>
<h2 id="1-5-2几种不同类别的网络"><a href="#1-5-2几种不同类别的网络" class="headerlink" title="1.5.2几种不同类别的网络"></a>1.5.2几种不同类别的网络</h2><ul>
<li>计算机网络有多种类别。类型包括：<ul>
<li><p>从网路的作用范围进行分类</p>
<ul>
<li><strong>广域网WAN</strong>：作用范围几十到几千公里</li>
<li><strong>城域网MAN</strong>；作用范围5~50公里</li>
<li><strong>局域网LAN/园区网</strong>：局限在较小范围（如1公里左右）</li>
<li><strong>个人局域网PAN</strong>：范围很小，大约在10米左右</li>
</ul>
</li>
<li><p>从网络的使用者进行分类</p>
<ul>
<li><strong>公用网</strong>：按规定缴纳费用的人都可以使用的网络</li>
<li><strong>专用网</strong>：为特殊业务工作的需要而建造的网络</li>
</ul>
</li>
<li><p>用来把用户接入到互联网的网络</p>
<ul>
<li><strong>接入网AN</strong>：又称本地接入网或居民接入网</li>
<li>接入网是一类比较特殊的计算机网络，用于将用户接入互联网。</li>
<li>接入网本身既不属于互联网的核心部分，也不属于互联网的边缘部分，由端系统到另一个端系统的路径中与第一个路由器间的物理链路所构成。从覆盖的范围看，很多接入网属于局域网，从作用上看，接入网只是起到让用户能够与互联网连接的作用。</li>
</ul>
</li>
</ul>
</li>
</ul>
<hr>
<h1 id="1-6计算机网络的性能，是什么？如何衡量？"><a href="#1-6计算机网络的性能，是什么？如何衡量？" class="headerlink" title="1.6计算机网络的性能，是什么？如何衡量？"></a>1.6计算机网络的性能，是什么？如何衡量？</h1><h2 id="1-6-1计算机网络的性能指标"><a href="#1-6-1计算机网络的性能指标" class="headerlink" title="1.6.1计算机网络的性能指标"></a>1.6.1计算机网络的性能指标</h2><ul>
<li><p>速率</p>
<ul>
<li>计算机数据量/信息量单位<strong>比特bit</strong></li>
<li>速率指的是<strong>数据的传送速率</strong>，也称为<strong>数据率</strong>或<strong>比特率</strong></li>
<li>速率的单位是<strong>bit/s</strong>,更大的单位有kbit/s,Mbit/s,Gbit/s等等。<em>需要注意的是，1kb=1024b，1kb/s=1000bit/s，其余以此类推。</em></li>
</ul>
</li>
<li><p>带宽</p>
<ul>
<li>带宽本来是指信号所具有的<strong>频带宽度</strong>，单位是Hz</li>
<li>在计算机网络中，带宽用来表示网络中某信道传送数据的能力，表示在单位时间内网络中的某通道所能通过的<strong>最高数据率</strong>，因此单位和速率一样是bit/s</li>
<li>在时间轴上信号的宽度随带宽的增大而变窄</li>
</ul>
</li>
<li><p>吞吐量</p>
<ul>
<li>吞吐量表示在单位时间内通过某个网络/通道/接口的数据量</li>
<li>吞吐量常用于对显示世界中网络的测量，以便知道有多少数据能够通过网络</li>
<li><strong>吞吐量受网络带宽/网络额定速率的限制</strong></li>
</ul>
</li>
<li><p>时延/延迟<del>ptsd犯了</del></p>
<ul>
<li>延迟是指数据从网络链路一段传送到另一端所需要的的时间</li>
<li>网络延迟由以下几个不同的部分组成：<ul>
<li><strong>发送延迟</strong> = 数据帧长度/发送速率</li>
<li><strong>传播延迟</strong>：电磁波在信道中传播一定的距离而花费的时间。<em>可知传播延迟和发送延迟有本质上的不同</em>。传播延迟==通道的物理长度/信号的传播速度</li>
<li><strong>处理延迟</strong>：主机或路由器收到分组时，为处理分组（分析首部、提取数据、差错检验、查找路由）所花费的时间 </li>
<li><strong>排队延迟</strong>：分组在路由器输入输出队列中<strong>排队等待处理所需时间</strong>，<strong>取决于网络中当时的通讯录</strong></li>
</ul>
</li>
<li>延迟=发送延迟+传播延迟+处理延迟+排队延迟</li>
</ul>
</li>
<li><p>时延带宽积</p>
<ul>
<li>链路的时延带宽积又称以比特为单位的链路长度</li>
<li><strong>时延带宽积=传播时延x带宽</strong></li>
</ul>
</li>
<li><p>往返时间RTT</p>
<ul>
<li>往返时间表示从发送方发送数据开始到发送方收到来自接收方的确认总共经历的时间</li>
<li>往返时间=各中间结点的处理延迟和排队延迟+传播延迟+发送延迟</li>
</ul>
</li>
<li><p>利用率</p>
<ul>
<li>分为<strong>信道利用率</strong>和<strong>网络利用率</strong></li>
<li>信道利用率：指出某信道有百分之几的时间是有数据通过的。</li>
<li>网络利用率：全网络的信道利用率的加权平均值</li>
<li><strong>信道利用率并非越高越好</strong>，当某信道的利用率增大时，该信道引起的<strong>时延</strong>也将<strong>急剧增加</strong>，若令D0为网络空闲时的延迟，D表示网络当前的延迟，U表示网络的利用率，则在适当的假定条件下，可以用公式<strong>D=D0/（1-U）</strong>表示D和D0的关系</li>
</ul>
</li>
</ul>
<h2 id="1-6-2计算机网络的非性能特征"><a href="#1-6-2计算机网络的非性能特征" class="headerlink" title="1.6.2计算机网络的非性能特征"></a>1.6.2计算机网络的非性能特征</h2><ul>
<li>费用</li>
<li>质量</li>
<li>标准化</li>
<li>可靠性</li>
<li>可扩展性和可升级性</li>
<li>易于管理和维护</li>
</ul>
<hr>
<h1 id="1-7计算机网络的体系结构"><a href="#1-7计算机网络的体系结构" class="headerlink" title="1.7计算机网络的体系结构"></a>1.7计算机网络的体系结构</h1><h2 id="1-7-1计算机网络体系结构的形成"><a href="#1-7-1计算机网络体系结构的形成" class="headerlink" title="1.7.1计算机网络体系结构的形成"></a>1.7.1计算机网络体系结构的形成</h2><ul>
<li>相互通讯的两个计算机系统必须高度协调工作，而这种协调是相当复杂的</li>
<li><strong>分层</strong>可将庞大而复杂的问题转化为若干较小的局部问题，化繁为简，易于处理。</li>
<li>在形成统一标准之前，各种体系结构的计算机网络之间很难相互连通，为了解决该问题，ISO于1977年提出了标准框架<strong>开放系统互连基本参考模型</strong>，简称<strong>OSI</strong>，但OSI在市场化方面失败了。</li>
<li>目前的两种国际标准(事实意义上)为<strong>TCP\IP</strong></li>
</ul>
<h2 id="1-7-2协议与划分层次"><a href="#1-7-2协议与划分层次" class="headerlink" title="1.7.2协议与划分层次"></a>1.7.2协议与划分层次</h2><ul>
<li>计算机网络中的数据交换<strong>必须遵守实现约定的规则</strong>，这些规则明确规定了所交换的数据的格式以及有关的同步问题</li>
<li><strong>网络协议</strong>是为进行网络中的数据交换而建立的规则、标准或约定</li>
<li>网络协议的三个组成要素<ul>
<li><strong>语法</strong>：报文格式/数据与控制信息的结构或格式</li>
<li><strong>语义</strong>：每个字段的含义/需要发出何种控制信息。完成何种动作以及做出何种响应</li>
<li><strong>同步</strong>：报文传输的先后次序/事件实现顺序的详细说明</li>
</ul>
</li>
<li>协议的两种形式：文字描述、程序代码</li>
<li>分层：将计算机数据的传送划分为彼此之间有联系但功能上相互独立的多个层次进行。</li>
<li>分层的好处和缺点<ul>
<li>好处<ul>
<li>各层之间相互独立</li>
<li>灵活性好</li>
<li>结构上可分割</li>
<li>易于实现和维护</li>
<li>能促进标准化工作</li>
</ul>
</li>
<li>缺点<ul>
<li>效率降低</li>
<li>有些功能会在不同的层次中重复出现，因而产生额外开销</li>
</ul>
</li>
<li>因此层数的多少要适当，层数太少会使得每一层的协议太过复杂，而层数太多，又会在描述和综合各层功能的系统工程任务时遇到较多的困难</li>
</ul>
</li>
</ul>
<h3 id="如何恰当分层？"><a href="#如何恰当分层？" class="headerlink" title="如何恰当分层？"></a>如何恰当分层？</h3><ul>
<li>各层完成的主要功能<ul>
<li>差错控制：使相应层次对等方的通信更加可靠</li>
<li>流量控制：发送端的发送速率必须使接收端来得及接收，不要太快</li>
<li>分段和重装：发送端将要发送的数据块划分为更小的单位，在接收端将其还原 </li>
<li>复用和分用：发送端几个高层会话复用一条底层的连接，在接收端再进行分用</li>
<li>连接建立和释放：交换数据前先建立一条逻辑连接，数据传送结束后再释放连接</li>
</ul>
</li>
</ul>
<h3 id="计算机网络的体系结构"><a href="#计算机网络的体系结构" class="headerlink" title="计算机网络的体系结构"></a>计算机网络的体系结构</h3><ul>
<li><strong>计算机网络的体系结构</strong>是关于网络的各层及其协议的集合</li>
<li>体系结构就是这个计算机网络及其部件<strong>所应完成的功能的精确定义</strong></li>
<li><strong>实现</strong>是遵循这种体系结构的前提下用何种硬件或软件完成这些功能的问题</li>
</ul>
<h2 id="1-7-3具有五层协议的体系结构"><a href="#1-7-3具有五层协议的体系结构" class="headerlink" title="1.7.3具有五层协议的体系结构"></a>1.7.3具有五层协议的体系结构</h2><ul>
<li>OSI的七层体系结构虽然概念清楚、理论较为完整，但它既复杂又不实用。</li>
<li>TCP/IP 是四层体系结构：应用层、运输层、网际层和网络接口层，但最下面的网络接口层并没有具体内容。</li>
<li>因此采取折中的办法，即综合OSI和TCP/IP的优点，采用一种五层协议的体系结构：<strong>应用层（对应OSI的应用层+表示层+会话层）、运输层、网络层、数据链路层、物理层</strong><h3 id="主机1向主机2通过五层协议体系结构发送数据的全过程"><a href="#主机1向主机2通过五层协议体系结构发送数据的全过程" class="headerlink" title="主机1向主机2通过五层协议体系结构发送数据的全过程"></a>主机1向主机2通过五层协议体系结构发送数据的全过程</h3></li>
<li>应用进程数据先传送到应用层，加上应用层首部，成为应用层<strong>PDU（OSI把对等层次之间传送的数据单位称为该层的协议数据单元）</strong></li>
<li>发送<ul>
<li>应用层PDU再传送到运输层，加上运输层首部成为<strong>运输层报文</strong></li>
<li>运输层报文再传送到网络层，加上网络层首部成为<strong>IP数据报/分组</strong></li>
<li>IP数据报再传送到数据链路层，加上链路层首部和尾部，成为<strong>数据链路层帧</strong></li>
<li>数据链路层帧再传送到物理层，物理层把比特流传送到物理媒体</li>
</ul>
</li>
<li>接收<ul>
<li>物理层接收到比特流，上交给数据链路层</li>
<li>数据链流层剥去帧首部和尾部，取出数据部分上交给网络层</li>
<li>网络层剥去首部，取出数据部分上交给运输层</li>
<li>运输层剥去首部，取出数据部分上交给应用层</li>
<li>应用层剥去首部，取出应用程序数据上交给应用进程，传送结束</li>
</ul>
</li>
<li>任何两个同样的层次把数据通过水平虚线 <em>（包含两个层次下面的所有部分）</em>直接传递给对方，这就是所谓的<strong>对等层</strong>之间的通信</li>
<li>各层协议实际上就是在各个对等层之间传递数据时的各项规定</li>
</ul>
<h2 id="1-7-4-实体、协议、服务和服务访问点"><a href="#1-7-4-实体、协议、服务和服务访问点" class="headerlink" title="1.7.4 实体、协议、服务和服务访问点"></a>1.7.4 实体、协议、服务和服务访问点</h2><ul>
<li><strong>实体</strong>：表示任何可发送或接收信息的硬件或软件进程</li>
<li><strong>协议</strong>：控制两个对等实体进行通信的规则的集合。在协议的控制下，两个对等实体间的通信使得本层能够向上一层提供服务。要实现本层协议，还需要使用下层所提供的服务</li>
<li>注意协议和服务的区别，<strong>协议是水平的</strong>，即协议是控制对等实体之间通信的规则，<strong>服务是垂直的</strong>，即服务是由下层向上层通过层间接口提供的。本层的服务用户只能看见服务而无法看见下面的协议。</li>
<li>协议必须把所有不利的事件事先都估计到，不能假定一切都是正常的、非常理想的。看一个计算机网络协议是否正确，不能光看在正常情况下是否正确，还必须非常仔细地检查这个协议能否应对各种异常情况</li>
</ul>
<hr>
]]></content>
      <categories>
        <category>课程笔记_计网</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>计网课程笔记2</title>
    <url>/2022/02/25/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B02/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="依照学校教学安排，第二章为应用层（即网课第六章）"><a href="#依照学校教学安排，第二章为应用层（即网课第六章）" class="headerlink" title="依照学校教学安排，第二章为应用层（即网课第六章）"></a>依照学校教学安排，第二章为应用层（即网课第六章）</h1><h1 id="应用层协议的特点"><a href="#应用层协议的特点" class="headerlink" title="应用层协议的特点"></a>应用层协议的特点</h1><p>每个应用层协议都是为了解决某一类应用问题，而问题的解决是通过位于不同主机中的多个应用之间的通信和协同工作来完成的，应用层的具体内容就是规定应用进程在通信时所遵循的协议。<br><strong>应用层的许多协议都是基于客户服务器方式</strong>，客户和服务器均为通信中所涉及的两个<strong>应用进程</strong>，客户服务器方式描述的是<strong>进程之间服务与被服务的关系</strong></p>
<h1 id="2-1-域名系统DNS"><a href="#2-1-域名系统DNS" class="headerlink" title="2.1 域名系统DNS"></a>2.1 域名系统DNS</h1><h2 id="2-1-1-什么是DNS"><a href="#2-1-1-什么是DNS" class="headerlink" title="2.1.1 什么是DNS"></a>2.1.1 什么是DNS</h2><ul>
<li><strong>域名系统</strong>：是互联网的一项服务，它是<strong>将域名和IP地址相互映射的一个分布式数据库</strong>，使人更容易地访问互联网、记忆网址</li>
<li>互联网采用层次结构的命名树作为主机的名字</li>
<li><strong>域名服务器</strong>：运行<strong>名字到IP地址的解析程序</strong>的机器，域名服务器程序在专设的结点上运行<h2 id="2-1-2-互联网的域名结构"><a href="#2-1-2-互联网的域名结构" class="headerlink" title="2.1.2 互联网的域名结构"></a>2.1.2 互联网的域名结构</h2></li>
<li>互联网采用层次树状结构的命名方法</li>
<li>任何一个连接在互联网上的主机或路由器，都有一个唯一的层次结构的名字，即<strong>域名</strong></li>
<li>域名的结构由标号序列组成，各标号之间用点隔开</li>
<li><strong>标号最长63个字符（不包含相隔的点），域名最长253个字符</strong></li>
</ul>
<p>例如：<a href="http://www.baidu.com，从左到右依次为：三级域名、二级域名、顶级域名，等级从低到高，有几段标号，www就是几级域名">www.baidu.com，从左到右依次为：三级域名、二级域名、顶级域名，等级从低到高，有几段标号，www就是几级域名</a></p>
<h3 id="顶级域名TLD"><a href="#顶级域名TLD" class="headerlink" title="顶级域名TLD"></a>顶级域名TLD</h3><ul>
<li>国家顶级域名nTLD:.cn/.us/.ru…</li>
<li>通用顶级域名gTLD:.gov（政府）/.edu（教育机构）/.org（非营利性组织）/.mil（军事部门）/.net（网络服务机构）/.int（国际组织）/.com或.biz（公司和企业）/.jobs（人力企业）/.coop（合作团体）/.aero（航空公司）/.pro（持有证书的专业人员）/.name（个人）/.museum（博物馆）…<strong>当.edu/.gov/.mil是顶级域名时，则域名均为美国专用，其他国家需要添加国家顶级域名</strong> <h2 id="2-1-3-域名服务器"><a href="#2-1-3-域名服务器" class="headerlink" title="2.1.3 域名服务器"></a>2.1.3 域名服务器</h2></li>
</ul>
<p><strong>既然域名系统是一个数据库，那么它放在哪里？</strong></p>
<ul>
<li><strong>区</strong>：一个服务器所负责管辖（或有权限的）范围</li>
<li>各单位根据具体情况来划分自己管辖范围的区，但在一个区内的所有节点必须是能够连通的</li>
<li>每一个区内所有主机的域名到IP地址的映射均存放在该区的<strong>权限域名服务器</strong>内</li>
<li>DNS服务器的管辖范围不以“域”为单位，而是以“区”为单位</li>
<li>找到域名对应的IP地址首先要找到<strong>根域名服务器</strong>，然后找其下的<strong>顶级域名服务器</strong>逐级往下直到找到域名</li>
<li><strong>根域名服务器共有13套装置，不是13个机器</strong>，这些装置对应的域名为从a.rootservers.net到m.rootservers.net，其中一套为<strong>主根服务器</strong>，其余12套为<strong>辅根服务器</strong>，截止到2016年2月，全世界已经在588个地点安装了根域名服务器 （有1000台以上的服务器）<em>（为了让世界上大部分DNS域名服务器都能就近找到一个域名服务器）</em>，所以<strong>根域名服务器不是13个机器，一套装置就是一个根服务器集群</strong>，访问根服务器的域名需要32个字节</li>
<li><strong>在IPV4下，为了在大多数的网络上进行传输，一个DNS数据包的大小规定小于等于512个字节</strong>，传输时在这个数据包的基础上还要加上8个字节大小的UDP头部，20个字节大小的IP，一定字节大小的数据链路层头部等等</li>
<li><strong>为什么根域名服务器只有13个</strong>:存放一个根域名服务器的域名需要32字节，而一个DNS数据包的大小规定小于等于512个字节，其中包含了13台根服务器的域名共416字节，为了省出足够空间存放其他参数，因此目前只有13台根服务器</li>
<li>根域名服务器不直接把域名转换成IP地址，在使用迭代查询时，根域名服务器把下一步应当找的顶级域名服务器的IP地址告诉本地域名服务器</li>
<li><strong>顶级域名服务器</strong>：负责管理在该顶级域名服务器注册的所有二级域名，当收到DNS查询请求时，就给出相应的回答 <em>（可能是最后的结果，也可能是下一步应当找的域名服务器的IP地址）</em></li>
<li><strong>分区域名服务器</strong>：负责一个区的域名服务器，当一个权限域名服务器还不能给出最后的查询回答时，就会告诉发出查询请求的DNS客户下一步应当找哪一个权限域名服务器</li>
<li><strong>本地域名服务器</strong>：当一个主机发出DNS查询请求时，这个查询请求报文就将发送给本地域名服务器，每一个互联网服务提供者ISP都可以拥有一个本地域名服务器，这种域名服务器也称为<strong>默认域名服务器</strong></li>
<li><strong>本地域名服务器采用迭代查询</strong>：当一个主机发出DNS查询请求时，这个请求将最先送到本地域名服务器，<strong>如果这个域名和对应的IP在服务器内没有存储或IP已经过期</strong>则本地域名服务器首先询问根域名服务器，获得顶级域名服务器IP，本地域名服务器再根据得到的IP询问顶级域名服务器，获得权限域名服务器IP，再根据得到的IP逐级向下询问次级权限域名服务器，直到获得完整的IP，本地域名服务器将域名和IP进行存储，最后将IP传给主机，完成查询。<strong>如果这个域名和对应的IP在服务器内存在或有效</strong>则本地域名服务器将存储的IP发送给主机，结束查询。</li>
<li><strong>本地域名服务器采用递归查询（少用）</strong>：<strong>如果这个域名和对应的IP在服务器内没有存储或IP已经过期</strong>，则本地域名服务器首先询问根域名服务器，根域名服务器再询问顶级域名服务器，顶级域名服务器再询问权限域名服务器，权限域名服务器逐级向下询问直到所有标号序列均查询完毕，询问顺序中最后一个权限域名服务器将完整的IP逐级返回到上一级域名服务器，根域名服务器将IP返回给本地域名服务器，本地域名服务器将域名和IP进行存储，最后将IP传给主机，完成查询。<strong>如果这个域名和对应的IP在服务器内存在或有效</strong>则本地域名服务器将存储的IP发送给主机，结束查询。由于根服务器是公共资源，我们希望根服务器的资源利用最大化，因此查询常常只发生在主机和本地域名服务器之间。</li>
<li>名字的高速缓存：<strong>每个域名服务器都维护一个高速缓存</strong>，存放最近用过的名字以及从何处获得名字映射信息的记录，这么做可以大大减轻根域名服务器的负荷，使互联网上的DNS查询请求和回答报文的数量大为减少。为了保持高速缓存中的内容正确，域名服务器应该为每项内容设置计时器，并处理超过合理时间的项。<strong>当权限域名服务器回答一个查询请求时，在响应中都指明绑定有效存在的时间值，增加此时间值可以减少网络开销，减少此时间值可以提高域名转换的准确性</strong></li>
</ul>
<hr>
<h1 id="2-2-文件传送协议"><a href="#2-2-文件传送协议" class="headerlink" title="2.2 文件传送协议"></a>2.2 文件传送协议</h1><h2 id="2-2-1-文件传送协议-File-Transfer-Protocol-FTP-概述"><a href="#2-2-1-文件传送协议-File-Transfer-Protocol-FTP-概述" class="headerlink" title="2.2.1 文件传送协议(File Transfer Protocol,FTP)概述"></a>2.2.1 文件传送协议(File Transfer Protocol,FTP)概述</h2><ul>
<li>FTP是互联网上使用最广泛的文件传送协议，有两种传输方式：<strong>ASCII传输</strong>和<strong>bit传输</strong></li>
<li>FTP提供交互式的访问，允许客户指明文件的类型和格式，并允许文件具有存取权限</li>
<li>FTP屏蔽了各计算机系统的细节，因而适用于在异构网络中任意计算机之间传送文件</li>
<li>RFC959很早就成为了互联网的正式标准</li>
</ul>
<h2 id="2-2-2-FTP的基本工作原理"><a href="#2-2-2-FTP的基本工作原理" class="headerlink" title="2.2.2 FTP的基本工作原理"></a>2.2.2 FTP的基本工作原理</h2><ul>
<li>文件传送协议FTP只借助TCP可靠的运输服务提供文件传送的一些基本服务</li>
<li>FTP的主要功能是减少或消除在不同操作系统下处理文件的不兼容性</li>
<li>FTP使用<strong>客户-服务器</strong>工作方式，一个FTP服务器进程可同时为多个客户进程提供服务。FTP的服务器进程由<strong>一个主进程和若干个从属进程两大部分</strong>组成，主进程负责接受新的请求，从属进程负责处理单个请求</li>
</ul>
<h3 id="主进程的工作步骤"><a href="#主进程的工作步骤" class="headerlink" title="主进程的工作步骤"></a>主进程的工作步骤</h3><ul>
<li>打开熟知端口（端口号为21），使客户进程能够连接上</li>
<li>等待客户进程发出连接请求</li>
<li>启动从属进程来处理客户进程发来的请求，从属进程对客户进程的请求处理完毕后即终止，但从属进程在运行期间根据需要还可能创建其它一些子进程</li>
<li>回到等待状态，继续接受其他客户进程发来的请求，主进程与从属进程的处理是<strong>并发</strong>地进行</li>
</ul>
<h3 id="控制连接和数据连接"><a href="#控制连接和数据连接" class="headerlink" title="控制连接和数据连接"></a>控制连接和数据连接</h3><ul>
<li>控制连接在整个会话期间一直保持打开，FTP客户发出的传送请求通过控制连接发送给服务器端的控制进程，但控制连接不用来传送文件</li>
<li>连接建立后，通过20号端口来进行数据连接（21号端口仍然打开），用于传输文件。服务器端的控制进程在接收到FTP客户发送来的文件传输请求后就创建<strong>数据传送进程</strong>和<strong>数据连接</strong>，用来连接客户端和服务器端的数据传送进程</li>
<li>数据传送进程实际完成文件的传送，在传送完毕后关闭数据传送连接并结束运行</li>
<li>当客户进程向服务器进程发出建立连接请求时，要寻找连接服务器进程的<strong>熟知端口（21）</strong>，同时还要高速服务器进程自己的另一个端口号码用于数据传送连接，之后服务器用自己传送数据的<strong>熟知端口（20）</strong>与客户进程所提供的端口号码建立数据传送连接</li>
<li>使用两个不同端口号的好处<ul>
<li>使协议更加简单和更容易实现</li>
<li>在传输文件时还可以利用控制连接来控制传输文件进程。</li>
</ul>
</li>
</ul>
<h3 id="网络文件系统-Network-File-System，NFS-的思路"><a href="#网络文件系统-Network-File-System，NFS-的思路" class="headerlink" title="网络文件系统(Network File System，NFS)的思路"></a>网络文件系统(Network File System，NFS)的思路</h3><ul>
<li>NFS允许应用进程打开一个远地文件，并能在该文件的某一个特定的位置上开始读写数据</li>
<li>NFS可使用户只复制一个大文件中的一个很小的片段，而不需要复制整个大文件，NFS软件把需要添加的数据和写数据请求一起发送到远地计算机的NFS服务器，NFS服务器更新文件后返回应答信息 <em>（比如git bash）</em></li>
<li><strong>NFS在网络上传送的只是少量的修改数据</strong></li>
</ul>
<h2 id="2-2-3-简单文件传送协议-Trival-File-Transfer-Protocal-TFTP"><a href="#2-2-3-简单文件传送协议-Trival-File-Transfer-Protocal-TFTP" class="headerlink" title="2.2.3 简单文件传送协议(Trival File Transfer Protocal,TFTP)"></a>2.2.3 简单文件传送协议(Trival File Transfer Protocal,TFTP)</h2><ul>
<li>TFTP是一个很小且易于实现的文件传送协议</li>
<li>TFTP使用客户服务器方式和使用UDP <em>（无连接运输）</em>数据报，因此TFTP需要有自己的差错改正措施</li>
<li>TFTP<strong>只支持文件传输</strong>而不支持交互</li>
<li>TFTP没有一个庞大的命令集，没有列目录的功能，也不能对用户进行身份鉴别</li>
</ul>
<hr>
<h1 id="2-3-远程终端协议TELNET（课程略）"><a href="#2-3-远程终端协议TELNET（课程略）" class="headerlink" title="2.3 远程终端协议TELNET（课程略）"></a>2.3 远程终端协议TELNET（课程略）</h1><hr>
<h1 id="2-4-万维网WWW"><a href="#2-4-万维网WWW" class="headerlink" title="2.4 万维网WWW"></a>2.4 万维网WWW</h1><hr>
<h1 id="2-5-电子邮件"><a href="#2-5-电子邮件" class="headerlink" title="2.5 电子邮件"></a>2.5 电子邮件</h1><h2 id="2-5-1电子邮件概述"><a href="#2-5-1电子邮件概述" class="headerlink" title="2.5.1电子邮件概述"></a>2.5.1电子邮件概述</h2><ul>
<li>电子邮件的传送方式是将邮件发送到收件人使用的邮件服务器并放在其中的收件人邮箱中，收件人可随时上网到自己使用的邮件服务器进行读取，是一种<strong>非即时</strong>的通信方式。</li>
<li>电子邮件具有<strong>方便、传递迅速、费用低廉的优点</strong></li>
<li>电子邮件的标准：<strong>发送邮件SMTP</strong>、<strong>读取邮件POP3和IMAP</strong>、<strong>同时传送多种类型数据MIME</strong></li>
<li>电子邮件的传送过程:发件人以SMTP标准借助TCP可靠的运输服务向发送方邮件服务器的25号端口传送邮件，发送方邮件服务器以SMTP标准借助TCP向接收方邮件服务器发送邮件，接收方邮件服务器以POP3/IMAP标准读取邮件，收件人以POP3/IMAP标准从接收方邮件服务器读取邮件 <strong>（POP3服务器和POP3客户之间的通信是由POP3客户发起的）</strong><br><img src="../photos/ComputerNetworkCourse/2_1.png" title="电子邮件发送-接收示意图"></li>
<li>用户代理(User Agent,UA)：用户与电子邮件系统的接口，是电子邮件客户端软件，功能是<strong>撰写、显示、处理和通信</strong>，邮件服务器的功能是发送和接收邮件，同时还要向发信人报告邮件传送的情况</li>
<li>TCP/IP体系的电子邮件系统规定电子邮件地址的格式：收件人邮箱名@邮箱所在主机的域名</li>
</ul>
<h2 id="2-5-2简单邮件传送协议SMTP"><a href="#2-5-2简单邮件传送协议SMTP" class="headerlink" title="2.5.2简单邮件传送协议SMTP"></a>2.5.2简单邮件传送协议SMTP</h2><ul>
<li>SMTP所规定的就是在两个相互通信的SMTP进程之间如何交换信息</li>
<li>由于SMTP使用<strong>客户-服务器</strong>工作方式，因此负责发送邮件的SMTP进程就是SMTP客户，而负责接收邮件的SMTP进程就是SMTP服务器</li>
<li><strong>SMTP通信的3个阶段</strong>：<strong>连接建立——邮件传送——连接释放</strong>（在发送主机的SMTP客户和负责接收的SMTP服务器之间建立连接，邮件发送完毕后，SMTP应释放TCP连接）<strong>SMTP不使用中间的邮件服务器</strong></li>
<li>缺陷：不能传送可执行文件或其他的二进制对象，仅限于传送7位的ASCII码，这意味着许多非英语国家的文字无法传送，SMTP服务器会拒收超过一定长度的邮件</li>
</ul>
<h2 id="2-5-3电子邮件的信息格式"><a href="#2-5-3电子邮件的信息格式" class="headerlink" title="2.5.3电子邮件的信息格式"></a>2.5.3电子邮件的信息格式</h2><ul>
<li>电子邮件的组成：<strong>信封和内容</strong></li>
<li>RFC822只规定了邮件内容中的首部格式，而对邮件的主体部分则让用户自由撰写，用户写好首部后，邮件系统将自动将信封所需的信息提取出来并写在信封上，无需用户填写，邮件内容首部包括一些关键字，后面加上冒号，最重要的关键字是<strong>To（后面填入收件人的电子邮件地址）、Subject（邮件的主题，便于用户查找）、Cc（表示应给某人发送一个邮件副本）、From和Date（分别表示发件人的电子邮件地址和发件日期）、Reply-To（对方回信所用的地址）</strong></li>
</ul>
<h2 id="2-5-4邮件读取协议POP3和IMAP4"><a href="#2-5-4邮件读取协议POP3和IMAP4" class="headerlink" title="2.5.4邮件读取协议POP3和IMAP4"></a>2.5.4邮件读取协议POP3和IMAP4</h2><ul>
<li>邮局协议POP是一个非常简单但功能有限的邮件读取协议，POP3是它的第三个版本，也是当前使用的版本。</li>
<li>POP也使用<strong>客户-服务器</strong>的工作方式，在接收邮件的用户PC机中必须运行POP客户程序，而在用户所连接的互联网服务提供商(Internet Service Provider,ISP)的邮件服务器中运行POP服务器程序</li>
<li>交互邮件访问协议IMAP也使用<strong>客户-服务器</strong>的工作方式，IMAP4是它的第四个版本，也是当前使用的版本。</li>
<li>用户在自己的PC机上就可以操纵ISP的邮件服务器的邮箱，就像在本地操纵一样</li>
<li><strong>IMAP是一个联机协议</strong>，当用户PC机上的IMAP客户程序打开IMAP服务器的邮箱时，用户就可看到邮件的首部，若用户需要打开某个邮件，则邮件才传到用户的PC机上</li>
<li>IMAP的优势<ul>
<li>用户可以在不同的地方使用不同的计算机随时上网阅读和处理的自己的邮件</li>
<li>IMAP允许收件人只读取邮件中的某一个部分</li>
</ul>
</li>
<li>IMAP的缺点：如果用户没有将邮件复制到自己的PC上，则邮件一直是存放在IMAP服务器上，因此用户需要经常与IMAP服务器建立连接</li>
</ul>
<h2 id="2-5-5基于万维网的电子邮件"><a href="#2-5-5基于万维网的电子邮件" class="headerlink" title="2.5.5基于万维网的电子邮件"></a>2.5.5基于万维网的电子邮件</h2><ul>
<li>发件方使用<strong>HTTP协议</strong>将邮件发送到邮件服务器，两个服务器之间的传送使用SMTP协议，邮件从服务器传到收件方是使用HTTP协议</li>
<li>万维网电子邮件的优势：只要能够找到可以上网的PC机，打开任何一种浏览器都可以方便地<strong>收发</strong>电子邮件，是一种“B-S”的方式（浏览器-服务器），而上述所提到的SMTP\POP3\IMAP都是“C-S”的方式（客户-服务器）</li>
</ul>
<h2 id="2-5-6通用互联网邮件扩充MIME"><a href="#2-5-6通用互联网邮件扩充MIME" class="headerlink" title="2.5.6通用互联网邮件扩充MIME"></a>2.5.6通用互联网邮件扩充MIME</h2><ul>
<li>由于SMTP能够传送的文件格式有限，因此MIME继续使用RFC822格式的同时增加了<strong>邮件主体的结构</strong>，定义了<strong>传送非ASCII码的编码规则</strong>，但<strong>MIME并没有改动SMTP或取代它</strong></li>
<li>MIME和SMTP的关系：邮件（非ASCII码）先通过MIME转换成7位ASCII码，再使用SMTP传输，然后通过MIME转回非ASCII码交给用户<br><img src="../photos/ComputerNetworkCourse/2_2.png" title="MIME和SMTP关系示意图"></li>
<li>MIME的三个主要部分<ul>
<li>首部字段：添加了5个新的首部字段，它们可包含在RFC822首部中，这些字段提供了有关邮件主体的信息</li>
<li>格式：定义了许多邮件内容的格式，对多媒体电子邮件的表示方法进行了标准化</li>
<li>传送编码：定义了新的传送编码，可对任何内容格式进行转换，而不会被邮件系统改变</li>
</ul>
</li>
</ul>
<hr>
<h1 id="2-6-动态主机配置协议DHCP（课程略）"><a href="#2-6-动态主机配置协议DHCP（课程略）" class="headerlink" title="2.6 动态主机配置协议DHCP（课程略）"></a>2.6 动态主机配置协议DHCP（课程略）</h1><h1 id="2-7-简单网络管理协议SNMP（课程略）"><a href="#2-7-简单网络管理协议SNMP（课程略）" class="headerlink" title="2.7 简单网络管理协议SNMP（课程略）"></a>2.7 简单网络管理协议SNMP（课程略）</h1><hr>
<h1 id="2-8-应用进程跨越网络的通信"><a href="#2-8-应用进程跨越网络的通信" class="headerlink" title="2.8 应用进程跨越网络的通信"></a>2.8 应用进程跨越网络的通信</h1><h2 id="2-8-1系统调用和应用编程接口"><a href="#2-8-1系统调用和应用编程接口" class="headerlink" title="2.8.1系统调用和应用编程接口"></a>2.8.1系统调用和应用编程接口</h2><ul>
<li>大多数操作系统使用系统调用的机制在应用程序和操作系统间传递控制权</li>
<li>系统调用和程序中的函数调用较为相似，只是系统调用是将控制权传递给操作系统，而函数调用的控制权是在调用函数的那部分代码 </li>
</ul>
<h2 id="2-8-2几种常用的系统调用"><a href="#2-8-2几种常用的系统调用" class="headerlink" title="2.8.2几种常用的系统调用"></a>2.8.2几种常用的系统调用</h2><ul>
<li>应用编程接口API——应用进程和操作系统控制权进行转换的接口：当某个应用进程启动系统调用时，控制权就从应用进程传递给了系统调用接口，此接口再将控制权传递给计算机的操作系统，操作系统将此调用转给某个内部进程，并执行所请求的操作，内部过程一旦执行完毕，控制权又通过系统调用接口返回给应用进程<ul>
<li>套接字接口</li>
<li>Windows Socket：采用套接字接口但稍有不同</li>
<li>TLI，为UNIX系统定义的一种API</li>
</ul>
</li>
<li><strong>套接字 <em>（IP地址+端口）</em>的作用**：当应用进程需要使用网络进行通信的时候就发出系统调用，请求操作系统为其创建套接字，以便把网络通信所需要的系统资源分配给该应用进程，操作系统为这些资源的综合用一个叫做</strong>套接字描述符**的号码来表示，并把此号码返回给应用进程，应用进程所进行的网络操作都必须使用这个号码。通信完毕后，应用进程通过一个关闭套接字的系统调用通知操作系统回收与该号码相关的所有资源</li>
</ul>
<hr>
<h1 id="2-9-P2P应用"><a href="#2-9-P2P应用" class="headerlink" title="2.9 P2P应用"></a>2.9 P2P应用</h1><h2 id="2-9-0P2P工作方式概述"><a href="#2-9-0P2P工作方式概述" class="headerlink" title="2.9.0P2P工作方式概述"></a>2.9.0P2P工作方式概述</h2><ul>
<li>P2P出现的背景：自从互联网能够提供音频、视频服务后，宽带上网用户数量急剧增长，很多用户使用宽带接入的目的就是更快地下载音频视频文件</li>
<li>P2P工作方式：所有的音频、视频文件都是在普通的互联网用户之间传输，<strong>每个客户也可以是服务器</strong>，在P2P工作方式下，相当于有很多分散在各地的媒体服务器提供下载服务</li>
<li>在互联网流量中，P2P工作方式下的文件分发已占据最大的份额，比万维网应用所占的比例要大得多</li>
<li>优点：用户不必访问集中式服务器，缓解了集中式媒体服务器可能出现的瓶颈问题，多个用户拥有相同资源使得可以获得的资源来源更多，获取资源更为方便、快捷<h2 id="2-9-1具有集中目录服务器的P2P工作方式"><a href="#2-9-1具有集中目录服务器的P2P工作方式" class="headerlink" title="2.9.1具有集中目录服务器的P2P工作方式"></a>2.9.1具有集中目录服务器的P2P工作方式</h2></li>
<li>Napster<ul>
<li>是最早出现的P2P技术，用于提供MP3音乐的免费下载</li>
<li>Napster能够搜索音乐文件，所有的音乐<strong>文件地址</strong>击中存放在一个Napster目录服务器中，便于用户下载</li>
<li>用户要及时向Napster的目录服务器报告自己存有的音乐文件，当用户需要下载时，就向服务器发出询问，服务器根据检索结果返回地址，Napster<strong>文件传输是分散的，但文件的定位是集中的</strong></li>
<li>缺点：可靠性差（需要目录服务器）、侵犯版权</li>
</ul>
</li>
</ul>
<h2 id="2-9-2具有全分布式结构的P2P文件共享程序"><a href="#2-9-2具有全分布式结构的P2P文件共享程序" class="headerlink" title="2.9.2具有全分布式结构的P2P文件共享程序"></a>2.9.2具有全分布式结构的P2P文件共享程序</h2><ul>
<li>电驴eMule<ul>
<li>电驴使用<strong>分散定位和分散传输技术</strong>，把每一个文件划分为许多小文件块，使用<strong>多源文件传输协议MFTP</strong>进行传送。因此用户可以同时从很多地方<strong>并行下载一个文件中的不同文件块</strong>，这么做使得下载可以较快完成</li>
<li>电驴用户在下载文件的同时也在上传文件</li>
</ul>
</li>
<li>比特洪流BT**<del>种子！</del><strong>：BitTorrent所有对等方集合称为一个</strong>洪流<strong>，下载文件的数据单元为</strong>长度固定的文件块<strong>，基础设施节点则叫做</strong>追踪器**，用于获得对等方列表</li>
</ul>
<h2 id="2-9-3P2P文件分发的分析"><a href="#2-9-3P2P文件分发的分析" class="headerlink" title="2.9.3P2P文件分发的分析"></a>2.9.3P2P文件分发的分析</h2><ul>
<li>使用P2P方式下载文件会<strong>同时占用下载和上传带宽</strong></li>
<li>C/S方式下分发的最短时间<ul>
<li>从服务器端考虑，有N台主机从服务器下载一个大文件，所有主机分发完毕的最短时间T不可能小于NF/u（？为啥），其中F为文件大小，单位为bit；上传速率和下载速率分别为u和d，单位为bit/s</li>
<li>若下载速率最慢的主机的下载速率为dmin，则T不可能小于F/dmin</li>
<li>综上可知所有主机都下载完文件F的最少时间为T=max（NF/u，F/dmin）</li>
</ul>
</li>
</ul>
<h2 id="2-9-4在P2P对等方式中搜索对象"><a href="#2-9-4在P2P对等方式中搜索对象" class="headerlink" title="2.9.4在P2P对等方式中搜索对象"></a>2.9.4在P2P对等方式中搜索对象</h2><ul>
<li>现在广泛使用的索引和查找技术叫做<strong>分布式散列表DHT</strong>，也可译为<strong>分布式哈希表</strong>，它是由大量对等方共同维护的散列表</li>
<li>分布式散列表DHT利用散列函数，把资源名K及其存放的结点IP地址N都分别映射为资源名标识符KID和节点标识符NID</li>
<li>chord算法把结点按标识符数值从小到大沿顺时针排列成一个环形覆盖网络</li>
</ul>
<hr>
<h2 id="2-10补充"><a href="#2-10补充" class="headerlink" title="2.10补充"></a>2.10补充</h2>]]></content>
      <categories>
        <category>课程笔记_计网</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>论文翻译1_粒子系统</title>
    <url>/2022/03/24/%E8%AE%BA%E6%96%87%E7%BF%BB%E8%AF%911/</url>
    <content><![CDATA[<h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p><strong>原文作者：William T.Reeves, Lucasfilm.Ltd</strong><br><strong>原文题目：Particle Systems-A Technique for Modeling a Class of Fuzzy Objects</strong>(Computer Graphics, Volume 17, Number 3, July 1983)<br><strong>翻译仅供个人学习，勿做他用</strong><br><strong>部分地方为了语义通顺，在尊重原文意思的同时使用了意译</strong><br><strong>翻译限于个人水平，敬请见谅</strong></p>
<hr>
<h1 id="1-引言"><a href="#1-引言" class="headerlink" title="1 引言"></a>1 引言</h1><ul>
<li>  当下的计算机图像合成技术对诸如云、雾、水和火等自然事物进行建模已经被证明是困难的。这些“模糊”的物体并没有平滑、界限清晰、闪闪发亮的表面，而是拥有不平整、复杂、界限模糊的表面。我们对这些事物形体的动态、流动变化深感兴趣。它们的动作既不一成不变也不能被计算机图像中的常见简单仿射变换所描绘。</li>
<li>  本文提供了一种对模糊物体的建模方法，称为“粒子系统”。粒子系统在图像合成方面与一般使用的呈现方式有三个基本的不同点。第一， 物体并不由一系列基本的面元素如多面形或色块所呈现，且它的边界也不为这些元素所定义，而是借助基本粒子组成的云团来定义它的体积；第二，粒子系统并不是确切的实体，它的粒子随着时间的变化而改变外观，粒子新旧更替。第三，由粒子系统所呈现的物体的外形并不被明确规定，因此其不具确定性。此外，随机处理被用于生成和改变物体的外观。</li>
<li>  在模糊物体的建模过程中，相较于传统以面为导向的技术，粒子系统方法有几个重要的优势。首先，粒子（目前将其想象为三维空间的一个点）是比多边形更加原始和简易的，是表面呈现方式中最为简化的。因此，在相同的计算时间内采用粒子系统可以处理更多的基元并产生更加复杂的图像。由于粒子是简易的，所以它也易于运动模糊。时态混叠效应下快速运动的物体导致的运动模糊现象在计算机图像合成中已经被长久地忽视了；第二个优势是模型定义是程序性的，并且由随机数控制。因此，相比于通常使用现有的基于表面的系统，使用粒子系统获得一个十分精细的模型并不一定需要人们长时间设计。由于它是程序性的，所以粒子系统可以调整其细节级别以适应特定的一组查看参数。使用分形曲面，使用粒子系统放大可以显示越来越多的细节；第三，使用粒子系统建模的物体是“活的”，也就是说，它们会在一段时间内改变外观。而这种复杂的动力学形式使用基于曲面的建模技术则难以实现。</li>
<li>  建模时将物体做成粒子的集合并非新想法。十五年前，最早的电脑磁带游戏将太空飞船的爆炸描绘成充满屏幕的许多光点。尽管在文献中很少提及它们，但在许多三维建模系统中，点源被用作图形数据类型。俄亥俄州的Roger Wilson使用粒子来建模从烟囱中冒出的烟雾。在他的模型中既没有随机控制，也没有动力学。Alvy Ray Smith和Jim Blinn在他们的系列节目《宇宙》（Cosmos）中使用粒子来给恒星消亡建模。Alan Norton使用粒子生成和显示三维分形形状。Jim Blinn讨论过模拟光通过和被粒子层反射的光反射函数。他的技术被用于生成土星环的图片。Blinn并没有解决模糊物体的建模问题，这也是他论文的主题。体积表示法也被认为是曲面表示的可行替代方案。实体建模是体积表示的一种，就如Norm Badler和Joe O’Rourke的《泡泡人》（Bubble-man）的一样。在分形建模中，随机建模的使用将我们的工作和最新的进展联系起来。</li>
<li>  第二部分更加详尽地描述了粒子系统的基本框架。第三部分研究了在《星际迷航2：可汗之怒》中粒子系统是怎样用于在“创世纪演示”中生成火，第四部分展现了粒子系统的另外几个应用，第五部分讨论了该领域未来的进一步研究。</li>
</ul>
<hr>
<h1 id="2-粒子系统的基本模型"><a href="#2-粒子系统的基本模型" class="headerlink" title="2 粒子系统的基本模型"></a>2 粒子系统的基本模型</h1><ul>
<li>  粒子系统是许多微小粒子的集合，它们共同表示一个模糊的物体。在一段时间内，许多粒子将被生成为一个系统、在这个系统内移动和改变外观，最后随着这个系统销毁。</li>
<li>  为了在动态演示中计算每一帧，需要进行以下步骤：(1)新粒子被生成到系统内，（2）每个粒子都被分配独立的属性，（3）系统中任何存在时间超过预定寿命的粒子都会被销毁，（4）剩余的粒子根据它们的动力学属性被移动和转化，（5）最后在帧缓存器中渲染活动粒子的图像。粒子系统可通过编程被设定为在每一步执行任何一组指令。由于它是程序性的，所以这种方法可以结合任何描述物体外观或动力学的计算模型。举个例子，粒子的运动和变换能够与一组偏微分方程的解联系在一起，或者粒子的属性能够基于统计力学被分配。因此，我们能利用那些已经在其它科学或工程学科中被开发的模型。</li>
<li>  在本文的研究中，我们是用简易的随机过程作为帧生成的每个步骤的程序性要素。为了在粒子系统中控制粒子的形状、外观和动力学特性，模型设计者需要用到一组参数。一般来说，每组参数表明了粒子属性值的范围。我们通常使用平均值和最大方差来指定这些范围。</li>
<li>  后续小节更加详尽地描述了粒子系统的基本模型和在我们编写的软件中这些粒子是如何被控制和规定的。</li>
</ul>
<h2 id="2-1-粒子生成"><a href="#2-1-粒子生成" class="headerlink" title="2.1 粒子生成"></a>2.1 粒子生成</h2><ul>
<li>  粒子在系统中以受控随机过程生成。该过程确定在每个时间间隔（给定帧）内进入系统的粒子数。生成的粒子数目很重要，因为它强烈影响模糊物体的密度。</li>
<li>  模型设计者可以在下面两种方法中选择一种来控制新粒子的数目。第一种方法是，设计者控制每帧内生成的粒子的平均数量及其方差。在帧f上生成的实际粒子数为：<center>NParts<sub>f</sub> = MeanParts<sub>f</sub> + Rand( ) × VarParts<sub>f</sub>，</center>
其中Rand是一个程序过程，它返回一个在-1.0和+1.0之间概率均匀分布的随机数，MeanParts<sub>f</sub>是粒子数量的平均数，VarParts<sub>f</sub>是粒子数量的方差。</li>
<li>  第二种方法是新粒子的数量取决于物体在屏幕上的大小。模型设计者控制每个屏幕单位面积内生成粒子的平均数及其方差。程序化粒子系统可以决定每一个特定帧的视图参数，计算其覆盖的大致区域，并相应地设定新粒子的数量。对应的方程为：<center>NParts<sub>f</sub> = (MeanParts<sub>sa<sub>f</sub></sub> + Rand( ) × VarParts<sub>sa<sub>f</sub></sub>) x ScreenArea，</center>
其中MeanParts<sub>sa</sub>是每单位屏幕面积粒子数的平均值，MeanParts<sub>sa<sub>f</sub></sub>是其方差，ScreenArea则是粒子系统在屏幕上所占的面积。这个方法
控制了粒子系统细节的级别，从而控制渲染其图像所需的时间。举个例子，我们没必要在屏幕上4个像素大小的区域生成100000个粒子。</li>
<li>  为了使粒子系统能够在密度上增减，设计者可以随时间去改变每帧生成的粒子的平均数量（即，MeanParts<sub>f</sub>和MeanParts<sub>sa<sub>f</sub></sub>是如上所述的帧数函数）。目前，我们使用一个简单的线性函数：<center>MeanParts<sub>f</sub> = InitialMeanParts + DeltaMeanParts<sub>sa<sub>f</sub></sub> x (f - f<sub>0</sub>) </center>
或
<center>MeanParts<sub>sa<sub>f</sub></sub>= InitialMeanParts<sub>sa</sub> + DeltaMeanParts<sub>sa</sub> x ( f - f<sub>0</sub>), </center>
其中f是当前帧，f<sub>0</sub>是粒子系统处于活动状态的第一帧，InitialMeanParts<sub>sa</sub>表示该第一帧的粒子平均数，VarParts<sub>sa<sub>f</sub></sub>表示其变化率，方差约束量VarParts<sub>sa<sub>f</sub></sub>和VarParts<sub>f</sub>目前在所有帧上都是常量。更复杂的二次型、三次型甚至随机变化在均值和方差参数中都很容易添加。</li>
<li>  为了控制粒子系统中的粒子生成，设计者指定f<sub>0</sub>和参数InitialMeanParts、DeltaMeanParts和VarParts，或和参数InitialMeanParts<sub>sa</sub>、DeltaMeanParts<sub>sa</sub>和VarParts<sub>sa</sub>。</li>
</ul>
<h2 id="2-2-粒子属性"><a href="#2-2-粒子属性" class="headerlink" title="2.2 粒子属性"></a>2.2 粒子属性</h2><ul>
<li>  对于每个被生成的新粒子，粒子系统必须指定其以下属性值：</li>
<li>初始位置</li>
<li>初始速度（包含速率和方向）</li>
<li>初始大小</li>
<li>初始颜色</li>
<li>初始透明度</li>
<li>形状</li>
<li>寿命</li>
<li>  粒子系统的几个参数控制着粒子的初始位置。粒子系统在三维空间内有一个用于定义原点的位置，通过原点绕坐标系旋转的两个角度得出其方向 <em>（球坐标系）</em>。粒子系统也有一个 <em>生成形状</em>，它定义了一个关于其原点的区域，新产生的粒子被随机放置在该区域内。我们已经实现的生成形状有：半径为r的球体，坐标系内xoy平面上的半径为r的圆形，以及坐标系内xoy平面上的长l宽w的矩形。图1展示了一个典型的球形生成形状的粒子系统。基于物理系统或混沌吸引子的更复杂的生成形状已被构思出来但仍未实现。<br>（插图）</li>
<li>  粒子系统的生成形状也描述了新粒子移动的初始方向。在一个球形生成形状内，粒子从粒子系统的原点向外移动。在圆形或矩形形状中，粒子从x-y平面向上移动，但被允许根据另一个参数——“放射”角度——偏移垂直方向。粒子的初始速度由该公式决定：<center>InitialSpeed = MeanSpeed + Rand( ) x VarSpeed，</center>
其中MeanSpeed和VarSpeed是粒子系统的另外两个参数，它们分别表示平均速度和速度的方差。</li>
<li>  为了确定一个粒子的初始颜色，粒子系统需要一个平均颜色和与该颜色的最大偏差。粒子透明度和粒子大小也由平均值和最大变化范围决定。这些方程与上面给出的初速公式类似。</li>
<li>  粒子系统有一个用于明确每个被生成粒子的形状的参数。目前已实现的粒子形状有球形、矩形和条纹球形。后者被用于运动态模糊化粒子——一个在给快速移动物体建模时十分重要的特性。我们在2.5小节和3小节更加详细地探讨了条纹粒子。</li>
<li>  可能的属性控制参数及其变体的数量是无限的。我们目前呈现的是已经找到的最有用和最有趣的。</li>
</ul>
<h2 id="2-3-粒子动力学"><a href="#2-3-粒子动力学" class="headerlink" title="2.3 粒子动力学"></a>2.3 粒子动力学</h2><ul>
<li>  在粒子系统内的单个粒子在三维空间内随着时间移动，并改变颜色、透明度和尺寸。</li>
<li>  将粒子从一帧移动到下一帧（的位置）易如反掌，只需将它的速度矢量加到它的位置矢量上即可。更复杂一些，粒子系统也使用加速度在帧与帧之间修改黎姿的速度。通过这个参数，模型设计师能够模拟重力并让粒子以抛物线轨迹而不是直线轨迹运动。</li>
<li>  粒子随着时间的颜色变化是由颜色变化率这一参数所规定的。粒子的透明度和尺寸也是这么被控制的。在我们的实现方案中，这些变化率在粒子系统中的影响对所有粒子而言是全局的，我们也很容易想到将这个参数也做成随机变化的。</li>
</ul>
<h2 id="2-4-粒子销毁"><a href="#2-4-粒子销毁" class="headerlink" title="2.4 粒子销毁"></a>2.4 粒子销毁</h2><ul>
<li>  粒子在被生成时赋予了一个以帧为衡量单位的寿命。随着每一帧被计算，（剩余）寿命也逐渐减少。当粒子的（剩余）寿命减为0时，粒子就被销毁了。</li>
<li>  只要粒子对图像没有任何贡献，也可以用其它机制来安排粒子的销毁。如果根据颜色和透明度计算的粒子强度低于指定阈值，则该粒子将被销毁。从其父粒子系统的原点沿指定方向移动的距离超过规定值的粒子也会被销毁。这一机制能够被用于去除在关注区域以外的粒子。</li>
</ul>
<h2 id="2-5-粒子渲染"><a href="#2-5-粒子渲染" class="headerlink" title="2.5 粒子渲染"></a>2.5 粒子渲染</h2><ul>
<li>  一旦一帧内所有粒子的位置和外形参数都被计算了，渲染算法就会生成一张图片。一般的粒子渲染问题与更常见的图元（如多边形和曲面）组成的物体对象的渲染一样复杂。粒子可以在屏幕深度上遮挡其它粒子。它们既能变得透明也能在其它粒子上投射阴影。此外，粒子可以在场景中与基于曲面的建模基元的物体共存，而且这些物体能够和粒子交合。</li>
<li>  在我们已有的系统中，有两个假设允许我们简化渲染算法。第一个假设是，我们假设粒子系统不与其它基于曲面的建模基元交合，因此我们的渲染算法只需处理粒子。使用其它技术建模的对象将在渲染后的合成阶段与粒子系统对象合成在一起。为了让粒子系统和其它物体交合或在它们后面，渲染系统将基于在模型坐标空间中定义的剪裁平面使粒子系统图像分为多个子图像，然后在合成阶段将这些子图像与其它图像混合。</li>
<li>  另外一个在目前的渲染系统中做出的假设是每个粒子能够被显示为一个点光源。借助这个假设，确定隐藏曲面不再是一个问题。每个粒子都向它覆盖的像素增加一点光强。一个在其它粒子后面的粒子不再被遮挡，而是给其覆盖的像素添加更多光强。添加的光强及其颜色取决于粒子的透明度和颜色。目前，增加光强的数值不再取决于粒子间距和观察位置，但这些是简单的拓展。观察到的变化、粒子的尺寸和它的形状决定了哪个像素要被遮挡。为了防止时间混叠和残影（的出现），所有粒子的形状都进行反锯齿绘制处理。许多粒子的光可能叠加到一个像素上，因此渲染算法固定红、绿、蓝通道的强度值固定在帧缓存器的最大强度值处，而不是让它们任意溢出。</li>
<li>  借助上述算法和假设，我们不再需要给粒子排序，它们以任意生成顺序渲染到帧缓存器。阴影不再是问题，因为粒子不再反射光而是发光。</li>
</ul>
<h2 id="2-6-粒子层级"><a href="#2-6-粒子层级" class="headerlink" title="2.6 粒子层级"></a>2.6 粒子层级</h2>]]></content>
      <categories>
        <category>个人翻译</category>
      </categories>
      <tags>
        <tag>论文翻译</tag>
        <tag>粒子系统</tag>
        <tag>3D建模</tag>
        <tag>物理模拟</tag>
      </tags>
  </entry>
  <entry>
    <title>计网课程笔记3</title>
    <url>/2022/03/08/%E8%AE%A1%E7%BD%91%E8%AF%BE%E7%A8%8B%E7%AC%94%E8%AE%B03/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.bilibili.com/video/BV1gu411D7QB?p=40">课程链接</a><br>本文仅供个人预习和知识点记录<del>你这不就是抄了一遍PPT吗</del>用。</p>
<hr>
<h1 id="依照学校教学安排，第三章为应用层（即网课第五章）"><a href="#依照学校教学安排，第三章为应用层（即网课第五章）" class="headerlink" title="依照学校教学安排，第三章为应用层（即网课第五章）"></a>依照学校教学安排，第三章为应用层（即网课第五章）</h1><h1 id="3-1-运输层协议概述"><a href="#3-1-运输层协议概述" class="headerlink" title="3.1 运输层协议概述"></a>3.1 运输层协议概述</h1><h2 id="3-1-1-进程之间的通信"><a href="#3-1-1-进程之间的通信" class="headerlink" title="3.1.1 进程之间的通信"></a>3.1.1 进程之间的通信</h2><ul>
<li><strong>运输层属于面向通信部分的最高层，同时也是用户功能中的最底层</strong>，运输层向它上面的应用提供通信服务</li>
<li>当网络的边缘部分中的两个主机使用网络的核心部分的功能进行端到端的通信时，<strong>只有位于网络边缘部分的主机的协议栈才有运输层</strong>，而网络核心部分中的路由器在转发分组时都只用到下三层的功能<br><img src="../photos/ComputerNetworkCourse/3_1.png" title="传输过程中各层与进程示意图"></li>
<li><strong>IP协议的作用范围是两个主机之间的所有链路和路由器</strong> <em>（提供主机之间的逻辑通信）</em></li>
<li><strong>运输层协议TCP和UDP的作用范围是从一台主机的某个进程到另一台主机的进程之间</strong> <em>（为相互通信的应用进程提供了逻辑通信）</em></li>
</ul>
<h2 id="3-1-2-运输层的两个主要协议"><a href="#3-1-2-运输层的两个主要协议" class="headerlink" title="3.1.2 运输层的两个主要协议"></a>3.1.2 运输层的两个主要协议</h2><ul>
<li>在一台主机中经常有多个应用进程同时分别和另一台主机中的多个应用进程通信</li>
<li>运输层的两个重要功能：<strong>复用</strong>和<strong>分用</strong></li>
<li>根据应用程序的不同需求，运输层需要有两种不同的运输协议：<strong>面向连接的传输控制协议TCP</strong>和<strong>无连接的用户数据报UDP</strong><h3 id="基于端口的复用和分用功能"><a href="#基于端口的复用和分用功能" class="headerlink" title="基于端口的复用和分用功能"></a>基于端口的复用和分用功能</h3></li>
<li><strong>向下复用和向上分用</strong><ul>
<li>发送方应用层的多个应用进程通过各自端口传入运输层并在运输层中<strong>重复使用</strong>TCP和UDP协议，对应转化为TCP报文段和UDP用户数据报，随后在网络层中<strong>重复使用</strong>IP协议，转换为IP数据报传送至接收方。</li>
<li>接收方在网络层中<strong>分开使用</strong>IP协议，转化为TCP报文段和UDP用户数据报，在运输层中<strong>分开使用</strong>TCP协议和UDP协议，最后通过各自端口发给应用进程<br><img src="../photos/ComputerNetworkCourse/3_2.png" title="基于端口的复用和分用功能示意图"></li>
</ul>
</li>
<li>运输层向高层用户<strong>屏蔽</strong>了下面网络核心的细节，它使应用进程“看见”的仿佛是一条<strong>在两个运输层实体间的端到端的逻辑通信信道</strong>，但这条通信信道对上层的表现却因运输层使用的不同协议而有很大的差别<ul>
<li>当运输层采用<strong>面向连接的TCP协议</strong>时 <em>（对可靠性要求高）</em>，即使下面的网络不可靠，但逻辑通信信道相当于一条<strong>全双工的可靠信道</strong></li>
<li>当运输层采用<strong>无连接的UDP协议</strong>时 <em>（对效率要求高）</em>，这种逻辑通信信道是一条<strong>不可靠信道</strong></li>
</ul>
</li>
<li>TCP和UDP<ul>
<li><strong>运输协议数据单元</strong>：两个对等实体在通信时传送的数据单位</li>
<li><strong>TCP报文段</strong>：TCP传送的运输协议数据单元</li>
<li><strong>UDP报文/用户数据报</strong>：UDP传送的运输协议数据单元</li>
<li><strong>UDP：一种无连接协议</strong><ul>
<li>提供无连接服务</li>
<li><strong>在传输数据之前不需要先建立连接</strong></li>
<li>传送的数据单位是UDP报文/用户数据报</li>
<li>对方的运输层在收到UDP报文后，<strong>不需要给出任何确认</strong></li>
<li>虽然UDP不提供可靠交付，但在某些情况下UDP是一种最有效的工作方式 <em>（因为要求少）</em></li>
</ul>
</li>
<li><strong>TCP：一种面向连接的协议</strong><ul>
<li>提供面向连接的服务</li>
<li>传送的数据单位协议是TCP报文段</li>
<li><strong>TCP不提供广播或多播服务</strong></li>
<li>由于TCP要提供<strong>可靠的、面向连接的运输服务</strong>，因此不可避免地增加了许多的开销，这不仅使数据单元的首部增大很多，还要占用许多的处理机资源</li>
</ul>
</li>
</ul>
</li>
<li>补充：运输层的UDP用户数据报与网际/网络层的IP数据报有很大区别<ul>
<li>IP数据报要经过互连网中许多路由器的存储转发</li>
<li>UDP用户数据报是在运输层的端到端<strong>抽象的</strong>逻辑信道中传送的</li>
</ul>
</li>
</ul>
<h2 id="3-1-3-运输层的端口"><a href="#3-1-3-运输层的端口" class="headerlink" title="3.1.3 运输层的端口"></a>3.1.3 运输层的端口</h2><ul>
<li>运行在计算机中的进程是用<strong>进程标识符</strong>来标识的</li>
<li><strong>运行在应用层的各种应用进程不应当让计算机操作系统指派它的进程标识符</strong>，这是因为互连网上使用的计算机的操作系统种类很多而不同的操作系统又使用不同格式的进程操作符</li>
<li>为了使运行不同操作系统的计算机的应用进程能够互相通信，就必须使用<strong>统一的方法</strong>对TCP/IP体系的应用进程进行标识<h3 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h3></li>
<li>为了解决不同操作系统下的应用进程在互连网上相互通信时进程标识符不统一的问题，我们在运输层使用<strong>协议端口号/端口</strong></li>
<li>虽然通信的终点是应用进程，但我们可以把端口想象为通信的终点，因为我们只要把统一格式的报文交到目的主机的一个合适的目的端口，剩下交付给进程的过程就交由TCP完成<h3 id="硬件端口与软件端口"><a href="#硬件端口与软件端口" class="headerlink" title="硬件端口与软件端口"></a>硬件端口与软件端口</h3></li>
<li><strong>软件端口</strong>：协议栈层间的抽象的协议端口</li>
<li><strong>硬件端口</strong>：路由器或交换机上的端口</li>
<li>硬件端口是不同硬件设备进行交互的端口，而软件端口是应用层的各种协议进程与运输实体进行层间交互的一种地址<h3 id="TCP-IP运输层端口"><a href="#TCP-IP运输层端口" class="headerlink" title="TCP/IP运输层端口"></a>TCP/IP运输层端口</h3></li>
<li>端口用一个16位端口号进行标志 <em>（意味着最多可以有2的16次方个软件端口）</em></li>
<li>端口号只具有本地意义 <em>（两个主机的端口号可以相同）</em>，即端口号只是为了标识<strong>本计算机应用层中的各进程</strong></li>
<li>在互连网中，不同计算机的相同端口号是没有联系的</li>
<li>两个计算机中的进程要互相通信，不仅必须知道对方的IP地址 <em>（找计算机）</em>，而且还要知道对方的端口号 <em>（找进程）</em><h3 id="两大类端口"><a href="#两大类端口" class="headerlink" title="两大类端口"></a>两大类端口</h3></li>
<li><strong>服务器端使用的端口号</strong><ul>
<li>熟知端口：一般为1-1023</li>
<li>登记端口号：为1024-49151，供没有熟知端口号的应用程序使用的，使用这个范围的端口号必须在互联网数字分配机构IANA登记以防止重复</li>
</ul>
</li>
<li><strong>客户端使用的端口号</strong><ul>
<li>又称短暂端口号，为49152-65535，留给客户进程选择暂时使用</li>
<li>当服务器进程收到客户进程的报文时，就知道了客户进程所使用的动态端口号，通信结束后这个端口号可供其他客户进程以后使用<br><img src="../photos/ComputerNetworkCourse/3_3.png" title="常用的熟知端口"></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-2-用户数据报协议UDP"><a href="#3-2-用户数据报协议UDP" class="headerlink" title="3.2 用户数据报协议UDP"></a>3.2 用户数据报协议UDP</h1><h2 id="3-2-1-UDP概述"><a href="#3-2-1-UDP概述" class="headerlink" title="3.2.1 UDP概述"></a>3.2.1 UDP概述</h2><ul>
<li>UDP只在IP的数据报服务之上增加了一点功能：<ul>
<li>复用和分用的功能</li>
<li>差错检测的功能</li>
</ul>
</li>
<li>虽然UDP用户数据报只能提供不可靠的交付，但UDP在某些方面有特殊的优点</li>
<li>UDP的主要特点<ul>
<li><strong>UDP是无连接的</strong>：发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延</li>
<li><strong>UDP使用尽最大努力交付</strong>：UDP的尽最大努力是在IP的基础上的，即不保证可靠交付，因此主机不需要维持复杂的连接状态表</li>
<li><strong>UDP是面向报文的</strong><ul>
<li>发送方UDP对应用层交下来的报文，在添加首部后就向下交付IP层，<strong>既不合并，也不拆分</strong>，而是保留这些报文的边界</li>
<li>发送时应用层交给UDP多长的报文，UDP就照样发送，<strong>一次发送一个完整的报文</strong></li>
<li>接收方UDP对IP层交上来的UDP用户数据报，在去除首部后就原封不动地交付上层的应用进程，<strong>一次交付一个完整的报文</strong></li>
<li>应用程序必须选择合适大小的报文<ul>
<li>若报文太长，UDP交给IP层后在传输时可能要进行<strong>分片</strong>，这会<strong>降低IP层的效率</strong></li>
<li>若报文太短，UDP交给IP层后在传输时IP数据报中<strong>首部的相对长度太大</strong>，这会<strong>降低IP层的效率</strong></li>
</ul>
</li>
<li>UDP发送的报文长度是应用进程给出的</li>
</ul>
</li>
<li><strong>UDP没有拥塞控制</strong>：：由于UDP不用实现可靠传送网络出现额拥塞不会使源主机发送速率降低，这对某些实时应用很重要，很适合多媒体通信的要求</li>
<li><strong>UDP支持一对一、一对多、多对一和多对多的交互通信</strong></li>
<li><strong>UDP的首部开销小</strong>：只有8字节，比TCP20个字节的首部要短，<strong>同时也意味着UDP的功能比TCP少</strong></li>
</ul>
</li>
</ul>
<h2 id="3-2-2-UDP的首部格式"><a href="#3-2-2-UDP的首部格式" class="headerlink" title="3.2.2 UDP的首部格式"></a>3.2.2 UDP的首部格式</h2><ul>
<li>UDP用户数据报有两个字段：<strong>数据字段</strong>和<strong>首部字段</strong>，首部字段只有8个字节</li>
<li>8个字节的首部构成：<strong>源端口(2字节)+目的端口(2字节)+数据长度(伪首部+有效数据的字节长度)(2字节)+校验和(2字节)</strong></li>
<li>12个字节的伪首部 <em>（不占报文的地址空间，但在计算校验和的时候会临时把伪首部和UDP用户数据报连接在一起）</em>构成：<strong>源IP地址(4字节)+目的IP地址(4字节)+8位全0(1字节)+8位协议（17）(1字节)+UDP长度(2字节)</strong></li>
<li><strong>UDP校验和的计算</strong>：将数据报空余的部分填0，将伪首部、首部、数据以一字节为一段，两字节为一行从上到下排列，进行加法计算，产生的进位溢出加到结果的末位，然后将结果取反即得到校验和。<br><img src="../photos/ComputerNetworkCourse/3_4.png" title="UDP首部、伪首部构成示意图"><br><a href="https://www.cnblogs.com/roccoshi/p/13033014.html">UDP校验和计算教程</a></li>
</ul>
<hr>
<h1 id="3-3-传输控制协议TCP概述"><a href="#3-3-传输控制协议TCP概述" class="headerlink" title="3.3 传输控制协议TCP概述"></a>3.3 传输控制协议TCP概述</h1><h2 id="3-3-1-TCP最主要的特点"><a href="#3-3-1-TCP最主要的特点" class="headerlink" title="3.3.1 TCP最主要的特点"></a>3.3.1 TCP最主要的特点</h2><ul>
<li><strong>TCP是面向连接的运输层协议</strong>：先建立连接再传输</li>
<li>每一条TCP连接<strong>只能有两个端点</strong>，每一条TCP连接<strong>只能是点对点的、一对一的</strong></li>
<li>TCP提供<strong>可靠交付</strong>的服务：不重复、不丢失、不失序</li>
<li>TCP提供<strong>全双工通信</strong>：双方都可以发送和接收</li>
<li><strong>面向字节流</strong><ul>
<li>TCP中的“流”指的是流入或流出进程的字节序列</li>
<li>“面向字节流”的含义：虽然应用程序和TCP的交互时一次一个数据块，但TCP把应用程序交下来的数据看成仅仅是一连串无结构的字节流</li>
<li>TCP不保证接收方应用程序所收到的数据块和发送方应用程序所发出的数据块具有对应大小的关系，但接收方接收到的字节流必须和发送方应用程序发出的字节流完全一样：<strong>TCP不管你数据怎么分的块，但要求数据内容必须是一样的</strong></li>
<li>TCP不关心应用进程一次把多长的报文发送到TCP缓存</li>
<li>TCP对连续的字节流进行分段，形成TCP报文段，但<strong>分段是不定的</strong>，TCP<strong>根据对方给出的窗口值和当前网络拥塞的程度</strong>来决定一个报文段应包含多少字节</li>
</ul>
</li>
<li><strong>注意</strong>，TCP连接是运输层间的<strong>需连接</strong>，是逻辑上的通信信道<br><img src="../photos/ComputerNetworkCourse/3_5.png" title="TCP字节流发送、传输示意图"><h2 id="3-3-2-TCP的连接"><a href="#3-3-2-TCP的连接" class="headerlink" title="3.3.2 TCP的连接"></a>3.3.2 TCP的连接</h2></li>
<li>TCP把连接作为<strong>最基本的工作/功能的抽象</strong>：所有的工作都要以连接建立为根本前提</li>
<li>每一条TCP连接<strong>有两个端点</strong></li>
<li>TCP连接的端点不是主机，不是主机的IP地址，不是应用进程，也不是运输层的协议接口，<strong>TCP连接的端点叫做套接字或插口</strong></li>
<li><strong>套接字就是IP后面加上端口号</strong>，socket=（ip地址：端口号），每一条TCP连接唯一地被通信两端的两个套接字所确定 TCP连接={socket1，socket2}={(ip:port1),(ip:port2)}</li>
<li>同一个IP地址可以有多个不同的TCP连接，同一个端口号也可以出现在多个不同的TCP连接中</li>
</ul>
<hr>
<h1 id="3-4-可靠传输的工作原理"><a href="#3-4-可靠传输的工作原理" class="headerlink" title="3.4 可靠传输的工作原理"></a>3.4 可靠传输的工作原理</h1><h2 id="3-4-1-停止等待协议"><a href="#3-4-1-停止等待协议" class="headerlink" title="3.4.1 停止等待协议"></a>3.4.1 停止等待协议</h2><h3 id="理想的传输条件有两个特点"><a href="#理想的传输条件有两个特点" class="headerlink" title="理想的传输条件有两个特点"></a>理想的传输条件有两个特点</h3><ul>
<li>传输信道不产生差错</li>
<li>不管发送方以多快的速度发送数据，接收方总是来得及处理收到的数据</li>
</ul>
<p><strong>然而实际的网络都不具备以上两个理想条件</strong>，故必须使用一些可靠传输协议，在不可靠的传输信道实现可靠传输</p>
<h3 id="停止等待协议"><a href="#停止等待协议" class="headerlink" title="停止等待协议"></a>停止等待协议</h3><ul>
<li>“停止等待”的思路：每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组</li>
<li><strong>全双工通信的双方既是发送方也是接收方</strong> <em>（发送/接收数据和确认）</em></li>
</ul>
<h3 id="传输情况"><a href="#传输情况" class="headerlink" title="传输情况"></a>传输情况</h3><ul>
<li>无差错情况：A向B发送组1，发完暂停发送，等待B接收组1并传回确认后再发送组2</li>
<li>接收方B出现差错情况<ul>
<li>第一种：B接收组1时出现了差错，就丢弃组1，其它什么也不做（不传回确认）</li>
<li>第二种：组1在传输过程中丢失了，B当然什么都不知道，因此也什么都不做</li>
<li>在这两种情况下，B都不会发送信息</li>
</ul>
</li>
<li>确认出现差错情况：确认信息在传输过程中丢失了</li>
<li>解决方案：超时重传<ul>
<li>A为每个已经发送的组都设置了一个<strong>超时计时器</strong></li>
<li>A只要在超时计时器到期之前收到了确认就撤销该超时计时器，继续发送组2</li>
<li>如果超时计时器到期，就重新发送组1</li>
<li>由此可见<strong>传输过程中的问题都由发送方解决</strong></li>
</ul>
</li>
</ul>
<h3 id="确认丢失和确认迟到"><a href="#确认丢失和确认迟到" class="headerlink" title="确认丢失和确认迟到"></a>确认丢失和确认迟到</h3><ul>
<li>确认丢失<ul>
<li>若B所发送的对M1的确认丢失了，那么A在设定的超时重传时间内不能收到确认，但A无法知道是上述三种情况的哪种，因此<strong>A在超时计时器到期后就要重传组1</strong></li>
<li>假定B又收到了重传的组1（即确认信息丢失），此时B要采取两个行动<ul>
<li>丢弃这个重复的组1，不向上层交付</li>
<li>向A发送确认：就算给A发送过确认信息也要再发送，正是因为A没有收到确认信息所以才重发组1</li>
</ul>
</li>
</ul>
</li>
<li>确认迟到<ul>
<li>若B所发送的对组1的确认传到A的时间过长（在超时计时器到期后送达），则A将重新发送组1，以第二次发送组1收到的确认和第一次发送收到的确认中较早者为时间点发送组2，第二次收到的对组1确认将丢弃</li>
</ul>
</li>
<li><strong>注意</strong><ul>
<li>在发送完一个分组后，必须暂时保留已发送的分组的副本已备重发</li>
<li><strong>分组和确认分组都必须进行编号</strong></li>
<li>超时计时器的重传时间应当比数据在分组传输的平均往返时间<strong>更长一些</strong>，以减少重发次数<h2 id="3-4-2-连续ARQ协议"><a href="#3-4-2-连续ARQ协议" class="headerlink" title="3.4.2 连续ARQ协议"></a>3.4.2 连续ARQ协议</h2></li>
</ul>
</li>
<li><strong>通常A最终总是可以收到对所有发出的分组的确认</strong>，如果A不断重发却收不到确认，则说明通信线路太差，不能进行通信</li>
<li><strong>使用停止等待协议的确认和重传机制，我们就可以在不可靠的传输网络上实现可靠的通信</strong></li>
<li>像上述的这种可靠传输协议常称为<strong>自动重传请求ARQ</strong>,即重传请求是自动进行的，不需要接收方发送重传请求</li>
</ul>
<h3 id="信道利用率"><a href="#信道利用率" class="headerlink" title="信道利用率"></a>信道利用率</h3><ul>
<li><strong>停止等待协议的优点是简单，缺点是信道利用率太低</strong></li>
<li>设分组发送所需时间为Td，确认发送所需时间为Ta（均不包含传送时间），两者的传送时间与分组确认接收时间总和为RTT，则信道利用率<strong>U=Td/(Td+RTT+Ta)</strong></li>
<li>可以看出，当往返时间RTT远大于分组发送时间Td时，信道的利用率就会非常低，若出现重传，则对传送有用的数据信息而言，信道的利用率还要降低、</li>
</ul>
<h3 id="连续ARQ协议-流水线传输"><a href="#连续ARQ协议-流水线传输" class="headerlink" title="连续ARQ协议/流水线传输"></a>连续ARQ协议/流水线传输</h3><ul>
<li>为了提高传输效率，发送方采用流水线传输</li>
<li>流水线传输就是发送方<strong>可连续发送多个分组，不必每发完一个分组就停下来等待对方确认</strong>，这样可以使信道上一直有数据不间断地传送</li>
<li>由于信道上一直有数据不间断地传送，这种传输方式可以获得很高的信道利用率</li>
<li><strong>仍然需要设置超时计时器</strong></li>
<li><strong>滑动窗口协议比较复杂，是TCP协议的精髓所在</strong><ul>
<li>发送方维持的<strong>发送窗口</strong>：位于发送窗口内的分组都可连续发送出去而不需要等待对方的确认</li>
<li>连续ARQ协议规定，<strong>发送方每收到一个确认，就把发送窗口（缓存中的一块区域）向前滑动一个分组的位置</strong><br><img src="../photos/ComputerNetworkCourse/3_6.png" title="连续ARQ协议发送窗口工作原理示意图"></li>
</ul>
</li>
</ul>
<h3 id="累计确认"><a href="#累计确认" class="headerlink" title="累计确认"></a>累计确认</h3><ul>
<li>接收方一般采用<strong>累计确认</strong>的方式，即不必对收到的分组逐个发送确认，而是对<strong>按序到达的最后一个分组发送确认</strong>，表示到这个分组之前的所有分组都已经正确收到了</li>
<li>优点：容易实现，即使确认丢失也不必重传</li>
<li>缺点：不能向发送方反映出接收方已经正确收到的所有分组的信息</li>
<li>对于缺点的补充：<strong>Go-back-N(回退N)</strong><ul>
<li>如果发送方发送了x个分组，而其中第N个分组丢失了，此时接收方只能对<strong>第N个分组之前的所有分组发出确认</strong>，发送方无法得知第N个分组后其他分组的接收情况，只能<strong>将从第N个分组起的所有分组重新发送</strong>，即<strong>表示需要再退回来重传已发送过的分组</strong></li>
<li>可见当通信信道质量不好时，连续ARQ协议会带来不好的影响</li>
</ul>
</li>
</ul>
<h3 id="TCP可靠通信的具体实现"><a href="#TCP可靠通信的具体实现" class="headerlink" title="TCP可靠通信的具体实现"></a>TCP可靠通信的具体实现</h3><ul>
<li><strong>TCP连接的每一端都必须设有一个发送窗口和一个接收窗口</strong></li>
<li>TCP的可靠传输机制用字节的序号进行控制，TCP所有的确认都是基于序号而不是基于报文</li>
<li>TCP两端的四个窗口经常处于<strong>动态变化</strong>之中</li>
<li>TCP连接的往返时间RTT也不是固定不变的，需要使用特定的算法估算较为合理的时间</li>
</ul>
<hr>
<h1 id="3-5-TCP报文段的首部格式"><a href="#3-5-TCP报文段的首部格式" class="headerlink" title="3.5 TCP报文段的首部格式"></a>3.5 TCP报文段的首部格式</h1><ul>
<li>TCP虽然是面向字节流的，但TCP传送的数据单元确是报文段</li>
<li>一个TCP报文段分为首部和数据两部分，而TCP的全部功能体现在它首部中各字段的作用</li>
<li>TCP报文段首部的前20个字节是固定的，后面有4n（n为自然数）字节是根据需要而增加的选项，因此**TCP首部的最小长度是20字节)<br><img src="../photos/ComputerNetworkCourse/3_7.png" title="TCP首部格式示意图"></li>
<li>源端口和目的端口字段各占2字节，端口是运输层和应用层的服务接口，运输层的复用和分用功能都要通过端口才能实现</li>
<li>序号字段占4字节，TCP连接传送的数据流中的每一个字节都编上一个序号，序号字段的值则指的是本报文段所发送的数据的第一个字节的编号</li>
<li>确认号字段占4字节，是期望收到对方的下一个报文段的数据的第一个字节的编号</li>
<li>数据偏移（即首部长度）占4位，它指出TCP报文段的<strong>数据起始处</strong>距离TCP报文段的起始处有多远，数据偏移的单位是32位字（以4字节为计算单位）</li>
<li>保留字段占6位，保留为今后使用，但目前应置为0</li>
<li>六个标志位占六位<ul>
<li>紧急URG：当URG=1时，表明紧急指针字段有效，告诉系统此报文段中有紧急数据，应尽快传送</li>
<li>确认ACK：当ACK=1时，确认号字段有效，0则无效</li>
<li>推送PSH：当PSH=1时，就尽快的交付给接收应用进程，而不再等到整个缓存都填满后再向上交付</li>
<li>复位RST：当RST=1时，表明TCP连接中出现严重差错（如主机崩溃），必须释放连接，然后再重新建立运输连接</li>
<li>同步SYN：SYN=1表明这是一个连接请求或连接接受报文（确认连接）</li>
<li>终止FIN：用于释放连接，FIN=1表示此报文段的发送端的数据已发送完毕，并要求释放运输连接</li>
</ul>
</li>
<li>窗口字段占2字节，用来让对方设置发送窗口的依据 <em>（告诉对方自己的接收窗口的大小）</em>，单位为字节</li>
<li>校验和占2字节，检验和字段检验的范围包括首部和数据两部分，计算检验和具体见3.2.2</li>
<li>紧急指针字段占2字节，指出在本报文段中紧急数据有多少个字节 *（紧急数据放在本报文段数据的最前面）</li>
<li>选项字段：长度可变。TCP最初只规定了一种选项，即<strong>最大报文段长度MSS</strong>，MSS高速对方TCP己方缓存能接收的报文段的数据字段（TCP报文段长度减去TCP首部长度）的最大长度是多少字节，字节数存储在MSS中。其他选项如下：<ul>
<li>窗口扩大选项占3字节，其中有一个字节表示移位S，新的2窗口值等于TCP首部中的窗口位数增大到16+S，相当于把窗口值向左移动S位后获得的实际的窗口大小</li>
<li>时间戳选项占10字节，其中最主要的字段<strong>时间戳值字段</strong>占4字节，<strong>时间戳回送回答字段</strong>占4字节</li>
<li>选择确认选项，见3.6.3</li>
</ul>
</li>
<li>规定MSS的原因<ul>
<li>MSS与接收窗口值没有关系</li>
<li><strong>若选择较小的MSS长度，网络的利用率就降低</strong>，因为TCP报文段越少，首部占比就越大，传输效率就越低，开销就显得大</li>
<li><strong>若TCP报文段很长，会使得开销增大</strong>，在IP层传输时就有可能要分解成多个端数据报片，在终点要把收到的各个短数据报片装配成原来的TCP报文段，当传输出错时还要进行重传，进而增大开销</li>
<li>综上，<strong>MSS应尽可能大些，只要在IP层传输时不需要再分片就行</strong></li>
<li>由于IP数据报的路径是动态变化的，因此在这条路径上确定的不需要分片的MSS，如果改走另一条路径就可能需要进行分片</li>
<li>综上，<strong>最佳的MSS很难确定</strong></li>
</ul>
</li>
</ul>
<hr>
<h1 id="3-6-TCP可靠传输的实现"><a href="#3-6-TCP可靠传输的实现" class="headerlink" title="3.6 TCP可靠传输的实现"></a>3.6 TCP可靠传输的实现</h1><h2 id="3-6-1-以字节为单位的滑动窗口"><a href="#3-6-1-以字节为单位的滑动窗口" class="headerlink" title="3.6.1 以字节为单位的滑动窗口"></a>3.6.1 以字节为单位的滑动窗口</h2><ul>
<li>TCP的滑动窗口是以字节为单位的</li>
<li>先假定A收到了B发来的确认报文段，其中窗口（接收能力）是20字节，而确认号（下一个报文段开头的序号）是31（表明序号30为止的数据已经收到了），根据窗口和确认号，A就构造出自己的发送窗口。<ul>
<li>发送窗口表示：<strong>在没有收到B的确认的情况下，A可以连续把窗口内的数据都发送出去</strong></li>
<li>发送窗口里面的序号表示允许发送的序号</li>
<li>显然，窗口越大，发送方就可以在收到对方确认之前连续发送更多的数据，因而可能获得更高的传输效率</li>
<li><strong>TCP标准强烈不赞成发送窗口前沿向后收缩</strong><br><img src="../photos/ComputerNetworkCourse/3_8.png" title="发送窗口示意图"></li>
</ul>
</li>
<li>发送时遇到字节未按序收到的解决方案<ul>
<li>当一部分字节未收到确认时，重新从未收到字节中序号最靠前的那个字节开始重新发送</li>
<li>若发送窗口内的序号都已用完但还没有收到确认，必须停止发送 <em>（不再发送后续字节）</em></li>
</ul>
</li>
<li>发送方的应用进程把字节流写入TCP的发送缓存，发送缓存一般都比发送窗口大<br><img src="../photos/ComputerNetworkCourse/3_9.png" title="发送缓存、发送窗口关系示意图"></li>
<li>接收方的应用进程从TCP的接收缓存中读取字节流，接收缓存一般都比接收窗口大<br><img src="../photos/ComputerNetworkCourse/3_10.png" title="接收缓存、接收窗口关系示意图"></li>
<li><strong>需要注意</strong><ul>
<li>A的发送窗口并不总是和B的接收窗口一样大（因为有一定的时间滞后）</li>
<li>TCP标准没有规定对不按序到达的数据如何处理，通常是先临时放在接收窗口中，等到字节流中所缺少的字节收到后，再按序交付上层的应用进程</li>
<li>TCP要求接收方必须有累计确认的功能，这样可以减少传输开销<h3 id="接收方发送确认"><a href="#接收方发送确认" class="headerlink" title="接收方发送确认"></a>接收方发送确认</h3></li>
</ul>
</li>
<li>接收方可以在合适的时候发送确认，也可以在自己有数据要发送时把确认信息顺便捎带上</li>
<li><strong>需要注意</strong>：<ul>
<li>接收方不应过分推迟发送确认，否则会导致发送方不必要的重传，浪费了网络的资源</li>
<li>捎带确认实际上并不经常发生，因为大多数应用程序很少同时在两个方向上发送数据<h2 id="3-6-2-超时重传时间的选择"><a href="#3-6-2-超时重传时间的选择" class="headerlink" title="3.6.2 超时重传时间的选择"></a>3.6.2 超时重传时间的选择</h2></li>
</ul>
</li>
<li>重传机制是TCP中最重要和最复杂的问题之一</li>
<li>TCP每发送一个报文段，就对这个报文段设置一次计时器</li>
<li>只要计时器设置的重传时间已到但还没有收到确认，就要重传这一报文段</li>
<li><strong>重传时间的选择是TCP最复杂的问题之一</strong><ul>
<li>如果把超时重传时间设置得太短，就会引起很多报文段的不必要的重传，使网络负荷增大</li>
<li>但若把超时重传时间设置得过长，则又使网络的空闲时间增大，降低了传输效率</li>
</ul>
</li>
<li><strong>TCP采用了一种自适应算法</strong>，它记录一个报文段发出的时间，以及收到相应的确认的时间，这两个时间之差就是报文段的往返时间RTT</li>
<li><strong>往返时延的方差很大</strong>:由于TCP的下层是一个互联网环境，IP数据报所选择的路由变化很大，因而运输层的往返时间的方差也很大<h3 id="加权平均往返时间"><a href="#加权平均往返时间" class="headerlink" title="加权平均往返时间"></a>加权平均往返时间</h3></li>
<li>TCP保留了RTT的一个加权平均往返时间RTT<sub>S</sub>（这又称为<strong>平滑的往返时间</strong>）</li>
<li>第一次测量到RTT样本时，RTT<sub>S</sub>值就取为所测量到的RTT样本值，以后每测量到一个新的RTT样本，就按下式重新计算一次RTT<sub>S</sub><br><img src="../photos/ComputerNetworkCourse/3_11.png" title="RTT&lt;sub&gt;S&lt;/sub&gt;迭代计算公式"></li>
<li>其中，0≤α≤1，若α很接近于0，表示RTT值更新较慢，若α接近于1，则表示RTT更新较快</li>
<li>RFC2988推荐的α值为0.125<h3 id="超时重传时间"><a href="#超时重传时间" class="headerlink" title="超时重传时间"></a>超时重传时间</h3></li>
<li><strong>RTO应略大于上面得出的加权平均往返时间RTT<sub>S</sub></strong></li>
<li>RFC2988建议使用<strong>RTO=RTT<sub>S</sub>+4xRTT<sub>D</sub><strong>计算RTO，其中RTT<sub>D</sub>是</strong>RTT的偏差的加权平均值</strong></li>
<li>RFC2988计算RTT<sub>D</sub>的计算方法：第一次测量时，RTT<sub>D</sub>值取为测量到的RTT样本值的一半，在以后的测量中，使用下式计算加权平均的RTT<sub>D</sub><br><img src="../photos/ComputerNetworkCourse/3_12.png" title="RTT&lt;sub&gt;D&lt;/sub&gt;迭代计算公式"></li>
<li>其中β是一个小于1的系数，推荐值为0.25<h3 id="往返时间RTT的测量相当复杂"><a href="#往返时间RTT的测量相当复杂" class="headerlink" title="往返时间RTT的测量相当复杂"></a>往返时间RTT的测量相当复杂</h3></li>
<li>问题描述：TCP报文段1没有收到确认，重传后收到了确认报文段ACK，<strong>如何判定ACK是对第一次发出的报文段的确认还是对重传的报文段的确认？</strong></li>
<li>解决方案：Karn算法<ul>
<li>思想：<strong>在计算平均往返时间RTT时，只要报文段重传了就不采用其往返时间样本</strong></li>
<li>优点：得出的加权平均往返时间RTT<sub>S</sub>和超时重传时间RTO就比较准确</li>
<li>缺点：当报文段的时延突然增大很多时，在原来得出的重传时间内不会收到确认报文段，导致需要重传的报文段占比增加，但根据Karn算法，这些报文段的往返时间样本将不予考虑，因此导致<strong>超时重传时间无法更新</strong></li>
<li><strong>修正的Karn算法</strong><ul>
<li>报文段每重传一次，就把RTO增大一些：<strong>新RTO=γx旧的RTO</strong></li>
<li>其中γ的典型值是2</li>
<li>当不再发生报文段的重传时，才根据报文段的往返时延更新平均往返时延RTT和超时重传时间RTO的数值</li>
<li>实践证明，这种策略较为合理<h2 id="3-6-3-选择确认SACK"><a href="#3-6-3-选择确认SACK" class="headerlink" title="3.6.3 选择确认SACK"></a>3.6.3 选择确认SACK</h2></li>
</ul>
</li>
</ul>
</li>
<li>针对的问题：若收到的报文段无差错，只是未按序号，中间还缺少一些序号的数据，那么<strong>能否设法只传送缺少的数据而不重传已经准确到达接收方的数据？</strong></li>
<li>接收方收到和前面字节流不连续的两个字节块，如果这些字节的序号都在接收窗口内，那么接收方就先收下这些数据，但**要把这些信息准确地高速发送方，使发送方不要再重复发送这些已收到的数据<h3 id="RFC2018的规定"><a href="#RFC2018的规定" class="headerlink" title="RFC2018的规定"></a>RFC2018的规定</h3></li>
<li>如果要使用SACK，那么在建立TCP连接时，就要在TCP首部的选项中加上“允许SACK”的选项，而双方都必须事先商定好</li>
<li>如果使用SACK，那么原来首部中的确认号字段的用法仍然不变，只是以后在TCP报文段的首部中都增加了SACK选项，以便报告收到的不连续的字节块的边界</li>
<li>由于首部选项的长度最多只有40字节，而指明一个边界就要用到4字节，因此在选项中<strong>最多只能指明4个字节块的边界信息</strong> </li>
</ul>
<hr>
<h1 id="3-7-TCP的流量控制"><a href="#3-7-TCP的流量控制" class="headerlink" title="3.7 TCP的流量控制"></a>3.7 TCP的流量控制</h1><h2 id="3-7-1-利用滑动窗口实现流量控制"><a href="#3-7-1-利用滑动窗口实现流量控制" class="headerlink" title="3.7.1 利用滑动窗口实现流量控制"></a>3.7.1 利用滑动窗口实现流量控制</h2><h2 id="3-7-2-TCP的传输效率"><a href="#3-7-2-TCP的传输效率" class="headerlink" title="3.7.2 TCP的传输效率"></a>3.7.2 TCP的传输效率</h2><hr>
<h1 id="3-8-TCP的拥塞控制"><a href="#3-8-TCP的拥塞控制" class="headerlink" title="3.8 TCP的拥塞控制"></a>3.8 TCP的拥塞控制</h1><hr>
<h1 id="3-9-TCP的运输连接管理"><a href="#3-9-TCP的运输连接管理" class="headerlink" title="3.9 TCP的运输连接管理"></a>3.9 TCP的运输连接管理</h1><hr>
<h1 id="3-10-补充"><a href="#3-10-补充" class="headerlink" title="3.10 补充"></a>3.10 补充</h1><ul>
<li>使用TCP的网络应用：HTTP\FTP\TELNET\SMTP</li>
<li>使用UDP的网络应用：流媒体\视频会议\DNS\Internet电话</li>
</ul>
]]></content>
      <categories>
        <category>课程笔记_计网</category>
      </categories>
      <tags>
        <tag>课程笔记</tag>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title>需求文档(v4.1)</title>
    <url>/2022/03/06/%E9%9C%80%E6%B1%82%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<p><strong>截止日期：4.21号</strong><br><strong>统一Unity版本:2020.3</strong></p>
<h1 id="效果预期"><a href="#效果预期" class="headerlink" title="效果预期"></a>效果预期</h1><h2 id="三个场景"><a href="#三个场景" class="headerlink" title="三个场景"></a><strong>三个场景</strong></h2><ul>
<li><strong>主页面（标题，选择场景，制作名单）</strong></li>
<li><strong>游戏场景1：石碑刻字</strong><ul>
<li>石碑的场景是一个碑林，可以搭一个园林</li>
<li>有不同的碑文供临摹</li>
<li>临摹的过程是玩家手拿凿子去刻</li>
<li>玩家可随时查看作品的效果</li>
<li>给玩家提供碑文的介绍查阅</li>
</ul>
</li>
<li><strong>游戏场景2：猜灯谜</strong><ul>
<li>猜灯谜的场景最好是一个古代夜市（限制玩家移动范围）或者是一个封闭的游戏室</li>
<li>有不同的灯谜</li>
<li>玩家拼灯谜里的字<ul>
<li>拼字思路：每个字有一个数组，数组元素从第一个到最后一个均为各自对应笔画的个数，这样谜底的每个字都有独立编号，你往填字页面扔笔画组件，对应的数组元素内容++</li>
<li>拼字UI思路：有一个页面，玩家<strong>一个一个地拼</strong>页面上显示上述数组的一个表格，让玩家看到自己在当前字放了哪些笔画，然后有确定键，重来键，<strong>确定键提交全部字，重来键清空当前字</strong>。</li>
</ul>
</li>
<li>有一个能旋转的跑马灯，每切换一次题目就转一下（从慢到快再从快到慢最后停下）</li>
</ul>
</li>
<li><strong>其他</strong><ul>
<li>所有场景都提供到另外两个场景的选项</li>
</ul>
</li>
</ul>
<h1 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h1><h2 id="模型、美术素材"><a href="#模型、美术素材" class="headerlink" title="模型、美术素材"></a>模型、美术素材</h2><ul>
<li><strong>主页面</strong><ul>
<li>标题：书刀梦</li>
<li>标题字体 <strong>（已解决）</strong></li>
<li>主页面演出效果：搭一个夜市场景 <strong>（已解决）</strong></li>
</ul>
</li>
<li><strong>游戏场景1</strong><ul>
<li>石碑模型 <strong>（已解决）</strong></li>
<li>树林模型 <strong>（已解决）</strong></li>
<li>凿子模型 <strong>（已解决）</strong></li>
<li>石碑的材质（类似雪地但需要多刻一会才能留痕迹，同时要控制笔画的最大深度）<strong>（已解决）</strong></li>
<li>几张碑帖的高清图 <strong>（已解决）</strong></li>
<li>换一个天空盒 <strong>（已解决）</strong></li>
</ul>
</li>
<li><strong>游戏场景2</strong><ul>
<li>古代夜市场景，建筑素材 <strong>（已解决）</strong></li>
<li>水面（正在解决）</li>
<li>由于是夜市，所以需要适合的光照（这个的调整可能需要一定时间，所以越早确定场景2的具体内容越好）<strong>（已解决）</strong></li>
<li>灯笼模型（最好是跑马灯的样子和功能，能在上面贴几张古画更好）<strong>（已撤销方案）</strong><ul>
<li>灯笼分件建模，</li>
<li>画贴图，灯笼架子一套贴图灯笼上透光的纸要做另一套贴图 </li>
<li>贴图交由美工自由发挥</li>
</ul>
</li>
<li>选笔画的时候出一个选字页面，有几个按钮，按钮的外观是各个笔画的sprite，按一个按钮，就在旁边的一个盘子或者地上生成相应笔画，然后让玩家捡起来放到指定位置。</li>
<li>字体（暂定华文隶书）</li>
<li>笔画（思路是二维的笔画进行y轴上的拉伸得到柱体），<strong>这个等灯谜确定后我把需要拆分成组件的字发到群里然后做</strong>。</li>
</ul>
</li>
</ul>
<h2 id="玩家的功能"><a href="#玩家的功能" class="headerlink" title="玩家的功能"></a>玩家的功能</h2><ul>
<li>移动</li>
<li>旋转视角</li>
<li>拾取</li>
<li>刻字</li>
<li>UI交互</li>
</ul>
<h2 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h2><ul>
<li>主页面需要提供选关页面/按键，标题（UI界面布局在群里）</li>
<li>弹窗显示信息（游戏场景1的碑文介绍功能要用到）</li>
<li>游戏场景1内需要提供让玩家控制弹窗（开启或关闭）、音量调整、碑文图片显示（开启或关闭）的UI</li>
</ul>
<h1 id="目前需要解决（想到的）的问题"><a href="#目前需要解决（想到的）的问题" class="headerlink" title="目前需要解决（想到的）的问题"></a>目前需要解决（<del>想到的</del>）的问题</h1><ul>
<li>游戏标题 <strong>（已解决）</strong></li>
<li>刻字效果的实现 <strong>（已解决）</strong></li>
<li>UI交互还未完全实现</li>
<li>美术素材：灯笼、标题字体、笔画模型<strong>（解决中）</strong></li>
<li>场景的具体内容 <strong>（解决中）</strong></li>
</ul>
<h1 id="目前需要关注的"><a href="#目前需要关注的" class="headerlink" title="目前需要关注的"></a>目前需要关注的</h1><ul>
<li>报名</li>
<li>PPT</li>
<li>学学剪映</li>
</ul>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
      <tags>
        <tag>Unity</tag>
        <tag>VR</tag>
        <tag>计设</tag>
      </tags>
  </entry>
  <entry>
    <title>每日力扣1</title>
    <url>/2022/09/11/%E6%AF%8F%E6%97%A5%E5%8A%9B%E6%89%A31/</url>
    <content><![CDATA[<h1 id="【前言】：写给无意中点进来的你"><a href="#【前言】：写给无意中点进来的你" class="headerlink" title="【前言】：写给无意中点进来的你"></a><strong>【前言】</strong>：写给无意中点进来的你</h1><h2 id="（主要是因为博客好久没更新了，打算重新利用起来）代码有一部分是借鉴评论区和官方题解的，所以在力扣写题解就难免不太合适，然而记笔记的需求是确切存在的，博客的tag查找也很方便，就打算在博客写笔记了，也方便我快速回忆起知识点省得再去CSDN（垃圾堆）里找，尽量每日一更，之前积攒下来的题也会慢慢加更上来。"><a href="#（主要是因为博客好久没更新了，打算重新利用起来）代码有一部分是借鉴评论区和官方题解的，所以在力扣写题解就难免不太合适，然而记笔记的需求是确切存在的，博客的tag查找也很方便，就打算在博客写笔记了，也方便我快速回忆起知识点省得再去CSDN（垃圾堆）里找，尽量每日一更，之前积攒下来的题也会慢慢加更上来。" class="headerlink" title="（主要是因为博客好久没更新了，打算重新利用起来）代码有一部分是借鉴评论区和官方题解的，所以在力扣写题解就难免不太合适，然而记笔记的需求是确切存在的，博客的tag查找也很方便，就打算在博客写笔记了，也方便我快速回忆起知识点省得再去CSDN（垃圾堆）里找，尽量每日一更，之前积攒下来的题也会慢慢加更上来。"></a><del>（主要是因为博客好久没更新了，打算重新利用起来）</del>代码有一部分是借鉴评论区和官方题解的，所以在力扣写题解就难免不太合适，然而记笔记的需求是确切存在的，博客的tag查找也很方便，就打算在博客写笔记了，也方便我快速回忆起知识点<em>省得再去CSDN<del>（垃圾堆）</del>里找</em>，尽量每日一更，之前积攒下来的题也会慢慢加更上来。</h2><h1 id="今日题目"><a href="#今日题目" class="headerlink" title="今日题目"></a>今日题目</h1><p><strong>雇佣K名工人的最低成本</strong><br><strong>计算右侧小于当前元素的个数</strong><br><strong>分割回文串</strong><br><strong>单词搜索II</strong><br><strong>修剪二叉搜索树</strong></p>
<hr>
<h1 id="雇佣K名工人的最低成本（优先级队列，lambda排序）"><a href="#雇佣K名工人的最低成本（优先级队列，lambda排序）" class="headerlink" title="雇佣K名工人的最低成本（优先级队列，lambda排序）"></a>雇佣K名工人的最低成本（优先级队列，lambda排序）</h1><p><a href="https://leetcode.cn/problems/minimum-cost-to-hire-k-workers/">题目链接</a><br>这道题的核心在于根据什么去挑工人。我们定义“价性比”=期望工资/工作量，即每单位工作量对应的工资。<br>我们再看题目的两个关键要求：<br>1.工资要按工作量占比分配<br>2.每个工人得到的工资应大于等于其期望工资<br>我们将所有工人按<strong>价性比</strong>从低往高排列，如果按第k个人的价性比付工资，则能满足以上两个条件。<br>那么如何满足成本最低呢？<br>我们易知成本=价性比*工作总量，如果成本要最低的，那么工作总量也要尽量小。我们使用优先级队列，先将前k-1个人的工作量入队，从第k个人开始，我们将当前遍历到的工人的工作量加入k-1个工人的工作量中得到总工作量，再乘以当前工人对应的效费比，将结果与最小值进行比较以更新结果，最后返回。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public double MincostToHireWorkers(int[] quality, int[] wage, int k) &#123;//雇佣K名工人的最低成本</span><br><span class="line">         int l = quality.Length;</span><br><span class="line">         int[] q = new int[l];</span><br><span class="line">         double res =1e9,totalq=0.0;</span><br><span class="line">         for(int i = 0;i&lt;l;i++)&#123;//这个数组是用来存储按效费比排列后工人的序号，以获取对应工作量和工资</span><br><span class="line">             q[i]=i;</span><br><span class="line">         &#125;</span><br><span class="line">         Array.Sort(q,(a,b)=&gt;&#123;return wage[a]*quality[b]-wage[b]*quality[a];&#125;);//将数组通过lambda表达式按升序排列，前者比后者大则调转，即升序</span><br><span class="line">         PriorityQueue&lt;int,int&gt; PQ = new PriorityQueue&lt;int,int&gt;();//通过优先级队列实现最大堆，优先级队列中维护的是最小的k个工作量</span><br><span class="line">         for(int i =0;i&lt;k-1;i++)&#123;//先获取前k-1个工人的工作量之和，并将他们的工作量入队</span><br><span class="line">             totalq+=quality[q[i]];</span><br><span class="line">             PQ.Enqueue(quality[q[i]],-quality[q[i]]);//C#的最大堆优先级是根据第二个参数的大小升序排列的，要想让工作量从大到小排，就让工作量的相反数从小到大排</span><br><span class="line">         &#125;      </span><br><span class="line">         for(int i =k-1;i&lt;l;i++)&#123;</span><br><span class="line">             totalq+=quality[q[i]];//得到当前k个工人的工作量</span><br><span class="line">             double cur = ((double)wage[q[i]]/quality[q[i]])*totalq;//得到结果</span><br><span class="line">             res = Math.Min(res,cur);//取较小值</span><br><span class="line">             PQ.Enqueue(quality[q[i]],-quality[q[i]]);//将当前工人的工作量入队进行比较</span><br><span class="line">             totalq-=PQ.Dequeue(); //将最大的工作量出队，此时totalq是最小的k-1个工作量之和  </span><br><span class="line">         &#125;</span><br><span class="line">         return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="计算右侧小于当前元素的个数（二分查找）"><a href="#计算右侧小于当前元素的个数（二分查找）" class="headerlink" title="计算右侧小于当前元素的个数（二分查找）"></a>计算右侧小于当前元素的个数（二分查找）</h1><p><a href="https://leetcode.cn/problems/count-of-smaller-numbers-after-self/">题目链接</a><br>从右往左遍历数组，单独用一个List存入，每次存入前先通过二分查找获取该数在List中的位置（按升序排列），设该类数的最小索引为k，即有k个数在该数右侧且比该数小。<br>由于是从右往左遍历数组，每次遍历得到的结果也是从右往左加入作为结果的List，故需要对List进行翻转后再返回。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public IList&lt;int&gt; CountSmaller(int[] nums) &#123;//计算右侧小于当前元素的个数-二分查找</span><br><span class="line">          IList&lt;int&gt; res = new List&lt;int&gt;();</span><br><span class="line">          List&lt;int&gt; sortedList = new List&lt;int&gt;();</span><br><span class="line">          int[] resTemp = new int[nums.Length];</span><br><span class="line">          for(int i = nums.Length-1;i&gt;-1;i--)&#123;</span><br><span class="line">              int location = bFind(sortedList,nums[i]);</span><br><span class="line">              resTemp[i]=location;</span><br><span class="line">              sortedList.Insert(location,nums[i]);</span><br><span class="line">          &#125;</span><br><span class="line">        res = resTemp.ToList();</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int bFind(List&lt;int&gt; sortedList,int num)&#123;</span><br><span class="line">        if(sortedList.Count==0)</span><br><span class="line">            return 0;</span><br><span class="line">        int left = 0,right = sortedList.Count-1;</span><br><span class="line">        while(left&lt;=right)&#123;</span><br><span class="line">            int mid = (left+right)&gt;&gt;1;</span><br><span class="line">            if(num&gt;sortedList[mid])&#123;</span><br><span class="line">                left=mid+1;</span><br><span class="line">             &#125;else&#123;</span><br><span class="line">                right = mid-1;</span><br><span class="line">                //num=sortedList[mid]或num&lt;sortedList[mid]都得right=mid-1，后者的原因显而易见，而前者的原因是这道题要求的是当前元素右侧小于（划重点）该元素的元素个数，如果是小于等于则可直接返回mid，但为了排除相等的元素，我们则要去找这段连续的相同数字的左边界</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return left;</span><br><span class="line">    &#125;</span><br><span class="line">    // public void Reverse(IList&lt;int&gt; res)&#123;//由于力扣的C#版本中Reverse存在问题，然而重写Reverse会导致超时，最后用数组和ToList方法取代。</span><br><span class="line">    //     Stack&lt;int&gt; stack = new Stack&lt;int&gt;();</span><br><span class="line">    //     int l  = res.Count;</span><br><span class="line">    //     for(int i  = 0;i&lt;l;i++)&#123;</span><br><span class="line">    //         stack.Push(res[0]);</span><br><span class="line">    //         res.RemoveAt(0);</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     for(int i = 0;i&lt;l;i++)&#123;</span><br><span class="line">    //         res.Add(stack.Pop());</span><br><span class="line">    //     &#125;</span><br><span class="line">    //     return ;</span><br><span class="line">    // &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<hr>
<h1 id="分割回文串（回溯、DFS）"><a href="#分割回文串（回溯、DFS）" class="headerlink" title="分割回文串（回溯、DFS）"></a>分割回文串（回溯、DFS）</h1><p><a href="https://leetcode.cn/problems/palindrome-partitioning/">题目链接</a><br>题目的要求是返回一个List，List里是这个字符串分成多个回文串组合的所有分法。这是一个考察<strong>枚举</strong>的题<br>我们先用一个bool类型的二维数组record记录i和j为左右端点的回文串是否存在，如果存在即为true，类似于动态规划，我们通过上一个回文串来判断当前的子串是否是回文串<br>设字符串为s,i为左端点，j为右端点，则record[i,j]的递推式如下：<br>record[i,j]= i&gt;=j? true: (record[i+1,j-1]==true&amp;&amp;s[i]==s[j]?true:false) <em>意会，不严谨</em>，首先判断i是否大于等于j，即当前串是否为空串或长度为1的串，如果不是，则需要查询该子串的上一个状态s[i+1]-s是否是回文串，如果是回文串且当前指向的两个字符相等，才返回为true。<br>通过以上步骤，我们获取了字符串所有的回文串，接下来解决怎么分的问题。<br>由于是枚举，我们可以通过DFS+回溯的方式来枚举。设一个指针i，0~i的子串被枚举完了，又设一个指针j，j在i和最后一个字符间枚举当前分法的下一个回文子串两端，i再指向j。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    bool[,] record;</span><br><span class="line">    int l ;</span><br><span class="line">    IList&lt;IList&lt;string&gt;&gt; res = new List&lt;IList&lt;string&gt;&gt;();</span><br><span class="line">    IList&lt;string&gt; ans = new List&lt;string&gt;();</span><br><span class="line">    public IList&lt;IList&lt;string&gt;&gt; Partition(string s) &#123;//分割回文串</span><br><span class="line">            l = s.Length;</span><br><span class="line">           record = new bool[l,l];</span><br><span class="line">           for(int i =0;i&lt;l;i++)&#123;</span><br><span class="line">               for(int j = 0;j&lt;l;j++)&#123;</span><br><span class="line">                   record[i,j]=true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           for(int i = l-1;i&gt;-1;--i)&#123;</span><br><span class="line">               for(int j = i+1;j&lt;l;j++)&#123;</span><br><span class="line">                   record[i,j]=(s[i]==s[j]&amp;&amp;record[i+1,j-1]);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           DFS(s,0);</span><br><span class="line">           return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public void DFS(string s,int i)&#123;</span><br><span class="line">        if(i==l)&#123;</span><br><span class="line">           res.Add(new List&lt;string&gt;(ans));</span><br><span class="line">           return;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j = i;j&lt;l;j++)&#123;</span><br><span class="line">            if(record[i,j])&#123;</span><br><span class="line">                ans.Add(s.Substring(i,j-i+1));</span><br><span class="line">                DFS(s,j+1);</span><br><span class="line">                ans.RemoveAt(ans.Count-1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="单词搜索II（字典树，回溯）"><a href="#单词搜索II（字典树，回溯）" class="headerlink" title="单词搜索II（字典树，回溯）"></a>单词搜索II（字典树，回溯）</h1><p><a href="https://leetcode.cn/problems/word-search-ii/">题目链接</a><br>字典树是一种用于快速查找单词的数据结构，它基于字典实现，每个结点的孩子结点值（即字符）和所属字典树的对应关系都用字典存储。将单词插入到字典树中的步骤是遍历单词的字符，若当前字典树/字典子树不存在与该字符相等的键（即不存在以当前字符为首字母的单词），则将该字符与新字典树组成的键值对加入字典，当遍历到当前单词的最后一个字符时，将该单词存入字典树结点的word属性。在遍历时，我们以board中的每个格为起点做DFS，在该格子对应的DFS结束后进行回溯，再以下一个格子为起点进行DFS。查找时，若当前字典树结点为叶结点或不匹配（字典不存在当前字符对应的键，当前字符不在路径上）则返回，若存在对应键且该键对应的值（字典树）的word属性为单词，说明找到了一个单词，将单词存入ISet，ISet是C#提供的用于集的抽象的基接口，用HashSet实现时，其Add方法保证最后结果的元素互不相同，使用ISet存储结果完美避免了重复的问题。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    int[][] direction = new int[][]&#123;</span><br><span class="line">        new int[]&#123;1,0&#125;,</span><br><span class="line">        new int[]&#123;-1,0&#125;,</span><br><span class="line">        new int[]&#123;0,-1&#125;,</span><br><span class="line">        new int[]&#123;0,1&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    public IList&lt;string&gt; FindWords(char[][] board, string[] words) &#123;//单词搜索II</span><br><span class="line">           Trie trie = new Trie();</span><br><span class="line">           foreach(string word in words)&#123;//构造字典树</span><br><span class="line">               trie.Insert(word);</span><br><span class="line">           &#125;</span><br><span class="line">           ISet&lt;string&gt; ans = new HashSet&lt;string&gt;();//用于集的抽象基接口ISet，可以用HashSet或SortedSet实现</span><br><span class="line">           //使用HashSet的一个重要原因是HashSet中的元素互不相同，和哈希表类似（键互不相同）</span><br><span class="line">           for(int i = 0;i&lt;board.Length;i++)&#123;</span><br><span class="line">               for(int j = 0;j&lt;board[0].Length;j++)&#123;</span><br><span class="line">                   DFS(board,trie,i,j,ans);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">        return new List&lt;string&gt;(ans);</span><br><span class="line">    &#125;</span><br><span class="line">    public void DFS(char[][] board,Trie now,int i1,int j1, ISet&lt;string&gt; ans)&#123;</span><br><span class="line">        if(!now.children.ContainsKey(board[i1][j1]))&#123;</span><br><span class="line">            return;//没有以当前字母为前缀的单词、当前结点为叶结点或不匹配</span><br><span class="line">        &#125;</span><br><span class="line">        char ch = board[i1][j1];</span><br><span class="line">        now=now.children[ch];</span><br><span class="line">        if(!&quot;&quot;.Equals(now.word))&#123;//如果词不为空</span><br><span class="line">            ans.Add(now.word);//这里不return的原因是可能存在以当前词为前缀的词语</span><br><span class="line">        &#125;</span><br><span class="line">        board[i1][j1]=&#x27;#&#x27;;</span><br><span class="line">        foreach(int[] dir in direction)&#123;</span><br><span class="line">            int i2=i1+dir[0],j2=j1+dir[1];</span><br><span class="line">            if(i2&gt;=0&amp;&amp;i2&lt;board.Length&amp;&amp;j2&gt;=0&amp;&amp;j2&lt;board[0].Length)&#123;</span><br><span class="line">               DFS(board,now,i2,j2,ans);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        board[i1][j1]=ch;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">public class Trie&#123;//字典树模板</span><br><span class="line">    public string word;</span><br><span class="line">    public Dictionary&lt;char,Trie&gt; children;</span><br><span class="line">    public Trie()&#123;</span><br><span class="line">        this.word = &quot;&quot;;</span><br><span class="line">        this.children = new Dictionary&lt;char,Trie&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    public void Insert(string word)&#123;</span><br><span class="line">        Trie cur = this;</span><br><span class="line">        foreach(char c in word)&#123;</span><br><span class="line">            if(!cur.children.ContainsKey(c))&#123;</span><br><span class="line">                cur.children.Add(c,new Trie());</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        cur.word=word;//当遍历结束时，cur指向的是以单词最后一个字母为根结点的字典树，让该字典树的word等于存入的word，当DFS遍历到该结点时，如果该结点的word为单词，就说明找到了这个词</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.iset-1?view=net-6.0">ISet C#文档链接</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.hashset-1?view=net-6.0">HashSet C#文档链接</a><br><a href="https://docs.microsoft.com/zh-cn/dotnet/api/system.collections.generic.sortedset-1?view=net-6.0">SortedSet C#文档链接</a></p>
<hr>
<h1 id="修剪二叉搜索树（二叉树、前序遍历、递归）"><a href="#修剪二叉搜索树（二叉树、前序遍历、递归）" class="headerlink" title="修剪二叉搜索树（二叉树、前序遍历、递归）"></a>修剪二叉搜索树（二叉树、前序遍历、递归）</h1><p><a href="https://leetcode.cn/problems/trim-a-binary-search-tree/">题目链接</a><br>对出范围的结点做如下处理：<br>结束递归条件：结点为空<br>出左边界：返回遍历其右子树的结果<br>出右边界：返回遍历其左子树的结果<br>对在范围内的结点，对其左右子树均进行同样的遍历<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left;</span><br><span class="line"> *     public TreeNode right;</span><br><span class="line"> *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode TrimBST(TreeNode root, int low, int high) &#123;//修剪二叉搜索树</span><br><span class="line">          if(root==null)</span><br><span class="line">             return root;</span><br><span class="line">          if(root.val&lt;low)//如果当前结点出左边界，就在该结点的右子树去找</span><br><span class="line">             return TrimBST(root.right,low,high);</span><br><span class="line">          if(root.val&gt;high)//如果当前结点出右边界，就在该结点的左子树去找</span><br><span class="line">             return TrimBST(root.left,low,high);//处理正常的结点</span><br><span class="line">          root.left=TrimBST(root.left,low,high);</span><br><span class="line">          root.right=TrimBST(root.right,low,high);</span><br><span class="line">          return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C#</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
        <tag>二分查找</tag>
        <tag>优先级队列</tag>
        <tag>二叉树</tag>
        <tag>字典树</tag>
        <tag>lambda排序</tag>
        <tag>递归</tag>
      </tags>
  </entry>
  <entry>
    <title>每日力扣2</title>
    <url>/2022/09/13/%E6%AF%8F%E6%97%A5%E5%8A%9B%E6%89%A32/</url>
    <content><![CDATA[<h1 id="今日题目"><a href="#今日题目" class="headerlink" title="今日题目"></a>今日题目</h1><p><strong>最大交换</strong><br><strong>课程表I</strong><br><strong>二叉树最近公共祖先</strong><br><strong>二叉树中的最大路径和</strong><br><strong>删除无效的括号</strong></p>
<hr>
<h1 id="最大交换-lambda排序"><a href="#最大交换-lambda排序" class="headerlink" title="最大交换(lambda排序)"></a>最大交换(lambda排序)</h1><p><a href="https://leetcode.cn/problems/maximum-swap/">题目链接</a><br>思路是将整数先通过ToString转换为string，再通过ToCharArray转换为可以进行单数位交换操作的字符数组ans，借助lambda表达式和Array.Sort对其进行降序排列得到temp，再与原数字进行逐位比较，找到第一个不相等的位置i，由于需要返回一次转换能产生的最大值，故要在后面的数位里去找<strong>值为temp[i]的最小一位</strong>，得到该位置后进行转换，最后将ans通过string的构造方法的重载转换为string，再由int.Parse()转换为最终值。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public int MaximumSwap(int num) &#123;//最大交换</span><br><span class="line">        if(num&lt;=9)</span><br><span class="line">           return num;</span><br><span class="line">        string s = num.ToString();</span><br><span class="line">        char[] temp = s.ToCharArray();</span><br><span class="line">        char[] ans = s.ToCharArray();</span><br><span class="line">        int res = 0;</span><br><span class="line">        Array.Sort(temp,(a,b)=&gt;&#123;return b-a;&#125;);</span><br><span class="line">        for(int i = 0;i&lt;temp.Length;i++)&#123;//temp将所有数字降序排列，s存储的是原数字</span><br><span class="line">            if(temp[i]!=ans[i])&#123;</span><br><span class="line">                int lastlocation = i+1;</span><br><span class="line">                for(int j = i+1;j&lt;temp.Length;j++)&#123;</span><br><span class="line">                     if(ans[j]==temp[i])&#123;</span><br><span class="line">                         lastlocation=j;</span><br><span class="line">                     &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                ans[lastlocation]=ans[i];</span><br><span class="line">                ans[i]=temp[i];</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string s2=new string(ans);</span><br><span class="line">        res = int.Parse(s2);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="课程表I（有向图生成、环检测、回溯、DFS）"><a href="#课程表I（有向图生成、环检测、回溯、DFS）" class="headerlink" title="课程表I（有向图生成、环检测、回溯、DFS）"></a>课程表I（有向图生成、环检测、回溯、DFS）</h1><p><a href="https://leetcode.cn/problems/course-schedule/">题目链接</a><br>该题要求验证是否能找到一个排课顺序，按照这个顺序，所有课在开课前都能修完需要提前修的课程，那么，我们根据这种前趋关系建立一个<strong>有向图</strong>，只用检查有向图中是否存在环即可，如果存在环，说明不存在该顺序。对于出度为0的点，其顺序可任意安排，故不影响结果。<br>我们首先建立存储有向图各结点有向边信息的List<int>类型数组graph，对其进行初始化遍历存储前趋关系的交错数组prerequisites，prerequisites[i][0]为有向边终点，prerequisites[i][1]为起点，按照prerequisites[i][1]找到graph对应List将有向边终点存入，完成图的建立。<br>对于环的检测，我们使用！bool类型数组onPath[] 和visited[]，前者用于判断当前检查的路径是否存在环（即该点是否已经存在于路径上）如果存在环， onPath[0]就置为true，后者用于记录已经在其他路径上遍历过的结点，防止超时（比如“灯笼”型有向图，多个路径指向同一个结点，而这个结点在DFS中已经被在第一条路径中注册了，到遍历其他路径时就不必重复，然而这种情况又要和onPath区分开，不能被误认为环）。以当前结点出发的子路径均检查完毕后，按照回溯，应当将当前结点的onPath置回false，再进行其他路径的检查<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public bool CanFinish(int numCourses, int[][] prerequisites) &#123;//课程表：有向图的环检测</span><br><span class="line">          List&lt;int&gt;[] graph = BuildGraph(numCourses,prerequisites);//课程总数，课程对</span><br><span class="line">          bool[] visited = new bool[numCourses];</span><br><span class="line">          bool[] onPath = new bool[numCourses+1];</span><br><span class="line">          for(int i = 0;i&lt;numCourses;i++)&#123;</span><br><span class="line">              DFS(graph,i,visited,onPath);</span><br><span class="line">          &#125;</span><br><span class="line">          return !onPath[0];//onPath[0]记录是否有环，有就是false，没有就是true，所以要置反</span><br><span class="line">    &#125;</span><br><span class="line">    public List&lt;int&gt;[] BuildGraph(int numCourses,int[][] prerequisites)&#123;</span><br><span class="line">        List&lt;int&gt;[] graph = new List&lt;int&gt;[numCourses];//用List&lt;int&gt;数组建立图，每个List都存着从该点出发的下一个点</span><br><span class="line">        for(int i = 0;i&lt;numCourses;i++)&#123;</span><br><span class="line">            graph[i] = new List&lt;int&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 0;i&lt;prerequisites.Length;i++)&#123;</span><br><span class="line">            int from =prerequisites[i][1];//先修课程为有向边起点，课程为有向边终点</span><br><span class="line">            int to = prerequisites[i][0];</span><br><span class="line">            graph[from].Add(to);</span><br><span class="line">        &#125;</span><br><span class="line">        return graph;//graph</span><br><span class="line">    &#125;</span><br><span class="line">    public void DFS(List&lt;int&gt;[] graph,int s,bool[] visited,bool[] onPath)&#123;</span><br><span class="line">        if(onPath[s+1])&#123;//如果这个地方已经在路径上了，说明有环</span><br><span class="line">              onPath[0]=true;</span><br><span class="line">        &#125;</span><br><span class="line">        if(visited[s]||onPath[0])&#123;//如果已经访问过了（由于是DFS，所以可能这个结点已经在已知的路径里了）或者已经证明有环了，那就返回。onPath判断在后用时最短（因为能通过的例子里onPath都是负，还要再判断visited[s]是不是true）</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[s]=true;</span><br><span class="line">        onPath[s+1]=true;</span><br><span class="line">        List&lt;int&gt; temp=graph[s];</span><br><span class="line">        for(int i = 0;i &lt; temp.Count;i++)&#123;</span><br><span class="line">            DFS(graph,temp[i],visited,onPath);</span><br><span class="line">        &#125;</span><br><span class="line">        onPath[s+1]=false;//这个回溯至关重要，如果没有这个回溯，就会出现因为visied[s]==true（即在前面遍历过）而导致onPath[0]=true</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二叉树的最近公共祖先（二叉树、DFS）"><a href="#二叉树的最近公共祖先（二叉树、DFS）" class="headerlink" title="二叉树的最近公共祖先（二叉树、DFS）"></a>二叉树的最近公共祖先（二叉树、DFS）</h1><p><a href="https://leetcode.cn/problems/lowest-common-ancestor-of-a-binary-tree/">题目链接</a><br>这道题的一个重要条件就是<strong>两个值均在二叉树中</strong>，所以对于p和q而言，只会有以下三种情况：<br>p和q都不是对方的最近公共祖先<br>p或q是最近公共祖先（两种）<br>如果遇到p或q，直接返回该结点，若其他子树返回的是null（即到了叶结点也没找到p或q，那就只能在返回不为null的子树里），就说明该结点是最近公共祖先<br>如果p和q分别在该结点的左右子树找到了（返回不为null），就说明当前结点是最近公共祖先，返回该结点<br>如果p和q都没找到，自己也不是p或q，就返回null<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left;</span><br><span class="line"> *     public TreeNode right;</span><br><span class="line"> *     public TreeNode(int x) &#123; val = x; &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public TreeNode LowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;//二叉树最近公共祖先</span><br><span class="line">        if(root==q||root==p||root==null)</span><br><span class="line">         return root;</span><br><span class="line">        TreeNode left=LowestCommonAncestor(root.left,p,q);</span><br><span class="line">        TreeNode right=LowestCommonAncestor(root.right,p,q);</span><br><span class="line">        TreeNode res=new TreeNode();</span><br><span class="line">        if(left==null&amp;&amp;right==null)&#123;</span><br><span class="line">            res= null;</span><br><span class="line">        &#125;else if(left!=null&amp;&amp;right!=null)&#123;</span><br><span class="line">            res= root;</span><br><span class="line">        &#125;else if(left!=null&amp;&amp;right==null)&#123;</span><br><span class="line">            res= left;</span><br><span class="line">        &#125;else if(right!=null&amp;&amp;left==null)&#123;</span><br><span class="line">            res= right;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="二叉树中的最大路径和（二叉树，DFS）"><a href="#二叉树中的最大路径和（二叉树，DFS）" class="headerlink" title="二叉树中的最大路径和（二叉树，DFS）"></a>二叉树中的最大路径和（二叉树，DFS）</h1><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">题目链接</a><br>这种情况适合DFS，从叶结点开始向祖先结点返回其子树的最大路径和，同时每个结点应先比较以下四个值，取最大值：<br>当前最大值<br>左右子树最大路径和较大者+自身值<br>自身值<br>自身值+左右子树的最大路径<br>向上返回时，比较自身值和自身+左右子树最大路径和较大者，返回较大的。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * public class TreeNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public TreeNode left;</span><br><span class="line"> *     public TreeNode right;</span><br><span class="line"> *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.left = left;</span><br><span class="line"> *         this.right = right;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">private int res = Int32.MinValue;</span><br><span class="line">    public int MaxPathSum(TreeNode root) &#123;//二叉树中的最大路径和</span><br><span class="line">        DFS(root);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    public int DFS(TreeNode root)&#123;//算是DFS吧，前序遍历</span><br><span class="line">        if(root==null)</span><br><span class="line">           return 0;</span><br><span class="line">        int left = DFS(root.left);</span><br><span class="line">        int right = DFS(root.right);</span><br><span class="line">        int max = Math.Max(left,right);</span><br><span class="line">        int[] arr = &#123;res,root.val+left+right,root.val,root.val+max&#125;;</span><br><span class="line">        Array.Sort(arr);</span><br><span class="line">        res = arr[3]; //将当前最大值、当前子树和、根值、根与最大子路径和进行比较</span><br><span class="line">        return Math.Max(root.val,root.val+max);//要么返回根结点，要么返回根结点与最大子路径和</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="删除无效的括号（BFS）"><a href="#删除无效的括号（BFS）" class="headerlink" title="删除无效的括号（BFS）"></a>删除无效的括号（BFS）</h1><p><a href="https://leetcode.cn/problems/remove-invalid-parentheses/">题目链接</a><br>我们使用HashSet来存储每层进行删除一个括号后所产生的所有结果以<strong>避免重复</strong>，针对相连左右括号和字符串首的括号进行删除操作。由于题目要求返回删除次数最小的有效字符串，故一旦当前步数（层数）产生了有效字符串（HashSet.Count&gt;0)，就返回结果。<br>检查当前字符串是否有效的逻辑是遍历该字符串，记录需要右括号的左括号个数，若左括号小于0则说明当前字符串无效，若遍历后左括号个数大于0说明缺少右括号，即当前字符串无效。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public IList&lt;string&gt; RemoveInvalidParentheses(string s) &#123;//删除无效的括号-BFS</span><br><span class="line">         List&lt;string&gt; res = new List&lt;string&gt;();</span><br><span class="line">         ISet&lt;string&gt; cur = new HashSet&lt;string&gt;();</span><br><span class="line">         cur.Add(s);</span><br><span class="line">         while(true)&#123;</span><br><span class="line">            foreach(string str in cur)&#123;</span><br><span class="line">                if(IsValid(str))&#123;</span><br><span class="line">                    res.Add(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if(res.Count&gt;0)&#123;</span><br><span class="line">                return res;</span><br><span class="line">            &#125;</span><br><span class="line">             ISet&lt;string&gt; next = new HashSet&lt;string&gt;();</span><br><span class="line">            foreach(string str in cur)&#123;</span><br><span class="line">                for(int i = 0;i&lt;str.Length;i++)&#123;</span><br><span class="line">                    if(i&gt;0&amp;&amp;str[i]==str[i-1])&#123;</span><br><span class="line">                        continue;</span><br><span class="line">                    &#125;if(str[i]==&#x27;(&#x27;||str[i]==&#x27;)&#x27;)</span><br><span class="line">                       next.Add(str.Substring(0,i)+str.Substring(i+1)); //SubString的两种重载用法：前者返回以0位起点的i长度子串，后者截取以i+1为起点的字符串剩余部分，这两个重载结合起来的用法就是生成删除了当前位字符的字符串。             </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = next;</span><br><span class="line">         &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    public bool IsValid(string s)&#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        for(int i = 0;i&lt;s.Length;i++)&#123;</span><br><span class="line">             if(s[i]==&#x27;(&#x27;)&#123;</span><br><span class="line">                  left++;</span><br><span class="line">             &#125;else if(s[i]==&#x27;)&#x27;)&#123;</span><br><span class="line">                 left--;</span><br><span class="line">             &#125;</span><br><span class="line">             if(left&lt;0)</span><br><span class="line">                return false;</span><br><span class="line">         &#125;</span><br><span class="line">         return left==0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>LeetCode</tag>
        <tag>C#</tag>
        <tag>回溯</tag>
        <tag>DFS</tag>
        <tag>二叉树</tag>
        <tag>有向图的环检测</tag>
        <tag>有向图生成</tag>
        <tag>BFS</tag>
      </tags>
  </entry>
  <entry>
    <title>每日力扣3</title>
    <url>/2022/09/14/%E6%AF%8F%E6%97%A5%E5%8A%9B%E6%89%A33/</url>
    <content><![CDATA[<h1 id="今日题目"><a href="#今日题目" class="headerlink" title="今日题目"></a>今日题目</h1><p><strong>正则表达式匹配</strong><br><strong>通配符匹配</strong><br><strong>复制带随机指针的链表</strong><br><strong>合并K个排序链表</strong><br><strong>最小覆盖子串</strong></p>
<hr>
<h1 id="正则表达式匹配（动态规划）"><a href="#正则表达式匹配（动态规划）" class="headerlink" title="正则表达式匹配（动态规划）"></a>正则表达式匹配（动态规划）</h1><p><a href="https://leetcode.cn/problems/zheng-ze-biao-da-shi-pi-pei-lcof/">题目链接</a><br>.匹配任意单个字符，<em>要么匹配长度为0的子串要么匹配长度不为0的和前一个字符一样的子串。和上一题类似，我们用一个二维bool数组dp=new bool[m+1,n+1]来存储s中1到i，p中1到j的匹配情况。而dp[i,j]的递推公式，我们发现，当p[j-1]，即第j个字符为字母的时候，只要判断和当前的第i个字符是否匹配即可，即dp[i,j]=dp[i-1,j-1]&amp;&amp;s[i-1]==p[j-1];<br>当其为’.’的时候，直接i++,j++;当其为’</em>‘的时候，我们先判断s[i-1]是否等于p[j-2]，如果不相等就等同于匹配长度为0的子串，即dp[i,j]=dp[i,j-2]，如果相等，就仍然和最开始的那样有两种选择。如果匹配长度为0的子串，直接dp[i,j]=dp[i,j-2]即可，如果匹配长度不为0的子串，则有以下的规律：<br>f[i][j]=f[i−1][j−2],if s[i]=p[j−1]<br>f[i][j]=f[i−2][j−2],if s[i−1]=s[i]=p[j−1]<br>f[i][j]=f[i−3][j−2],if s[i−2]=s[i−1]=s[i]=p[j−1]<br>⋯⋯<br>我们可以转成一个很巧妙的带有递归思想的式子：dp[i,j]=dp[i-1,j]，如果s[i-2]=p[j-2]的话，将继续触发dp[i-2,j]，如此往复直至到达这串相同字母的最左侧。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public bool IsMatch(string s, string p) &#123;//正则表达式匹配</span><br><span class="line">        int m = s.Length;</span><br><span class="line">        int n = p.Length;</span><br><span class="line">        bool[,] dp = new bool[m+1,n+1];</span><br><span class="line">        dp[0,0] = true;</span><br><span class="line">        for(int i = 0;i&lt;m+1;i++)&#123;</span><br><span class="line">            for(int j = 1;j&lt;n+1;j++)&#123;</span><br><span class="line">                if(p[j-1]==&#x27;*&#x27;)&#123;</span><br><span class="line">                    dp[i,j]=dp[i,j-2];</span><br><span class="line">                    if(match(s,p,i,j-1))&#123;</span><br><span class="line">                        dp[i,j]=dp[i,j]||dp[i-1,j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    if(match(s,p,i,j))&#123;</span><br><span class="line">                        dp[i,j]=dp[i-1,j-1];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[m,n];</span><br><span class="line">    &#125;</span><br><span class="line">    public bool match(string s,string p,int i,int j)&#123;</span><br><span class="line">        if(i==0)</span><br><span class="line">           return false;</span><br><span class="line">        if(p[j-1]==&#x27;.&#x27;)</span><br><span class="line">           return true;</span><br><span class="line">        return s[i-1]==p[j-1];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="通配符匹配（动态规划）"><a href="#通配符匹配（动态规划）" class="headerlink" title="通配符匹配（动态规划）"></a>通配符匹配（动态规划）</h1><p><a href="https://leetcode.cn/problems/wildcard-matching/">题目链接</a><br>(和上面的类似，实在不想写了)<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public bool IsMatch(string s, string p) &#123;//通配符匹配</span><br><span class="line">        int m = s.Length;</span><br><span class="line">        int n = p.Length;</span><br><span class="line">        bool[,] record= new bool[m+1,n+1];</span><br><span class="line">        record[0,0]=true;</span><br><span class="line">        for(int i = 1;i&lt;n+1;i++)&#123;</span><br><span class="line">            if(p[i-1]==&#x27;*&#x27;)&#123;</span><br><span class="line">                record[0,i]=true;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int i = 1;i&lt;m+1;i++)&#123;</span><br><span class="line">            for(int j = 1;j&lt;n+1;j++)&#123;</span><br><span class="line">                if(p[j-1]==&#x27;*&#x27;)&#123;</span><br><span class="line">                    record[i,j]=(record[i,j-1]||record[i-1,j]);//要么不匹配，要么匹配</span><br><span class="line">                &#125;else if(p[j-1]==&#x27;?&#x27;||p[j-1]==s[i-1])&#123;</span><br><span class="line">                    record[i,j]=record[i-1,j-1];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return record[m,n]==true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="复制带随机指针的链表（链表、哈希表）"><a href="#复制带随机指针的链表（链表、哈希表）" class="headerlink" title="复制带随机指针的链表（链表、哈希表）"></a>复制带随机指针的链表（链表、哈希表）</h1><p><a href="https://leetcode.cn/problems/copy-list-with-random-pointer/">题目链接</a><br>使用哈希表存储新链表中结点和旧链表的对应关系，同时我们可以通过HashMap.get(p.random)直接获取对应的q.random<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">// Definition for a Node.</span><br><span class="line">class Node &#123;</span><br><span class="line">    int val;</span><br><span class="line">    Node next;</span><br><span class="line">    Node random;</span><br><span class="line"></span><br><span class="line">    public Node(int val) &#123;</span><br><span class="line">        this.val = val;</span><br><span class="line">        this.next = null;</span><br><span class="line">        this.random = null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">class Solution &#123;</span><br><span class="line">    public Node copyRandomList(Node head) &#123;//复制带随机指针的链表-Java</span><br><span class="line">        Node p = head;//</span><br><span class="line">        Node q = new Node(0);</span><br><span class="line">        Node res = q;</span><br><span class="line">        Node tempRandom = new Node(0);//指向random的指针</span><br><span class="line">        HashMap&lt;Node,Node&gt; record = new HashMap&lt;&gt;();</span><br><span class="line">        while(p!=null)&#123;//录入新旧链表中结点的对应关系</span><br><span class="line">             q.next = new Node(p.val);</span><br><span class="line">             record.put(p,q.next);</span><br><span class="line">             p=p.next;</span><br><span class="line">             q=q.next;</span><br><span class="line">        &#125;   </span><br><span class="line">        p=head;</span><br><span class="line">        q=res.next;</span><br><span class="line">        while(p!=null)&#123;</span><br><span class="line">             tempRandom=record.get(p.random);</span><br><span class="line">             q.random=tempRandom;</span><br><span class="line">             p=p.next;</span><br><span class="line">             q=q.next;</span><br><span class="line">        &#125;  </span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="合并K个升序链表（链表、分治法）"><a href="#合并K个升序链表（链表、分治法）" class="headerlink" title="合并K个升序链表（链表、分治法）"></a>合并K个升序链表（链表、分治法）</h1><p><a href="https://leetcode.cn/problems/merge-k-sorted-lists/">题目链接</a><br>分治法的思路就是用相同的步骤将大的问题分解成多个小问题解决。这个题我们将多个链表进行分组，每个组只有一个链表或两个链表，将两个链表合并成一个链表，如此递归向上直至返回结果。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * public class ListNode &#123;</span><br><span class="line"> *     public int val;</span><br><span class="line"> *     public ListNode next;</span><br><span class="line"> *     public ListNode(int val=0, ListNode next=null) &#123;</span><br><span class="line"> *         this.val = val;</span><br><span class="line"> *         this.next = next;</span><br><span class="line"> *     &#125;</span><br><span class="line"> * &#125;</span><br><span class="line"> */</span><br><span class="line">public class Solution &#123;</span><br><span class="line">    public ListNode MergeKLists(ListNode[] lists) &#123;//排序链表-分治法：化大为小，思路统一</span><br><span class="line">          if(lists.Length==0)//如果没有链表</span><br><span class="line">            return null;</span><br><span class="line">          return FenZhi(lists,0,lists.Length-1);</span><br><span class="line">    &#125;</span><br><span class="line">    public ListNode FenZhi(ListNode[] lists,int left, int right)&#123;</span><br><span class="line">         if(left==right)//如果就一个链表了</span><br><span class="line">            return lists[left];</span><br><span class="line">         if(left&gt;right)</span><br><span class="line">            return null;</span><br><span class="line">         int m = right+left&gt;&gt;1;//实际上就是(r+l)/2,利用了运算符优先级</span><br><span class="line">         return merge(FenZhi(lists,left,m),FenZhi(lists,m+1,right));//将几个链表拆分到最小组，然后递归merge</span><br><span class="line">    &#125;</span><br><span class="line">    public ListNode merge(ListNode l1,ListNode l2)&#123;</span><br><span class="line">        if(l1==null)</span><br><span class="line">          return l2;</span><br><span class="line">        if(l2==null)</span><br><span class="line">          return l1;</span><br><span class="line">        ListNode res= new ListNode();//新链表的头结点，res.next才是结果的头结点</span><br><span class="line">        ListNode temp = res;//指向当前插入位置的前一个结点</span><br><span class="line">        while(l1!=null&amp;&amp;l2!=null)&#123;//如果两个链表都不为空</span><br><span class="line">            if(l1.val&lt;l2.val)&#123;</span><br><span class="line">                temp.next=l1;</span><br><span class="line">                l1=l1.next;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                temp.next=l2;</span><br><span class="line">                l2=l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            temp=temp.next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(l1!=null)&#123;</span><br><span class="line">            temp.next=l1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            temp.next=l2;</span><br><span class="line">        &#125;</span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h1 id="最小覆盖子串（滑动窗口）"><a href="#最小覆盖子串（滑动窗口）" class="headerlink" title="最小覆盖子串（滑动窗口）"></a>最小覆盖子串（滑动窗口）</h1><p><a href="https://leetcode.cn/problems/minimum-window-substring/">题目链接</a><br>滑动窗口的核心思路就是反复调整左右边界以实现目的。在本题中如果当前窗口满足条件了（包含t中的所有字符），就收缩左边界直至不满足条件了，然后右边界扩张直至满足条件，如此循环。<br>来看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public string MinWindow(string s, string t) &#123;</span><br><span class="line">        char[] S = s.ToCharArray();</span><br><span class="line">        char[] T = t.ToCharArray();//匹配的时候用这俩数组和字典，截取的时候用 res=s.Substring()</span><br><span class="line">        //字典是这个题的要素，字典内的值有两种，一种是缺省值Int32.MaxValue，用来判断当前字母在t里有没有</span><br><span class="line">        //另一种是会变化的，用来表示滑动窗口内至少应该包含多少个该类字母，如果右边界右扩的时候遇到需要的字母，对应的值就会-1，表示收集到了一个这类字母，而左边界右缩的时候如果遇到了该类字母，对应的值就要+1，表示该类字母在滑动窗口内的需求量+1。</span><br><span class="line">        Dictionary&lt;char,int&gt; dict = new Dictionary&lt;char,int&gt;();</span><br><span class="line">        int l = S.Length;</span><br><span class="line">        int min = Int32.MaxValue;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int threshold = 0;</span><br><span class="line">        int cnt = 0;//cnt用于统计当前滑动窗口内的目标字母集齐了多少个，cnt++的触发条件是字典中t里包含的字母对应的数量变为0，即滑动窗口内有和t一样多的该字母</span><br><span class="line">        int left = 0;</span><br><span class="line">        int right = 0;</span><br><span class="line">        for(int i = 0;i&lt; T.Length;i++)&#123;</span><br><span class="line">            if(!dict.ContainsKey(T[i]))&#123;</span><br><span class="line">                dict.Add(T[i],0);</span><br><span class="line">            &#125;</span><br><span class="line">            int val = dict[T[i]]+1;</span><br><span class="line">            if(val==1)</span><br><span class="line">              threshold++;//指的是有t里有多少种字母</span><br><span class="line">            dict[T[i]]=val;</span><br><span class="line">        &#125;</span><br><span class="line">        while(right&lt;l)&#123;</span><br><span class="line">            if(!dict.ContainsKey(S[right]))&#123;</span><br><span class="line">                dict.Add(S[right],Int32.MaxValue);</span><br><span class="line">            &#125;</span><br><span class="line">            int rval = dict[S[right]];</span><br><span class="line">            if(rval == Int32.MaxValue)&#123;</span><br><span class="line">                right++;</span><br><span class="line">                continue;</span><br><span class="line">            &#125;</span><br><span class="line">            if(--rval==0)&#123;//怎么着都要减，如果这个字母的数量减为0了，说明滑动窗口内该字母的数量达到要求，也就是集齐了这个字母</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125;</span><br><span class="line">            dict[S[right]]=rval;</span><br><span class="line">            while(cnt==threshold &amp;&amp; left&lt;=right)&#123;</span><br><span class="line">                int length = right - left+1;</span><br><span class="line">                if(length&lt;min)&#123;</span><br><span class="line">                    min = length;</span><br><span class="line">                    res=s.Substring(left,length);</span><br><span class="line">                &#125;</span><br><span class="line">                int lval = dict[S[left]];</span><br><span class="line">                if(lval==Int32.MaxValue)&#123;//如果left指向的字母t里没有，说明没啥用，可以继续缩小左边界</span><br><span class="line">                    left++;</span><br><span class="line">                    continue;</span><br><span class="line">                &#125;</span><br><span class="line">                if(lval==0)&#123;//如果left指向的字母在滑动窗口内的数量刚好满足要求，然而left右移会导致滑动窗口内缺一个该字母，导致滑动窗口不满足要求，从而触发当前while循环终止，进入right右扩循环</span><br><span class="line">                    cnt--;</span><br><span class="line">                &#125;</span><br><span class="line">                dict[S[left]]=++lval;//能执行到这里的都是left指向的字母在t里有，left右扩会导致窗口需要更多的该字母，所以字典内对应的值+1</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
]]></content>
      <categories>
        <category>力扣</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>LeetCode</tag>
        <tag>C#</tag>
        <tag>递归</tag>
        <tag>BFS</tag>
        <tag>链表</tag>
        <tag>分治法</tag>
        <tag>动态规划</tag>
        <tag>滑动窗口</tag>
        <tag>哈希表</tag>
      </tags>
  </entry>
</search>
